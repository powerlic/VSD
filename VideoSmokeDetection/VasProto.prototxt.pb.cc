// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: VasProto.prototxt
#include"stdafx.h"
#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "VasProto.prototxt.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace vas {

namespace {

const ::google::protobuf::Descriptor* NvrParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NvrParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* NvrChannel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NvrChannel_reflection_ = NULL;
const ::google::protobuf::Descriptor* DecodeParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DecodeParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* BgGuassianParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BgGuassianParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* BgVibeParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BgVibeParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* BgOperation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BgOperation_reflection_ = NULL;
const ::google::protobuf::Descriptor* BgParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BgParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColorThreshold_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColorThreshold_reflection_ = NULL;
const ::google::protobuf::Descriptor* FilterParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FilterParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* CaffeClassifierParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CaffeClassifierParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* DetectParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DetectParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* SsdDetecterParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SsdDetecterParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* CaffeModelPath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CaffeModelPath_reflection_ = NULL;
const ::google::protobuf::Descriptor* SsdModelPath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SsdModelPath_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServiceParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServiceParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* SsdServiceParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SsdServiceParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* NvrServiceParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NvrServiceParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServiceList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServiceList_reflection_ = NULL;
const ::google::protobuf::Descriptor* SsdServiceList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SsdServiceList_reflection_ = NULL;
const ::google::protobuf::Descriptor* NvrServiceList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NvrServiceList_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasComParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasComParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasComputeNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasComputeNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasClientParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasClientParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasMsgFilterParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasMsgFilterParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasHeartbeatParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasHeartbeatParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasHeartbeat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasHeartbeat_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasRetrunParamter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasRetrunParamter_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasReturn_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasReturn_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegRes_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasResultParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasResultParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasResult_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasResult_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasFeedbackParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasFeedbackParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* VasFeedback_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VasFeedback_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DecodeMethod_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* VideoSource_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CamStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* StreamStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* BgStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* BgMethod_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FilterMethod_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FilterType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* DetectStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ServiceStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ServiceCommandReply_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RegMsgSubscribe_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EnAppState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_VasProto_2eprototxt() {
  protobuf_AddDesc_VasProto_2eprototxt();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "VasProto.prototxt");
  GOOGLE_CHECK(file != NULL);
  NvrParameter_descriptor_ = file->message_type(0);
  static const int NvrParameter_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, user_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, password_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, connect_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, reconnect_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, check_interval_),
  };
  NvrParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NvrParameter_descriptor_,
      NvrParameter::default_instance_,
      NvrParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NvrParameter));
  NvrChannel_descriptor_ = file->message_type(1);
  static const int NvrChannel_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, channel_no_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, cam_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, interval_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, dst_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, dst_height_),
  };
  NvrChannel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NvrChannel_descriptor_,
      NvrChannel::default_instance_,
      NvrChannel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrChannel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NvrChannel));
  DecodeParameter_descriptor_ = file->message_type(2);
  static const int DecodeParameter_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, decode_method_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, dst_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, dst_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, interval_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, max_reconnect_times_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, reconnect_sleep_times_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, max_decode_error_frames_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, stream_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, total_ms_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, connect_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, video_source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, print_decode_count_),
  };
  DecodeParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DecodeParameter_descriptor_,
      DecodeParameter::default_instance_,
      DecodeParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecodeParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DecodeParameter));
  BgGuassianParameter_descriptor_ = file->message_type(3);
  static const int BgGuassianParameter_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgGuassianParameter, num_history_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgGuassianParameter, var_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgGuassianParameter, shadow_detection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgGuassianParameter, learn_rate_),
  };
  BgGuassianParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BgGuassianParameter_descriptor_,
      BgGuassianParameter::default_instance_,
      BgGuassianParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgGuassianParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgGuassianParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BgGuassianParameter));
  BgVibeParameter_descriptor_ = file->message_type(4);
  static const int BgVibeParameter_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, num_samples_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, min_match_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, subsample_factor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, bg2_delay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, max_mismatch_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, double_bg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, learn_rate_),
  };
  BgVibeParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BgVibeParameter_descriptor_,
      BgVibeParameter::default_instance_,
      BgVibeParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgVibeParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BgVibeParameter));
  BgOperation_descriptor_ = file->message_type(5);
  static const int BgOperation_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgOperation, morphology_open_times_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgOperation, dilate_times_),
  };
  BgOperation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BgOperation_descriptor_,
      BgOperation::default_instance_,
      BgOperation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgOperation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgOperation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BgOperation));
  BgParameter_descriptor_ = file->message_type(6);
  static const int BgParameter_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, bg_method_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, stable_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, guassian_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, vibe_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, bg_operation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, bg_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, bg_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, bg_height_),
  };
  BgParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BgParameter_descriptor_,
      BgParameter::default_instance_,
      BgParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BgParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BgParameter));
  ColorThreshold_descriptor_ = file->message_type(7);
  static const int ColorThreshold_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorThreshold, lower_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorThreshold, upper_),
  };
  ColorThreshold_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColorThreshold_descriptor_,
      ColorThreshold::default_instance_,
      ColorThreshold_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorThreshold, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColorThreshold, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColorThreshold));
  FilterParameter_descriptor_ = file->message_type(8);
  static const int FilterParameter_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, contour_area_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, contour_perimeter_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, area_perimeter_ratio_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, filter_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, rgb_th_1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, rgb_th_2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, ycbcr_th_1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, ycbcr_th_2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, color_fit_ratio_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, filter_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, filter_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, filter_method_),
  };
  FilterParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FilterParameter_descriptor_,
      FilterParameter::default_instance_,
      FilterParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilterParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FilterParameter));
  CaffeClassifierParameter_descriptor_ = file->message_type(9);
  static const int CaffeClassifierParameter_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeClassifierParameter, confience_score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeClassifierParameter, input_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeClassifierParameter, model_version_),
  };
  CaffeClassifierParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CaffeClassifierParameter_descriptor_,
      CaffeClassifierParameter::default_instance_,
      CaffeClassifierParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeClassifierParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeClassifierParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CaffeClassifierParameter));
  DetectParameter_descriptor_ = file->message_type(10);
  static const int DetectParameter_offsets_[23] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, reg_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, smoke_detect_sensitity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, fire_detect_sensitity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, num_history_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, reg_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, reg_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, reg_interval_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, bg_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, filter_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, caffe_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, detect_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, merge_fore_rects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, show_result_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, show_bg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, show_reg_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, print_reg_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, show_smoke_hot_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, show_fire_hot_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, save_reg_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, save_video_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, move_area_for_reg_only_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, show_move_area_for_reg_only_),
  };
  DetectParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DetectParameter_descriptor_,
      DetectParameter::default_instance_,
      DetectParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DetectParameter));
  SsdDetecterParameter_descriptor_ = file->message_type(11);
  static const int SsdDetecterParameter_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, reg_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, reg_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, reg_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, detect_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, show_result_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, show_reg_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, save_video_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, save_reg_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, reg_interval_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, confidence_threshold_),
  };
  SsdDetecterParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SsdDetecterParameter_descriptor_,
      SsdDetecterParameter::default_instance_,
      SsdDetecterParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdDetecterParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SsdDetecterParameter));
  CaffeModelPath_descriptor_ = file->message_type(12);
  static const int CaffeModelPath_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, deploy_file_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, trained_model_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, label_file_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, mean_file_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, input_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, model_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, use_gpu_),
  };
  CaffeModelPath_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CaffeModelPath_descriptor_,
      CaffeModelPath::default_instance_,
      CaffeModelPath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CaffeModelPath, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CaffeModelPath));
  SsdModelPath_descriptor_ = file->message_type(13);
  static const int SsdModelPath_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, deploy_file_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, trained_model_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, label_file_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, mean_file_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, mean_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, model_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, use_gpu_),
  };
  SsdModelPath_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SsdModelPath_descriptor_,
      SsdModelPath::default_instance_,
      SsdModelPath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdModelPath, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SsdModelPath));
  ServiceParameter_descriptor_ = file->message_type(14);
  static const int ServiceParameter_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceParameter, decode_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceParameter, detect_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceParameter, service_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceParameter, reg_msg_subscribe_),
  };
  ServiceParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServiceParameter_descriptor_,
      ServiceParameter::default_instance_,
      ServiceParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServiceParameter));
  SsdServiceParameter_descriptor_ = file->message_type(15);
  static const int SsdServiceParameter_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceParameter, decode_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceParameter, detect_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceParameter, service_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceParameter, reg_msg_subscribe_),
  };
  SsdServiceParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SsdServiceParameter_descriptor_,
      SsdServiceParameter::default_instance_,
      SsdServiceParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SsdServiceParameter));
  NvrServiceParameter_descriptor_ = file->message_type(16);
  static const int NvrServiceParameter_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceParameter, nvr_channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceParameter, detect_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceParameter, service_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceParameter, reg_msg_subscribe_),
  };
  NvrServiceParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NvrServiceParameter_descriptor_,
      NvrServiceParameter::default_instance_,
      NvrServiceParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NvrServiceParameter));
  ServiceList_descriptor_ = file->message_type(17);
  static const int ServiceList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceList, last_update_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceList, service_paramter_),
  };
  ServiceList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServiceList_descriptor_,
      ServiceList::default_instance_,
      ServiceList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServiceList));
  SsdServiceList_descriptor_ = file->message_type(18);
  static const int SsdServiceList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceList, last_update_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceList, service_paramter_),
  };
  SsdServiceList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SsdServiceList_descriptor_,
      SsdServiceList::default_instance_,
      SsdServiceList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SsdServiceList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SsdServiceList));
  NvrServiceList_descriptor_ = file->message_type(19);
  static const int NvrServiceList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceList, nvr_paramter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceList, service_parameter_),
  };
  NvrServiceList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NvrServiceList_descriptor_,
      NvrServiceList::default_instance_,
      NvrServiceList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NvrServiceList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NvrServiceList));
  VasComParameter_descriptor_ = file->message_type(20);
  static const int VasComParameter_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComParameter, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComParameter, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComParameter, app_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComParameter, heartbeat_interval_),
  };
  VasComParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasComParameter_descriptor_,
      VasComParameter::default_instance_,
      VasComParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasComParameter));
  VasComputeNode_descriptor_ = file->message_type(21);
  static const int VasComputeNode_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComputeNode, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComputeNode, node_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComputeNode, center_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComputeNode, com_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComputeNode, retry_count_),
  };
  VasComputeNode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasComputeNode_descriptor_,
      VasComputeNode::default_instance_,
      VasComputeNode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComputeNode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasComputeNode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasComputeNode));
  VasClientParameter_descriptor_ = file->message_type(22);
  static const int VasClientParameter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasClientParameter, com_param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasClientParameter, node_param_),
  };
  VasClientParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasClientParameter_descriptor_,
      VasClientParameter::default_instance_,
      VasClientParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasClientParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasClientParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasClientParameter));
  VasMsgFilterParam_descriptor_ = file->message_type(23);
  static const int VasMsgFilterParam_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasMsgFilterParam, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasMsgFilterParam, interval_sec_),
  };
  VasMsgFilterParam_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasMsgFilterParam_descriptor_,
      VasMsgFilterParam::default_instance_,
      VasMsgFilterParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasMsgFilterParam, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasMsgFilterParam, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasMsgFilterParam));
  VasHeartbeatParameter_descriptor_ = file->message_type(24);
  static const int VasHeartbeatParameter_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeatParameter, app_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeatParameter, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeatParameter, service_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeatParameter, timestamp_),
  };
  VasHeartbeatParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasHeartbeatParameter_descriptor_,
      VasHeartbeatParameter::default_instance_,
      VasHeartbeatParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeatParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeatParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasHeartbeatParameter));
  VasHeartbeat_descriptor_ = file->message_type(25);
  static const int VasHeartbeat_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeat, psi_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeat, params_),
  };
  VasHeartbeat_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasHeartbeat_descriptor_,
      VasHeartbeat::default_instance_,
      VasHeartbeat_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeat, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasHeartbeat, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasHeartbeat));
  VasRetrunParamter_descriptor_ = file->message_type(26);
  static const int VasRetrunParamter_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasRetrunParamter, psi_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasRetrunParamter, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasRetrunParamter, timestamp_),
  };
  VasRetrunParamter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasRetrunParamter_descriptor_,
      VasRetrunParamter::default_instance_,
      VasRetrunParamter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasRetrunParamter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasRetrunParamter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasRetrunParamter));
  VasReturn_descriptor_ = file->message_type(27);
  static const int VasReturn_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasReturn, ret_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasReturn, ret_msg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasReturn, params_),
  };
  VasReturn_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasReturn_descriptor_,
      VasReturn::default_instance_,
      VasReturn_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasReturn, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasReturn, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasReturn));
  RegRes_descriptor_ = file->message_type(28);
  static const int RegRes_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, reg_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, height_),
  };
  RegRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegRes_descriptor_,
      RegRes::default_instance_,
      RegRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegRes));
  VasResultParameter_descriptor_ = file->message_type(29);
  static const int VasResultParameter_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResultParameter, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResultParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResultParameter, result_rects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResultParameter, timestamp_),
  };
  VasResultParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasResultParameter_descriptor_,
      VasResultParameter::default_instance_,
      VasResultParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResultParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResultParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasResultParameter));
  VasResult_descriptor_ = file->message_type(30);
  static const int VasResult_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResult, psi_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResult, params_),
  };
  VasResult_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasResult_descriptor_,
      VasResult::default_instance_,
      VasResult_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResult, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasResult, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasResult));
  VasFeedbackParameter_descriptor_ = file->message_type(31);
  static const int VasFeedbackParameter_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, service_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, address_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, device_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, device_channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, feedback_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, feedback_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, timestamp_),
  };
  VasFeedbackParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasFeedbackParameter_descriptor_,
      VasFeedbackParameter::default_instance_,
      VasFeedbackParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedbackParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasFeedbackParameter));
  VasFeedback_descriptor_ = file->message_type(32);
  static const int VasFeedback_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedback, psi_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedback, params_),
  };
  VasFeedback_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VasFeedback_descriptor_,
      VasFeedback::default_instance_,
      VasFeedback_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedback, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VasFeedback, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VasFeedback));
  DecodeMethod_descriptor_ = file->enum_type(0);
  VideoSource_descriptor_ = file->enum_type(1);
  CamStatus_descriptor_ = file->enum_type(2);
  StreamStatus_descriptor_ = file->enum_type(3);
  BgStatus_descriptor_ = file->enum_type(4);
  BgMethod_descriptor_ = file->enum_type(5);
  FilterMethod_descriptor_ = file->enum_type(6);
  FilterType_descriptor_ = file->enum_type(7);
  DetectStatus_descriptor_ = file->enum_type(8);
  ServiceStatus_descriptor_ = file->enum_type(9);
  ServiceCommandReply_descriptor_ = file->enum_type(10);
  RegMsgSubscribe_descriptor_ = file->enum_type(11);
  EnAppState_descriptor_ = file->enum_type(12);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_VasProto_2eprototxt);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NvrParameter_descriptor_, &NvrParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NvrChannel_descriptor_, &NvrChannel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DecodeParameter_descriptor_, &DecodeParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BgGuassianParameter_descriptor_, &BgGuassianParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BgVibeParameter_descriptor_, &BgVibeParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BgOperation_descriptor_, &BgOperation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BgParameter_descriptor_, &BgParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColorThreshold_descriptor_, &ColorThreshold::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FilterParameter_descriptor_, &FilterParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CaffeClassifierParameter_descriptor_, &CaffeClassifierParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DetectParameter_descriptor_, &DetectParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SsdDetecterParameter_descriptor_, &SsdDetecterParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CaffeModelPath_descriptor_, &CaffeModelPath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SsdModelPath_descriptor_, &SsdModelPath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServiceParameter_descriptor_, &ServiceParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SsdServiceParameter_descriptor_, &SsdServiceParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NvrServiceParameter_descriptor_, &NvrServiceParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServiceList_descriptor_, &ServiceList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SsdServiceList_descriptor_, &SsdServiceList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NvrServiceList_descriptor_, &NvrServiceList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasComParameter_descriptor_, &VasComParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasComputeNode_descriptor_, &VasComputeNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasClientParameter_descriptor_, &VasClientParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasMsgFilterParam_descriptor_, &VasMsgFilterParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasHeartbeatParameter_descriptor_, &VasHeartbeatParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasHeartbeat_descriptor_, &VasHeartbeat::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasRetrunParamter_descriptor_, &VasRetrunParamter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasReturn_descriptor_, &VasReturn::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegRes_descriptor_, &RegRes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasResultParameter_descriptor_, &VasResultParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasResult_descriptor_, &VasResult::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasFeedbackParameter_descriptor_, &VasFeedbackParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VasFeedback_descriptor_, &VasFeedback::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_VasProto_2eprototxt() {
  delete NvrParameter::default_instance_;
  delete NvrParameter_reflection_;
  delete NvrChannel::default_instance_;
  delete NvrChannel_reflection_;
  delete DecodeParameter::default_instance_;
  delete DecodeParameter_reflection_;
  delete BgGuassianParameter::default_instance_;
  delete BgGuassianParameter_reflection_;
  delete BgVibeParameter::default_instance_;
  delete BgVibeParameter_reflection_;
  delete BgOperation::default_instance_;
  delete BgOperation_reflection_;
  delete BgParameter::default_instance_;
  delete BgParameter_reflection_;
  delete ColorThreshold::default_instance_;
  delete ColorThreshold_reflection_;
  delete FilterParameter::default_instance_;
  delete FilterParameter_reflection_;
  delete CaffeClassifierParameter::default_instance_;
  delete CaffeClassifierParameter_reflection_;
  delete DetectParameter::default_instance_;
  delete DetectParameter_reflection_;
  delete SsdDetecterParameter::default_instance_;
  delete SsdDetecterParameter_reflection_;
  delete CaffeModelPath::default_instance_;
  delete CaffeModelPath_reflection_;
  delete SsdModelPath::default_instance_;
  delete SsdModelPath_reflection_;
  delete ServiceParameter::default_instance_;
  delete ServiceParameter_reflection_;
  delete SsdServiceParameter::default_instance_;
  delete SsdServiceParameter_reflection_;
  delete NvrServiceParameter::default_instance_;
  delete NvrServiceParameter_reflection_;
  delete ServiceList::default_instance_;
  delete ServiceList_reflection_;
  delete SsdServiceList::default_instance_;
  delete SsdServiceList_reflection_;
  delete NvrServiceList::default_instance_;
  delete NvrServiceList_reflection_;
  delete VasComParameter::default_instance_;
  delete VasComParameter_reflection_;
  delete VasComputeNode::default_instance_;
  delete VasComputeNode_reflection_;
  delete VasClientParameter::default_instance_;
  delete VasClientParameter_reflection_;
  delete VasMsgFilterParam::default_instance_;
  delete VasMsgFilterParam_reflection_;
  delete VasHeartbeatParameter::default_instance_;
  delete VasHeartbeatParameter_reflection_;
  delete VasHeartbeat::default_instance_;
  delete VasHeartbeat_reflection_;
  delete VasRetrunParamter::default_instance_;
  delete VasRetrunParamter_reflection_;
  delete VasReturn::default_instance_;
  delete VasReturn_reflection_;
  delete RegRes::default_instance_;
  delete RegRes_reflection_;
  delete VasResultParameter::default_instance_;
  delete VasResultParameter_reflection_;
  delete VasResult::default_instance_;
  delete VasResult_reflection_;
  delete VasFeedbackParameter::default_instance_;
  delete VasFeedbackParameter_reflection_;
  delete VasFeedback::default_instance_;
  delete VasFeedback_reflection_;
}

void protobuf_AddDesc_VasProto_2eprototxt() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021VasProto.prototxt\022\003vas\"\263\001\n\014NvrParamete"
    "r\022\n\n\002ip\030\007 \001(\t\022\021\n\tuser_name\030\001 \001(\t\022\020\n\010pass"
    "word\030\002 \001(\t\022\022\n\004port\030\003 \001(\004:\0048000\022\037\n\017connec"
    "t_timeout\030\004 \001(\004:\006500000\022\037\n\016reconnect_tim"
    "e\030\005 \001(\004:\0071000000\022\034\n\016check_interval\030\006 \001(\004"
    ":\0045000\"\264\001\n\nNvrChannel\022\022\n\nservice_id\030\001 \001("
    "\t\022\025\n\nchannel_no\030\002 \001(\005:\0010\022/\n\ncam_status\030\003"
    " \001(\0162\016.vas.CamStatus:\013CAM_OFFLINE\022\031\n\rint"
    "erval_time\030\004 \001(\005:\00220\022\026\n\tdst_width\030\005 \001(\005:"
    "\003720\022\027\n\ndst_height\030\006 \001(\005:\003576\"\344\003\n\017Decode"
    "Parameter\022\022\n\nservice_id\030\001 \001(\t\0224\n\rdecode_"
    "method\030\002 \001(\0162\021.vas.DecodeMethod:\nDECODE_"
    "CPU\022\026\n\tdst_width\030\003 \001(\r:\003800\022\027\n\ndst_heigh"
    "t\030\004 \001(\r:\003576\022\031\n\rinterval_time\030\005 \001(\r:\00220\022"
    "\036\n\023max_reconnect_times\030\006 \001(\r:\0013\022$\n\025recon"
    "nect_sleep_times\030\016 \001(\r:\00510000\022$\n\027max_dec"
    "ode_error_frames\030\017 \001(\r:\003500\022\013\n\003url\030\007 \001(\t"
    "\0228\n\rstream_status\030\t \001(\0162\021.vas.StreamStat"
    "us:\016STREAM_UNKNOWN\022\034\n\010total_ms\030\n \001(\004:\n10"
    "00000000\022\037\n\017connect_timeout\030\013 \001(\004:\00650000"
    "0\022&\n\014video_source\030\014 \001(\0162\020.vas.VideoSourc"
    "e\022!\n\022print_decode_count\030\r \001(\010:\005false\"\202\001\n"
    "\023BgGuassianParameter\022\027\n\013num_history\030\001 \001("
    "\r:\00220\022\030\n\rvar_threshold\030\002 \001(\r:\0014\022\036\n\020shado"
    "w_detection\030\003 \001(\010:\004true\022\030\n\nlearn_rate\030\004 "
    "\001(\002:\0040.01\"\334\001\n\017BgVibeParameter\022\027\n\013num_sam"
    "ples\030\001 \001(\r:\00220\022\024\n\tmin_match\030\002 \001(\r:\0014\022\022\n\006"
    "radius\030\003 \001(\r:\00210\022\034\n\020subsample_factor\030\004 \001"
    "(\r:\00216\022\025\n\tbg2_delay\030\005 \001(\r:\00250\022\036\n\022max_mis"
    "match_count\030\006 \001(\r:\00250\022\030\n\tdouble_bg\030\007 \001(\010"
    ":\005false\022\027\n\nlearn_rate\030\010 \001(\002:\0030.5\"H\n\013BgOp"
    "eration\022 \n\025morphology_open_times\030\001 \001(\r:\001"
    "1\022\027\n\014dilate_times\030\002 \001(\r:\0011\"\311\002\n\013BgParamet"
    "er\022.\n\tbg_method\030\001 \001(\0162\r.vas.BgMethod:\014GU"
    "ASSIAN_CPU\022\035\n\020stable_threshold\030\002 \001(\002:\0030."
    "5\0224\n\022guassian_parameter\030\003 \001(\0132\030.vas.BgGu"
    "assianParameter\022,\n\016vibe_parameter\030\004 \001(\0132"
    "\024.vas.BgVibeParameter\022&\n\014bg_operation\030\005 "
    "\001(\0132\020.vas.BgOperation\0220\n\tbg_status\030\006 \001(\016"
    "2\r.vas.BgStatus:\016BG_UNINIALIZED\022\025\n\010bg_wi"
    "dth\030\007 \001(\r:\003420\022\026\n\tbg_height\030\010 \001(\r:\003320\"6"
    "\n\016ColorThreshold\022\020\n\005lower\030\001 \001(\002:\0010\022\022\n\005up"
    "per\030\002 \001(\002:\003255\"\363\003\n\017FilterParameter\022#\n\026co"
    "ntour_area_threshold\030\001 \001(\r:\003500\022\'\n\033conto"
    "ur_perimeter_threshold\030\002 \001(\r:\00210\022,\n\036area"
    "_perimeter_ratio_threshold\030\003 \001(\002:\0040.01\0222"
    "\n\013filter_type\030\014 \001(\0162\017.vas.FilterType:\014SM"
    "OKE_FILTER\022%\n\010rgb_th_1\030\004 \001(\0132\023.vas.Color"
    "Threshold\022%\n\010rgb_th_2\030\005 \001(\0132\023.vas.ColorT"
    "hreshold\022\'\n\nycbcr_th_1\030\006 \001(\0132\023.vas.Color"
    "Threshold\022\'\n\nycbcr_th_2\030\007 \001(\0132\023.vas.Colo"
    "rThreshold\022\034\n\017color_fit_ratio\030\010 \001(\002:\0030.5"
    "\022\031\n\014filter_width\030\t \001(\r:\003420\022\032\n\rfilter_he"
    "ight\030\n \001(\r:\003320\022;\n\rfilter_method\030\013 \001(\0162\021"
    ".vas.FilterMethod:\021PURE_CONTOUR_AREA\"h\n\030"
    "CaffeClassifierParameter\022\034\n\017confience_sc"
    "ore\030\001 \001(\002:\0030.5\022\027\n\ninput_size\030\002 \001(\r:\003224\022"
    "\025\n\rmodel_version\030\003 \001(\t\"\231\006\n\017DetectParamet"
    "er\022\022\n\nservice_id\030\001 \001(\t\022\020\n\010reg_type\030\002 \003(\t"
    "\022#\n\026smoke_detect_sensitity\030\013 \001(\002:\0030.2\022\"\n"
    "\025fire_detect_sensitity\030\030 \001(\002:\0030.2\022\027\n\013num"
    "_history\030\014 \001(\r:\00250\022\026\n\treg_width\030\004 \001(\r:\0038"
    "00\022\027\n\nreg_height\030\005 \001(\r:\003576\022\030\n\014reg_inter"
    "val\030\006 \001(\r:\00220\022&\n\014bg_parameter\030\007 \001(\0132\020.va"
    "s.BgParameter\022.\n\020filter_parameter\030\010 \001(\0132"
    "\024.vas.FilterParameter\0226\n\017caffe_parameter"
    "\030\t \001(\0132\035.vas.CaffeClassifierParameter\0223\n"
    "\rdetect_status\030\n \001(\0162\021.vas.DetectStatus:"
    "\tDETECT_ON\022\037\n\020merge_fore_rects\030\024 \001(\010:\005fa"
    "lse\022 \n\021show_result_frame\030\r \001(\010:\005false\022\026\n"
    "\007show_bg\030\017 \001(\010:\005false\022\035\n\016show_reg_frame\030"
    "\020 \001(\010:\005false\022\036\n\017print_reg_count\030\016 \001(\010:\005f"
    "alse\022#\n\024show_smoke_hot_frame\030\021 \001(\010:\005fals"
    "e\022\"\n\023show_fire_hot_frame\030\027 \001(\010:\005false\022\035\n"
    "\016save_reg_frame\030\022 \001(\010:\005false\022\031\n\nsave_vid"
    "eo\030\023 \001(\010:\005false\022%\n\026move_area_for_reg_onl"
    "y\030\025 \001(\010:\005false\022*\n\033show_move_area_for_reg"
    "_only\030\026 \001(\010:\005false\"\332\002\n\024SsdDetecterParame"
    "ter\022\022\n\nservice_id\030\001 \001(\t\022\020\n\010reg_type\030\002 \003("
    "\t\022\026\n\treg_width\030\004 \001(\r:\003800\022\027\n\nreg_height\030"
    "\005 \001(\r:\003576\0223\n\rdetect_status\030\n \001(\0162\021.vas."
    "DetectStatus:\tDETECT_ON\022 \n\021show_result_f"
    "rame\030\r \001(\010:\005false\022\035\n\016show_reg_frame\030\020 \001("
    "\010:\005false\022\031\n\nsave_video\030\023 \001(\010:\005false\022\035\n\016s"
    "ave_reg_frame\030\022 \001(\010:\005false\022\030\n\014reg_interv"
    "al\030\006 \001(\r:\00220\022!\n\024confidence_threshold\030\025 \001"
    "(\002:\0030.5\"\276\001\n\016CaffeModelPath\022\030\n\020deploy_fil"
    "e_path\030\001 \001(\t\022\032\n\022trained_model_path\030\002 \001(\t"
    "\022\027\n\017label_file_path\030\003 \001(\t\022\026\n\016mean_file_p"
    "ath\030\004 \001(\t\022\027\n\ninput_size\030\005 \001(\r:\003224\022\025\n\rmo"
    "del_version\030\006 \001(\t\022\025\n\007use_gpu\030\007 \001(\010:\004true"
    "\"\267\001\n\014SsdModelPath\022\030\n\020deploy_file_path\030\001 "
    "\001(\t\022\032\n\022trained_model_path\030\002 \001(\t\022\027\n\017label"
    "_file_path\030\003 \001(\t\022\026\n\016mean_file_path\030\004 \001(\t"
    "\022\022\n\nmean_value\030\005 \001(\t\022\025\n\rmodel_version\030\006 "
    "\001(\t\022\025\n\007use_gpu\030\007 \001(\010:\004true\"\361\001\n\020ServicePa"
    "rameter\022\022\n\nservice_id\030\001 \001(\t\022.\n\020decode_pa"
    "rameter\030\002 \001(\0132\024.vas.DecodeParameter\022.\n\020d"
    "etect_parameter\030\003 \001(\0132\024.vas.DetectParame"
    "ter\022*\n\016service_status\030\004 \001(\0162\022.vas.Servic"
    "eStatus\022=\n\021reg_msg_subscribe\030\005 \001(\0162\024.vas"
    ".RegMsgSubscribe:\014SUBSCRIBE_ON\"\371\001\n\023SsdSe"
    "rviceParameter\022\022\n\nservice_id\030\001 \001(\t\022.\n\020de"
    "code_parameter\030\002 \001(\0132\024.vas.DecodeParamet"
    "er\0223\n\020detect_parameter\030\003 \001(\0132\031.vas.SsdDe"
    "tecterParameter\022*\n\016service_status\030\004 \001(\0162"
    "\022.vas.ServiceStatus\022=\n\021reg_msg_subscribe"
    "\030\005 \001(\0162\024.vas.RegMsgSubscribe:\014SUBSCRIBE_"
    "ON\"\352\001\n\023NvrServiceParameter\022\022\n\nservice_id"
    "\030\001 \001(\t\022$\n\013nvr_channel\030\002 \001(\0132\017.vas.NvrCha"
    "nnel\022.\n\020detect_parameter\030\003 \001(\0132\024.vas.Det"
    "ectParameter\022*\n\016service_status\030\004 \001(\0162\022.v"
    "as.ServiceStatus\022=\n\021reg_msg_subscribe\030\005 "
    "\001(\0162\024.vas.RegMsgSubscribe:\014SUBSCRIBE_ON\""
    "X\n\013ServiceList\022\030\n\020last_update_time\030\001 \001(\t"
    "\022/\n\020service_paramter\030\002 \003(\0132\025.vas.Service"
    "Parameter\"^\n\016SsdServiceList\022\030\n\020last_upda"
    "te_time\030\001 \001(\t\0222\n\020service_paramter\030\002 \003(\0132"
    "\030.vas.SsdServiceParameter\"n\n\016NvrServiceL"
    "ist\022\'\n\014nvr_paramter\030\001 \001(\0132\021.vas.NvrParam"
    "eter\0223\n\021service_parameter\030\002 \003(\0132\030.vas.Nv"
    "rServiceParameter\"\201\001\n\017VasComParameter\022\n\n"
    "\002ip\030\001 \001(\t\022\022\n\004port\030\002 \001(\003:\0048001\022.\n\tapp_sta"
    "te\030\003 \001(\0162\017.vas.EnAppState:\nST_STOPPED\022\036\n"
    "\022heartbeat_interval\030\004 \001(\005:\00210\"q\n\016VasComp"
    "uteNode\022\017\n\007node_id\030\001 \001(\005\022\021\n\tnode_name\030\002 "
    "\001(\t\022\021\n\tcenter_id\030\003 \001(\005\022\023\n\013com_version\030\004 "
    "\001(\005\022\023\n\013retry_count\030\005 \001(\005\"f\n\022VasClientPar"
    "ameter\022\'\n\tcom_param\030\001 \001(\0132\024.vas.VasComPa"
    "rameter\022\'\n\nnode_param\030\002 \001(\0132\023.vas.VasCom"
    "puteNode\"@\n\021VasMsgFilterParam\022\022\n\nservice"
    "_id\030\001 \001(\t\022\027\n\014interval_sec\030\002 \001(\005:\0015\"b\n\025Va"
    "sHeartbeatParameter\022\017\n\007app_key\030\001 \001(\t\022\017\n\007"
    "node_id\030\002 \001(\005\022\024\n\014service_list\030\003 \001(\t\022\021\n\tt"
    "imestamp\030\004 \001(\003\"L\n\014VasHeartbeat\022\020\n\010psi_na"
    "me\030\001 \001(\t\022*\n\006params\030\002 \001(\0132\032.vas.VasHeartb"
    "eatParameter\"I\n\021VasRetrunParamter\022\020\n\010psi"
    "_name\030\001 \001(\t\022\017\n\007node_id\030\002 \001(\005\022\021\n\ttimestam"
    "p\030\003 \001(\003\"V\n\tVasReturn\022\020\n\010ret_code\030\001 \001(\005\022\017"
    "\n\007ret_msg\030\002 \001(\t\022&\n\006params\030\003 \001(\0132\026.vas.Va"
    "sRetrunParamter\"^\n\006RegRes\022\020\n\010reg_type\030\001 "
    "\001(\t\022\r\n\005score\030\002 \001(\002\022\t\n\001x\030\003 \001(\005\022\t\n\001y\030\004 \001(\005"
    "\022\r\n\005width\030\005 \001(\005\022\016\n\006height\030\006 \001(\005\"o\n\022VasRe"
    "sultParameter\022\017\n\007node_id\030\001 \001(\005\022\022\n\nservic"
    "e_id\030\002 \001(\t\022!\n\014result_rects\030\003 \003(\0132\013.vas.R"
    "egRes\022\021\n\ttimestamp\030\004 \001(\003\"F\n\tVasResult\022\020\n"
    "\010psi_name\030\001 \001(\t\022\'\n\006params\030\002 \001(\0132\027.vas.Va"
    "sResultParameter\"\316\001\n\024VasFeedbackParamete"
    "r\022\017\n\007node_id\030\001 \001(\005\022\022\n\nservice_id\030\002 \001(\t\022\024"
    "\n\014address_type\030\003 \001(\t\022\021\n\tdevice_id\030\004 \001(\t\022"
    "\026\n\016device_channel\030\005 \001(\t\022\017\n\007address\030\006 \001(\t"
    "\022\025\n\rfeedback_code\030\007 \001(\005\022\025\n\rfeedback_info"
    "\030\010 \001(\t\022\021\n\ttimestamp\030\t \001(\003\"J\n\013VasFeedback"
    "\022\020\n\010psi_name\030\001 \001(\t\022)\n\006params\030\002 \001(\0132\031.vas"
    ".VasFeedbackParameter*.\n\014DecodeMethod\022\016\n"
    "\nDECODE_CPU\020\000\022\016\n\nDECODE_GPU\020\001*7\n\013VideoSo"
    "urce\022\016\n\nVIDEO_FILE\020\001\022\017\n\013RTSP_STREAM\020\002\022\007\n"
    "\003NVR\020\003*,\n\tCamStatus\022\016\n\nCAM_ONLINE\020\001\022\017\n\013C"
    "AM_OFFLINE\020\002*\346\001\n\014StreamStatus\022\022\n\016STREAM_"
    "UNKNOWN\020\000\022\025\n\021STREAM_CONNECTING\020\001\022\021\n\rSTRE"
    "AM_NORMAL\020\002\022\021\n\rSTREAM_FINISH\020\003\022\017\n\013STREAM"
    "_STOP\020\n\022\020\n\014STREAM_PAUSE\020\004\022\030\n\024STREAM_NETW"
    "ORK_FAULT\020\005\022\016\n\nFILE_FAULT\020\006\022\033\n\027STREAM_CP"
    "U_DECODE_FAULT\020\010\022\033\n\027STREAM_GPU_DECODE_FA"
    "ULT\020\t*=\n\010BgStatus\022\022\n\016BG_UNINIALIZED\020\000\022\014\n"
    "\010BG_SETUP\020\001\022\017\n\013BG_UPDATING\020\002*J\n\010BgMethod"
    "\022\014\n\010VIBE_CPU\020\000\022\014\n\010VIBE_GPU\020\001\022\020\n\014GUASSIAN"
    "_CPU\020\002\022\020\n\014GUASSIAN_GPU\020\003*b\n\014FilterMethod"
    "\022\023\n\017FRAME_COLOR_CPU\020\000\022\023\n\017FRAME_COLOR_GPU"
    "\020\001\022\021\n\rCONTOUR_COLOR\020\003\022\025\n\021PURE_CONTOUR_AR"
    "EA\020\004*/\n\nFilterType\022\020\n\014SMOKE_FILTER\020\001\022\017\n\013"
    "FIRE_FILTER\020\002*\?\n\014DetectStatus\022\r\n\tDETECT_"
    "ON\020\001\022\016\n\nDETECT_OFF\020\002\022\020\n\014DETECT_PAUSE\020\003*\201"
    "\001\n\rServiceStatus\022\023\n\017SERVICE_UNKNOWN\020\000\022\022\n"
    "\016SERVICE_NORMAL\020\001\022\021\n\rSERVICE_PAUSE\020\002\022\030\n\024"
    "SERVICE_STREAM_FALUT\020\003\022\032\n\026SERVICE_DETECT"
    "ER_FALUT\020\004*\350\001\n\023ServiceCommandReply\022\031\n\025SE"
    "RVICE_START_SUCCESS\020\001\022\030\n\024SERVICE_START_F"
    "ALIED\020\002\022\027\n\023SERVICE_STOP_SUCESS\020\003\022\027\n\023SERV"
    "ICE_STOP_FALIED\020\004\022\031\n\025SERVICE_PAUSE_SUCCE"
    "SS\020\005\022\030\n\024SERVICE_PAUSE_FAILED\020\006\022\032\n\026SERVIC"
    "E_RESUME_SUCCESS\020\007\022\031\n\025SERVICE_RESUME_FAI"
    "LED\020\010*6\n\017RegMsgSubscribe\022\020\n\014SUBSCRIBE_ON"
    "\020\001\022\021\n\rSUBSCRIBE_OFF\020\002*,\n\nEnAppState\022\016\n\nS"
    "T_STARTED\020\001\022\016\n\nST_STOPPED\020\002", 7387);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "VasProto.prototxt", &protobuf_RegisterTypes);
  NvrParameter::default_instance_ = new NvrParameter();
  NvrChannel::default_instance_ = new NvrChannel();
  DecodeParameter::default_instance_ = new DecodeParameter();
  BgGuassianParameter::default_instance_ = new BgGuassianParameter();
  BgVibeParameter::default_instance_ = new BgVibeParameter();
  BgOperation::default_instance_ = new BgOperation();
  BgParameter::default_instance_ = new BgParameter();
  ColorThreshold::default_instance_ = new ColorThreshold();
  FilterParameter::default_instance_ = new FilterParameter();
  CaffeClassifierParameter::default_instance_ = new CaffeClassifierParameter();
  DetectParameter::default_instance_ = new DetectParameter();
  SsdDetecterParameter::default_instance_ = new SsdDetecterParameter();
  CaffeModelPath::default_instance_ = new CaffeModelPath();
  SsdModelPath::default_instance_ = new SsdModelPath();
  ServiceParameter::default_instance_ = new ServiceParameter();
  SsdServiceParameter::default_instance_ = new SsdServiceParameter();
  NvrServiceParameter::default_instance_ = new NvrServiceParameter();
  ServiceList::default_instance_ = new ServiceList();
  SsdServiceList::default_instance_ = new SsdServiceList();
  NvrServiceList::default_instance_ = new NvrServiceList();
  VasComParameter::default_instance_ = new VasComParameter();
  VasComputeNode::default_instance_ = new VasComputeNode();
  VasClientParameter::default_instance_ = new VasClientParameter();
  VasMsgFilterParam::default_instance_ = new VasMsgFilterParam();
  VasHeartbeatParameter::default_instance_ = new VasHeartbeatParameter();
  VasHeartbeat::default_instance_ = new VasHeartbeat();
  VasRetrunParamter::default_instance_ = new VasRetrunParamter();
  VasReturn::default_instance_ = new VasReturn();
  RegRes::default_instance_ = new RegRes();
  VasResultParameter::default_instance_ = new VasResultParameter();
  VasResult::default_instance_ = new VasResult();
  VasFeedbackParameter::default_instance_ = new VasFeedbackParameter();
  VasFeedback::default_instance_ = new VasFeedback();
  NvrParameter::default_instance_->InitAsDefaultInstance();
  NvrChannel::default_instance_->InitAsDefaultInstance();
  DecodeParameter::default_instance_->InitAsDefaultInstance();
  BgGuassianParameter::default_instance_->InitAsDefaultInstance();
  BgVibeParameter::default_instance_->InitAsDefaultInstance();
  BgOperation::default_instance_->InitAsDefaultInstance();
  BgParameter::default_instance_->InitAsDefaultInstance();
  ColorThreshold::default_instance_->InitAsDefaultInstance();
  FilterParameter::default_instance_->InitAsDefaultInstance();
  CaffeClassifierParameter::default_instance_->InitAsDefaultInstance();
  DetectParameter::default_instance_->InitAsDefaultInstance();
  SsdDetecterParameter::default_instance_->InitAsDefaultInstance();
  CaffeModelPath::default_instance_->InitAsDefaultInstance();
  SsdModelPath::default_instance_->InitAsDefaultInstance();
  ServiceParameter::default_instance_->InitAsDefaultInstance();
  SsdServiceParameter::default_instance_->InitAsDefaultInstance();
  NvrServiceParameter::default_instance_->InitAsDefaultInstance();
  ServiceList::default_instance_->InitAsDefaultInstance();
  SsdServiceList::default_instance_->InitAsDefaultInstance();
  NvrServiceList::default_instance_->InitAsDefaultInstance();
  VasComParameter::default_instance_->InitAsDefaultInstance();
  VasComputeNode::default_instance_->InitAsDefaultInstance();
  VasClientParameter::default_instance_->InitAsDefaultInstance();
  VasMsgFilterParam::default_instance_->InitAsDefaultInstance();
  VasHeartbeatParameter::default_instance_->InitAsDefaultInstance();
  VasHeartbeat::default_instance_->InitAsDefaultInstance();
  VasRetrunParamter::default_instance_->InitAsDefaultInstance();
  VasReturn::default_instance_->InitAsDefaultInstance();
  RegRes::default_instance_->InitAsDefaultInstance();
  VasResultParameter::default_instance_->InitAsDefaultInstance();
  VasResult::default_instance_->InitAsDefaultInstance();
  VasFeedbackParameter::default_instance_->InitAsDefaultInstance();
  VasFeedback::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_VasProto_2eprototxt);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_VasProto_2eprototxt {
  StaticDescriptorInitializer_VasProto_2eprototxt() {
    protobuf_AddDesc_VasProto_2eprototxt();
  }
} static_descriptor_initializer_VasProto_2eprototxt_;
const ::google::protobuf::EnumDescriptor* DecodeMethod_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DecodeMethod_descriptor_;
}
bool DecodeMethod_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* VideoSource_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VideoSource_descriptor_;
}
bool VideoSource_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CamStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CamStatus_descriptor_;
}
bool CamStatus_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StreamStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StreamStatus_descriptor_;
}
bool StreamStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* BgStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BgStatus_descriptor_;
}
bool BgStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* BgMethod_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BgMethod_descriptor_;
}
bool BgMethod_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FilterMethod_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilterMethod_descriptor_;
}
bool FilterMethod_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FilterType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilterType_descriptor_;
}
bool FilterType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* DetectStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetectStatus_descriptor_;
}
bool DetectStatus_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ServiceStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceStatus_descriptor_;
}
bool ServiceStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ServiceCommandReply_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceCommandReply_descriptor_;
}
bool ServiceCommandReply_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RegMsgSubscribe_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegMsgSubscribe_descriptor_;
}
bool RegMsgSubscribe_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EnAppState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EnAppState_descriptor_;
}
bool EnAppState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int NvrParameter::kIpFieldNumber;
const int NvrParameter::kUserNameFieldNumber;
const int NvrParameter::kPasswordFieldNumber;
const int NvrParameter::kPortFieldNumber;
const int NvrParameter::kConnectTimeoutFieldNumber;
const int NvrParameter::kReconnectTimeFieldNumber;
const int NvrParameter::kCheckIntervalFieldNumber;
#endif  // !_MSC_VER

NvrParameter::NvrParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.NvrParameter)
}

void NvrParameter::InitAsDefaultInstance() {
}

NvrParameter::NvrParameter(const NvrParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.NvrParameter)
}

void NvrParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = GOOGLE_ULONGLONG(8000);
  connect_timeout_ = GOOGLE_ULONGLONG(500000);
  reconnect_time_ = GOOGLE_ULONGLONG(1000000);
  check_interval_ = GOOGLE_ULONGLONG(5000);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NvrParameter::~NvrParameter() {
  // @@protoc_insertion_point(destructor:vas.NvrParameter)
  SharedDtor();
}

void NvrParameter::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (this != default_instance_) {
  }
}

void NvrParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NvrParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NvrParameter_descriptor_;
}

const NvrParameter& NvrParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

NvrParameter* NvrParameter::default_instance_ = NULL;

NvrParameter* NvrParameter::New() const {
  return new NvrParameter;
}

void NvrParameter::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
    if (has_user_name()) {
      if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_name_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        password_->clear();
      }
    }
    port_ = GOOGLE_ULONGLONG(8000);
    connect_timeout_ = GOOGLE_ULONGLONG(500000);
    reconnect_time_ = GOOGLE_ULONGLONG(1000000);
    check_interval_ = GOOGLE_ULONGLONG(5000);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NvrParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.NvrParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string user_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user_name().data(), this->user_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "user_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // optional string password = 2;
      case 2: {
        if (tag == 18) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->password().data(), this->password().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "password");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // optional uint64 port = 3 [default = 8000];
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_connect_timeout;
        break;
      }

      // optional uint64 connect_timeout = 4 [default = 500000];
      case 4: {
        if (tag == 32) {
         parse_connect_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &connect_timeout_)));
          set_has_connect_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reconnect_time;
        break;
      }

      // optional uint64 reconnect_time = 5 [default = 1000000];
      case 5: {
        if (tag == 40) {
         parse_reconnect_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &reconnect_time_)));
          set_has_reconnect_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_check_interval;
        break;
      }

      // optional uint64 check_interval = 6 [default = 5000];
      case 6: {
        if (tag == 48) {
         parse_check_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &check_interval_)));
          set_has_check_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_ip;
        break;
      }

      // optional string ip = 7;
      case 7: {
        if (tag == 58) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.NvrParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.NvrParameter)
  return false;
#undef DO_
}

void NvrParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.NvrParameter)
  // optional string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_name().data(), this->user_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_name(), output);
  }

  // optional string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "password");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->password(), output);
  }

  // optional uint64 port = 3 [default = 8000];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->port(), output);
  }

  // optional uint64 connect_timeout = 4 [default = 500000];
  if (has_connect_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->connect_timeout(), output);
  }

  // optional uint64 reconnect_time = 5 [default = 1000000];
  if (has_reconnect_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->reconnect_time(), output);
  }

  // optional uint64 check_interval = 6 [default = 5000];
  if (has_check_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->check_interval(), output);
  }

  // optional string ip = 7;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->ip(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.NvrParameter)
}

::google::protobuf::uint8* NvrParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.NvrParameter)
  // optional string user_name = 1;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user_name().data(), this->user_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "user_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->user_name(), target);
  }

  // optional string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "password");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->password(), target);
  }

  // optional uint64 port = 3 [default = 8000];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->port(), target);
  }

  // optional uint64 connect_timeout = 4 [default = 500000];
  if (has_connect_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->connect_timeout(), target);
  }

  // optional uint64 reconnect_time = 5 [default = 1000000];
  if (has_reconnect_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->reconnect_time(), target);
  }

  // optional uint64 check_interval = 6 [default = 5000];
  if (has_check_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->check_interval(), target);
  }

  // optional string ip = 7;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->ip(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.NvrParameter)
  return target;
}

int NvrParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string ip = 7;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional string user_name = 1;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_name());
    }

    // optional string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // optional uint64 port = 3 [default = 8000];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->port());
    }

    // optional uint64 connect_timeout = 4 [default = 500000];
    if (has_connect_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->connect_timeout());
    }

    // optional uint64 reconnect_time = 5 [default = 1000000];
    if (has_reconnect_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->reconnect_time());
    }

    // optional uint64 check_interval = 6 [default = 5000];
    if (has_check_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->check_interval());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NvrParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NvrParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NvrParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NvrParameter::MergeFrom(const NvrParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_user_name()) {
      set_user_name(from.user_name());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_connect_timeout()) {
      set_connect_timeout(from.connect_timeout());
    }
    if (from.has_reconnect_time()) {
      set_reconnect_time(from.reconnect_time());
    }
    if (from.has_check_interval()) {
      set_check_interval(from.check_interval());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NvrParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NvrParameter::CopyFrom(const NvrParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvrParameter::IsInitialized() const {

  return true;
}

void NvrParameter::Swap(NvrParameter* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(user_name_, other->user_name_);
    std::swap(password_, other->password_);
    std::swap(port_, other->port_);
    std::swap(connect_timeout_, other->connect_timeout_);
    std::swap(reconnect_time_, other->reconnect_time_);
    std::swap(check_interval_, other->check_interval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NvrParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NvrParameter_descriptor_;
  metadata.reflection = NvrParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NvrChannel::kServiceIdFieldNumber;
const int NvrChannel::kChannelNoFieldNumber;
const int NvrChannel::kCamStatusFieldNumber;
const int NvrChannel::kIntervalTimeFieldNumber;
const int NvrChannel::kDstWidthFieldNumber;
const int NvrChannel::kDstHeightFieldNumber;
#endif  // !_MSC_VER

NvrChannel::NvrChannel()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.NvrChannel)
}

void NvrChannel::InitAsDefaultInstance() {
}

NvrChannel::NvrChannel(const NvrChannel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.NvrChannel)
}

void NvrChannel::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  channel_no_ = 0;
  cam_status_ = 2;
  interval_time_ = 20;
  dst_width_ = 720;
  dst_height_ = 576;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NvrChannel::~NvrChannel() {
  // @@protoc_insertion_point(destructor:vas.NvrChannel)
  SharedDtor();
}

void NvrChannel::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
  }
}

void NvrChannel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NvrChannel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NvrChannel_descriptor_;
}

const NvrChannel& NvrChannel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

NvrChannel* NvrChannel::default_instance_ = NULL;

NvrChannel* NvrChannel::New() const {
  return new NvrChannel;
}

void NvrChannel::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    channel_no_ = 0;
    cam_status_ = 2;
    interval_time_ = 20;
    dst_width_ = 720;
    dst_height_ = 576;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NvrChannel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.NvrChannel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_channel_no;
        break;
      }

      // optional int32 channel_no = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_channel_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_no_)));
          set_has_channel_no();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_cam_status;
        break;
      }

      // optional .vas.CamStatus cam_status = 3 [default = CAM_OFFLINE];
      case 3: {
        if (tag == 24) {
         parse_cam_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::CamStatus_IsValid(value)) {
            set_cam_status(static_cast< ::vas::CamStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_interval_time;
        break;
      }

      // optional int32 interval_time = 4 [default = 20];
      case 4: {
        if (tag == 32) {
         parse_interval_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interval_time_)));
          set_has_interval_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_dst_width;
        break;
      }

      // optional int32 dst_width = 5 [default = 720];
      case 5: {
        if (tag == 40) {
         parse_dst_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dst_width_)));
          set_has_dst_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_dst_height;
        break;
      }

      // optional int32 dst_height = 6 [default = 576];
      case 6: {
        if (tag == 48) {
         parse_dst_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dst_height_)));
          set_has_dst_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.NvrChannel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.NvrChannel)
  return false;
#undef DO_
}

void NvrChannel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.NvrChannel)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // optional int32 channel_no = 2 [default = 0];
  if (has_channel_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->channel_no(), output);
  }

  // optional .vas.CamStatus cam_status = 3 [default = CAM_OFFLINE];
  if (has_cam_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->cam_status(), output);
  }

  // optional int32 interval_time = 4 [default = 20];
  if (has_interval_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->interval_time(), output);
  }

  // optional int32 dst_width = 5 [default = 720];
  if (has_dst_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->dst_width(), output);
  }

  // optional int32 dst_height = 6 [default = 576];
  if (has_dst_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->dst_height(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.NvrChannel)
}

::google::protobuf::uint8* NvrChannel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.NvrChannel)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // optional int32 channel_no = 2 [default = 0];
  if (has_channel_no()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->channel_no(), target);
  }

  // optional .vas.CamStatus cam_status = 3 [default = CAM_OFFLINE];
  if (has_cam_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->cam_status(), target);
  }

  // optional int32 interval_time = 4 [default = 20];
  if (has_interval_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->interval_time(), target);
  }

  // optional int32 dst_width = 5 [default = 720];
  if (has_dst_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->dst_width(), target);
  }

  // optional int32 dst_height = 6 [default = 576];
  if (has_dst_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->dst_height(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.NvrChannel)
  return target;
}

int NvrChannel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional int32 channel_no = 2 [default = 0];
    if (has_channel_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel_no());
    }

    // optional .vas.CamStatus cam_status = 3 [default = CAM_OFFLINE];
    if (has_cam_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cam_status());
    }

    // optional int32 interval_time = 4 [default = 20];
    if (has_interval_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interval_time());
    }

    // optional int32 dst_width = 5 [default = 720];
    if (has_dst_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->dst_width());
    }

    // optional int32 dst_height = 6 [default = 576];
    if (has_dst_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->dst_height());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NvrChannel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NvrChannel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NvrChannel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NvrChannel::MergeFrom(const NvrChannel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_channel_no()) {
      set_channel_no(from.channel_no());
    }
    if (from.has_cam_status()) {
      set_cam_status(from.cam_status());
    }
    if (from.has_interval_time()) {
      set_interval_time(from.interval_time());
    }
    if (from.has_dst_width()) {
      set_dst_width(from.dst_width());
    }
    if (from.has_dst_height()) {
      set_dst_height(from.dst_height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NvrChannel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NvrChannel::CopyFrom(const NvrChannel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvrChannel::IsInitialized() const {

  return true;
}

void NvrChannel::Swap(NvrChannel* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    std::swap(channel_no_, other->channel_no_);
    std::swap(cam_status_, other->cam_status_);
    std::swap(interval_time_, other->interval_time_);
    std::swap(dst_width_, other->dst_width_);
    std::swap(dst_height_, other->dst_height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NvrChannel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NvrChannel_descriptor_;
  metadata.reflection = NvrChannel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DecodeParameter::kServiceIdFieldNumber;
const int DecodeParameter::kDecodeMethodFieldNumber;
const int DecodeParameter::kDstWidthFieldNumber;
const int DecodeParameter::kDstHeightFieldNumber;
const int DecodeParameter::kIntervalTimeFieldNumber;
const int DecodeParameter::kMaxReconnectTimesFieldNumber;
const int DecodeParameter::kReconnectSleepTimesFieldNumber;
const int DecodeParameter::kMaxDecodeErrorFramesFieldNumber;
const int DecodeParameter::kUrlFieldNumber;
const int DecodeParameter::kStreamStatusFieldNumber;
const int DecodeParameter::kTotalMsFieldNumber;
const int DecodeParameter::kConnectTimeoutFieldNumber;
const int DecodeParameter::kVideoSourceFieldNumber;
const int DecodeParameter::kPrintDecodeCountFieldNumber;
#endif  // !_MSC_VER

DecodeParameter::DecodeParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.DecodeParameter)
}

void DecodeParameter::InitAsDefaultInstance() {
}

DecodeParameter::DecodeParameter(const DecodeParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.DecodeParameter)
}

void DecodeParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  decode_method_ = 0;
  dst_width_ = 800u;
  dst_height_ = 576u;
  interval_time_ = 20u;
  max_reconnect_times_ = 3u;
  reconnect_sleep_times_ = 10000u;
  max_decode_error_frames_ = 500u;
  url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  stream_status_ = 0;
  total_ms_ = GOOGLE_ULONGLONG(1000000000);
  connect_timeout_ = GOOGLE_ULONGLONG(500000);
  video_source_ = 1;
  print_decode_count_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DecodeParameter::~DecodeParameter() {
  // @@protoc_insertion_point(destructor:vas.DecodeParameter)
  SharedDtor();
}

void DecodeParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (this != default_instance_) {
  }
}

void DecodeParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DecodeParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DecodeParameter_descriptor_;
}

const DecodeParameter& DecodeParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

DecodeParameter* DecodeParameter::default_instance_ = NULL;

DecodeParameter* DecodeParameter::New() const {
  return new DecodeParameter;
}

void DecodeParameter::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    decode_method_ = 0;
    dst_width_ = 800u;
    dst_height_ = 576u;
    interval_time_ = 20u;
    max_reconnect_times_ = 3u;
    reconnect_sleep_times_ = 10000u;
    max_decode_error_frames_ = 500u;
  }
  if (_has_bits_[8 / 32] & 16128) {
    if (has_url()) {
      if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        url_->clear();
      }
    }
    stream_status_ = 0;
    total_ms_ = GOOGLE_ULONGLONG(1000000000);
    connect_timeout_ = GOOGLE_ULONGLONG(500000);
    video_source_ = 1;
    print_decode_count_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DecodeParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.DecodeParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_decode_method;
        break;
      }

      // optional .vas.DecodeMethod decode_method = 2 [default = DECODE_CPU];
      case 2: {
        if (tag == 16) {
         parse_decode_method:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::DecodeMethod_IsValid(value)) {
            set_decode_method(static_cast< ::vas::DecodeMethod >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dst_width;
        break;
      }

      // optional uint32 dst_width = 3 [default = 800];
      case 3: {
        if (tag == 24) {
         parse_dst_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dst_width_)));
          set_has_dst_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_dst_height;
        break;
      }

      // optional uint32 dst_height = 4 [default = 576];
      case 4: {
        if (tag == 32) {
         parse_dst_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dst_height_)));
          set_has_dst_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_interval_time;
        break;
      }

      // optional uint32 interval_time = 5 [default = 20];
      case 5: {
        if (tag == 40) {
         parse_interval_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &interval_time_)));
          set_has_interval_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_max_reconnect_times;
        break;
      }

      // optional uint32 max_reconnect_times = 6 [default = 3];
      case 6: {
        if (tag == 48) {
         parse_max_reconnect_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_reconnect_times_)));
          set_has_max_reconnect_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_url;
        break;
      }

      // optional string url = 7;
      case 7: {
        if (tag == 58) {
         parse_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_url()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->url().data(), this->url().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "url");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_stream_status;
        break;
      }

      // optional .vas.StreamStatus stream_status = 9 [default = STREAM_UNKNOWN];
      case 9: {
        if (tag == 72) {
         parse_stream_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::StreamStatus_IsValid(value)) {
            set_stream_status(static_cast< ::vas::StreamStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_total_ms;
        break;
      }

      // optional uint64 total_ms = 10 [default = 1000000000];
      case 10: {
        if (tag == 80) {
         parse_total_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &total_ms_)));
          set_has_total_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_connect_timeout;
        break;
      }

      // optional uint64 connect_timeout = 11 [default = 500000];
      case 11: {
        if (tag == 88) {
         parse_connect_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &connect_timeout_)));
          set_has_connect_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_video_source;
        break;
      }

      // optional .vas.VideoSource video_source = 12;
      case 12: {
        if (tag == 96) {
         parse_video_source:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::VideoSource_IsValid(value)) {
            set_video_source(static_cast< ::vas::VideoSource >(value));
          } else {
            mutable_unknown_fields()->AddVarint(12, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_print_decode_count;
        break;
      }

      // optional bool print_decode_count = 13 [default = false];
      case 13: {
        if (tag == 104) {
         parse_print_decode_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &print_decode_count_)));
          set_has_print_decode_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_reconnect_sleep_times;
        break;
      }

      // optional uint32 reconnect_sleep_times = 14 [default = 10000];
      case 14: {
        if (tag == 112) {
         parse_reconnect_sleep_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reconnect_sleep_times_)));
          set_has_reconnect_sleep_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_max_decode_error_frames;
        break;
      }

      // optional uint32 max_decode_error_frames = 15 [default = 500];
      case 15: {
        if (tag == 120) {
         parse_max_decode_error_frames:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_decode_error_frames_)));
          set_has_max_decode_error_frames();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.DecodeParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.DecodeParameter)
  return false;
#undef DO_
}

void DecodeParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.DecodeParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // optional .vas.DecodeMethod decode_method = 2 [default = DECODE_CPU];
  if (has_decode_method()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->decode_method(), output);
  }

  // optional uint32 dst_width = 3 [default = 800];
  if (has_dst_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dst_width(), output);
  }

  // optional uint32 dst_height = 4 [default = 576];
  if (has_dst_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->dst_height(), output);
  }

  // optional uint32 interval_time = 5 [default = 20];
  if (has_interval_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->interval_time(), output);
  }

  // optional uint32 max_reconnect_times = 6 [default = 3];
  if (has_max_reconnect_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->max_reconnect_times(), output);
  }

  // optional string url = 7;
  if (has_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "url");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->url(), output);
  }

  // optional .vas.StreamStatus stream_status = 9 [default = STREAM_UNKNOWN];
  if (has_stream_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->stream_status(), output);
  }

  // optional uint64 total_ms = 10 [default = 1000000000];
  if (has_total_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->total_ms(), output);
  }

  // optional uint64 connect_timeout = 11 [default = 500000];
  if (has_connect_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->connect_timeout(), output);
  }

  // optional .vas.VideoSource video_source = 12;
  if (has_video_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->video_source(), output);
  }

  // optional bool print_decode_count = 13 [default = false];
  if (has_print_decode_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->print_decode_count(), output);
  }

  // optional uint32 reconnect_sleep_times = 14 [default = 10000];
  if (has_reconnect_sleep_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->reconnect_sleep_times(), output);
  }

  // optional uint32 max_decode_error_frames = 15 [default = 500];
  if (has_max_decode_error_frames()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->max_decode_error_frames(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.DecodeParameter)
}

::google::protobuf::uint8* DecodeParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.DecodeParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // optional .vas.DecodeMethod decode_method = 2 [default = DECODE_CPU];
  if (has_decode_method()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->decode_method(), target);
  }

  // optional uint32 dst_width = 3 [default = 800];
  if (has_dst_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->dst_width(), target);
  }

  // optional uint32 dst_height = 4 [default = 576];
  if (has_dst_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->dst_height(), target);
  }

  // optional uint32 interval_time = 5 [default = 20];
  if (has_interval_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->interval_time(), target);
  }

  // optional uint32 max_reconnect_times = 6 [default = 3];
  if (has_max_reconnect_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->max_reconnect_times(), target);
  }

  // optional string url = 7;
  if (has_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "url");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->url(), target);
  }

  // optional .vas.StreamStatus stream_status = 9 [default = STREAM_UNKNOWN];
  if (has_stream_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->stream_status(), target);
  }

  // optional uint64 total_ms = 10 [default = 1000000000];
  if (has_total_ms()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->total_ms(), target);
  }

  // optional uint64 connect_timeout = 11 [default = 500000];
  if (has_connect_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->connect_timeout(), target);
  }

  // optional .vas.VideoSource video_source = 12;
  if (has_video_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->video_source(), target);
  }

  // optional bool print_decode_count = 13 [default = false];
  if (has_print_decode_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->print_decode_count(), target);
  }

  // optional uint32 reconnect_sleep_times = 14 [default = 10000];
  if (has_reconnect_sleep_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->reconnect_sleep_times(), target);
  }

  // optional uint32 max_decode_error_frames = 15 [default = 500];
  if (has_max_decode_error_frames()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->max_decode_error_frames(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.DecodeParameter)
  return target;
}

int DecodeParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional .vas.DecodeMethod decode_method = 2 [default = DECODE_CPU];
    if (has_decode_method()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->decode_method());
    }

    // optional uint32 dst_width = 3 [default = 800];
    if (has_dst_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dst_width());
    }

    // optional uint32 dst_height = 4 [default = 576];
    if (has_dst_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dst_height());
    }

    // optional uint32 interval_time = 5 [default = 20];
    if (has_interval_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->interval_time());
    }

    // optional uint32 max_reconnect_times = 6 [default = 3];
    if (has_max_reconnect_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_reconnect_times());
    }

    // optional uint32 reconnect_sleep_times = 14 [default = 10000];
    if (has_reconnect_sleep_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reconnect_sleep_times());
    }

    // optional uint32 max_decode_error_frames = 15 [default = 500];
    if (has_max_decode_error_frames()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_decode_error_frames());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string url = 7;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }

    // optional .vas.StreamStatus stream_status = 9 [default = STREAM_UNKNOWN];
    if (has_stream_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->stream_status());
    }

    // optional uint64 total_ms = 10 [default = 1000000000];
    if (has_total_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->total_ms());
    }

    // optional uint64 connect_timeout = 11 [default = 500000];
    if (has_connect_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->connect_timeout());
    }

    // optional .vas.VideoSource video_source = 12;
    if (has_video_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->video_source());
    }

    // optional bool print_decode_count = 13 [default = false];
    if (has_print_decode_count()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DecodeParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DecodeParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DecodeParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DecodeParameter::MergeFrom(const DecodeParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_decode_method()) {
      set_decode_method(from.decode_method());
    }
    if (from.has_dst_width()) {
      set_dst_width(from.dst_width());
    }
    if (from.has_dst_height()) {
      set_dst_height(from.dst_height());
    }
    if (from.has_interval_time()) {
      set_interval_time(from.interval_time());
    }
    if (from.has_max_reconnect_times()) {
      set_max_reconnect_times(from.max_reconnect_times());
    }
    if (from.has_reconnect_sleep_times()) {
      set_reconnect_sleep_times(from.reconnect_sleep_times());
    }
    if (from.has_max_decode_error_frames()) {
      set_max_decode_error_frames(from.max_decode_error_frames());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_url()) {
      set_url(from.url());
    }
    if (from.has_stream_status()) {
      set_stream_status(from.stream_status());
    }
    if (from.has_total_ms()) {
      set_total_ms(from.total_ms());
    }
    if (from.has_connect_timeout()) {
      set_connect_timeout(from.connect_timeout());
    }
    if (from.has_video_source()) {
      set_video_source(from.video_source());
    }
    if (from.has_print_decode_count()) {
      set_print_decode_count(from.print_decode_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DecodeParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DecodeParameter::CopyFrom(const DecodeParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecodeParameter::IsInitialized() const {

  return true;
}

void DecodeParameter::Swap(DecodeParameter* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    std::swap(decode_method_, other->decode_method_);
    std::swap(dst_width_, other->dst_width_);
    std::swap(dst_height_, other->dst_height_);
    std::swap(interval_time_, other->interval_time_);
    std::swap(max_reconnect_times_, other->max_reconnect_times_);
    std::swap(reconnect_sleep_times_, other->reconnect_sleep_times_);
    std::swap(max_decode_error_frames_, other->max_decode_error_frames_);
    std::swap(url_, other->url_);
    std::swap(stream_status_, other->stream_status_);
    std::swap(total_ms_, other->total_ms_);
    std::swap(connect_timeout_, other->connect_timeout_);
    std::swap(video_source_, other->video_source_);
    std::swap(print_decode_count_, other->print_decode_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DecodeParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DecodeParameter_descriptor_;
  metadata.reflection = DecodeParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BgGuassianParameter::kNumHistoryFieldNumber;
const int BgGuassianParameter::kVarThresholdFieldNumber;
const int BgGuassianParameter::kShadowDetectionFieldNumber;
const int BgGuassianParameter::kLearnRateFieldNumber;
#endif  // !_MSC_VER

BgGuassianParameter::BgGuassianParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.BgGuassianParameter)
}

void BgGuassianParameter::InitAsDefaultInstance() {
}

BgGuassianParameter::BgGuassianParameter(const BgGuassianParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.BgGuassianParameter)
}

void BgGuassianParameter::SharedCtor() {
  _cached_size_ = 0;
  num_history_ = 20u;
  var_threshold_ = 4u;
  shadow_detection_ = true;
  learn_rate_ = 0.01f;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BgGuassianParameter::~BgGuassianParameter() {
  // @@protoc_insertion_point(destructor:vas.BgGuassianParameter)
  SharedDtor();
}

void BgGuassianParameter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BgGuassianParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BgGuassianParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BgGuassianParameter_descriptor_;
}

const BgGuassianParameter& BgGuassianParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

BgGuassianParameter* BgGuassianParameter::default_instance_ = NULL;

BgGuassianParameter* BgGuassianParameter::New() const {
  return new BgGuassianParameter;
}

void BgGuassianParameter::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    num_history_ = 20u;
    var_threshold_ = 4u;
    shadow_detection_ = true;
    learn_rate_ = 0.01f;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BgGuassianParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.BgGuassianParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 num_history = 1 [default = 20];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_history_)));
          set_has_num_history();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_var_threshold;
        break;
      }

      // optional uint32 var_threshold = 2 [default = 4];
      case 2: {
        if (tag == 16) {
         parse_var_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &var_threshold_)));
          set_has_var_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_shadow_detection;
        break;
      }

      // optional bool shadow_detection = 3 [default = true];
      case 3: {
        if (tag == 24) {
         parse_shadow_detection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shadow_detection_)));
          set_has_shadow_detection();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_learn_rate;
        break;
      }

      // optional float learn_rate = 4 [default = 0.01];
      case 4: {
        if (tag == 37) {
         parse_learn_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &learn_rate_)));
          set_has_learn_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.BgGuassianParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.BgGuassianParameter)
  return false;
#undef DO_
}

void BgGuassianParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.BgGuassianParameter)
  // optional uint32 num_history = 1 [default = 20];
  if (has_num_history()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->num_history(), output);
  }

  // optional uint32 var_threshold = 2 [default = 4];
  if (has_var_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->var_threshold(), output);
  }

  // optional bool shadow_detection = 3 [default = true];
  if (has_shadow_detection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->shadow_detection(), output);
  }

  // optional float learn_rate = 4 [default = 0.01];
  if (has_learn_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->learn_rate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.BgGuassianParameter)
}

::google::protobuf::uint8* BgGuassianParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.BgGuassianParameter)
  // optional uint32 num_history = 1 [default = 20];
  if (has_num_history()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->num_history(), target);
  }

  // optional uint32 var_threshold = 2 [default = 4];
  if (has_var_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->var_threshold(), target);
  }

  // optional bool shadow_detection = 3 [default = true];
  if (has_shadow_detection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->shadow_detection(), target);
  }

  // optional float learn_rate = 4 [default = 0.01];
  if (has_learn_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->learn_rate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.BgGuassianParameter)
  return target;
}

int BgGuassianParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 num_history = 1 [default = 20];
    if (has_num_history()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_history());
    }

    // optional uint32 var_threshold = 2 [default = 4];
    if (has_var_threshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->var_threshold());
    }

    // optional bool shadow_detection = 3 [default = true];
    if (has_shadow_detection()) {
      total_size += 1 + 1;
    }

    // optional float learn_rate = 4 [default = 0.01];
    if (has_learn_rate()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BgGuassianParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BgGuassianParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BgGuassianParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BgGuassianParameter::MergeFrom(const BgGuassianParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num_history()) {
      set_num_history(from.num_history());
    }
    if (from.has_var_threshold()) {
      set_var_threshold(from.var_threshold());
    }
    if (from.has_shadow_detection()) {
      set_shadow_detection(from.shadow_detection());
    }
    if (from.has_learn_rate()) {
      set_learn_rate(from.learn_rate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BgGuassianParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BgGuassianParameter::CopyFrom(const BgGuassianParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BgGuassianParameter::IsInitialized() const {

  return true;
}

void BgGuassianParameter::Swap(BgGuassianParameter* other) {
  if (other != this) {
    std::swap(num_history_, other->num_history_);
    std::swap(var_threshold_, other->var_threshold_);
    std::swap(shadow_detection_, other->shadow_detection_);
    std::swap(learn_rate_, other->learn_rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BgGuassianParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BgGuassianParameter_descriptor_;
  metadata.reflection = BgGuassianParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BgVibeParameter::kNumSamplesFieldNumber;
const int BgVibeParameter::kMinMatchFieldNumber;
const int BgVibeParameter::kRadiusFieldNumber;
const int BgVibeParameter::kSubsampleFactorFieldNumber;
const int BgVibeParameter::kBg2DelayFieldNumber;
const int BgVibeParameter::kMaxMismatchCountFieldNumber;
const int BgVibeParameter::kDoubleBgFieldNumber;
const int BgVibeParameter::kLearnRateFieldNumber;
#endif  // !_MSC_VER

BgVibeParameter::BgVibeParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.BgVibeParameter)
}

void BgVibeParameter::InitAsDefaultInstance() {
}

BgVibeParameter::BgVibeParameter(const BgVibeParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.BgVibeParameter)
}

void BgVibeParameter::SharedCtor() {
  _cached_size_ = 0;
  num_samples_ = 20u;
  min_match_ = 4u;
  radius_ = 10u;
  subsample_factor_ = 16u;
  bg2_delay_ = 50u;
  max_mismatch_count_ = 50u;
  double_bg_ = false;
  learn_rate_ = 0.5f;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BgVibeParameter::~BgVibeParameter() {
  // @@protoc_insertion_point(destructor:vas.BgVibeParameter)
  SharedDtor();
}

void BgVibeParameter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BgVibeParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BgVibeParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BgVibeParameter_descriptor_;
}

const BgVibeParameter& BgVibeParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

BgVibeParameter* BgVibeParameter::default_instance_ = NULL;

BgVibeParameter* BgVibeParameter::New() const {
  return new BgVibeParameter;
}

void BgVibeParameter::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    num_samples_ = 20u;
    min_match_ = 4u;
    radius_ = 10u;
    subsample_factor_ = 16u;
    bg2_delay_ = 50u;
    max_mismatch_count_ = 50u;
    double_bg_ = false;
    learn_rate_ = 0.5f;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BgVibeParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.BgVibeParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 num_samples = 1 [default = 20];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_samples_)));
          set_has_num_samples();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_min_match;
        break;
      }

      // optional uint32 min_match = 2 [default = 4];
      case 2: {
        if (tag == 16) {
         parse_min_match:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_match_)));
          set_has_min_match();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_radius;
        break;
      }

      // optional uint32 radius = 3 [default = 10];
      case 3: {
        if (tag == 24) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_subsample_factor;
        break;
      }

      // optional uint32 subsample_factor = 4 [default = 16];
      case 4: {
        if (tag == 32) {
         parse_subsample_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &subsample_factor_)));
          set_has_subsample_factor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_bg2_delay;
        break;
      }

      // optional uint32 bg2_delay = 5 [default = 50];
      case 5: {
        if (tag == 40) {
         parse_bg2_delay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bg2_delay_)));
          set_has_bg2_delay();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_max_mismatch_count;
        break;
      }

      // optional uint32 max_mismatch_count = 6 [default = 50];
      case 6: {
        if (tag == 48) {
         parse_max_mismatch_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_mismatch_count_)));
          set_has_max_mismatch_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_double_bg;
        break;
      }

      // optional bool double_bg = 7 [default = false];
      case 7: {
        if (tag == 56) {
         parse_double_bg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &double_bg_)));
          set_has_double_bg();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_learn_rate;
        break;
      }

      // optional float learn_rate = 8 [default = 0.5];
      case 8: {
        if (tag == 69) {
         parse_learn_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &learn_rate_)));
          set_has_learn_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.BgVibeParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.BgVibeParameter)
  return false;
#undef DO_
}

void BgVibeParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.BgVibeParameter)
  // optional uint32 num_samples = 1 [default = 20];
  if (has_num_samples()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->num_samples(), output);
  }

  // optional uint32 min_match = 2 [default = 4];
  if (has_min_match()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->min_match(), output);
  }

  // optional uint32 radius = 3 [default = 10];
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->radius(), output);
  }

  // optional uint32 subsample_factor = 4 [default = 16];
  if (has_subsample_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->subsample_factor(), output);
  }

  // optional uint32 bg2_delay = 5 [default = 50];
  if (has_bg2_delay()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->bg2_delay(), output);
  }

  // optional uint32 max_mismatch_count = 6 [default = 50];
  if (has_max_mismatch_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->max_mismatch_count(), output);
  }

  // optional bool double_bg = 7 [default = false];
  if (has_double_bg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->double_bg(), output);
  }

  // optional float learn_rate = 8 [default = 0.5];
  if (has_learn_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->learn_rate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.BgVibeParameter)
}

::google::protobuf::uint8* BgVibeParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.BgVibeParameter)
  // optional uint32 num_samples = 1 [default = 20];
  if (has_num_samples()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->num_samples(), target);
  }

  // optional uint32 min_match = 2 [default = 4];
  if (has_min_match()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->min_match(), target);
  }

  // optional uint32 radius = 3 [default = 10];
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->radius(), target);
  }

  // optional uint32 subsample_factor = 4 [default = 16];
  if (has_subsample_factor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->subsample_factor(), target);
  }

  // optional uint32 bg2_delay = 5 [default = 50];
  if (has_bg2_delay()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->bg2_delay(), target);
  }

  // optional uint32 max_mismatch_count = 6 [default = 50];
  if (has_max_mismatch_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->max_mismatch_count(), target);
  }

  // optional bool double_bg = 7 [default = false];
  if (has_double_bg()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->double_bg(), target);
  }

  // optional float learn_rate = 8 [default = 0.5];
  if (has_learn_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->learn_rate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.BgVibeParameter)
  return target;
}

int BgVibeParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 num_samples = 1 [default = 20];
    if (has_num_samples()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_samples());
    }

    // optional uint32 min_match = 2 [default = 4];
    if (has_min_match()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_match());
    }

    // optional uint32 radius = 3 [default = 10];
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->radius());
    }

    // optional uint32 subsample_factor = 4 [default = 16];
    if (has_subsample_factor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->subsample_factor());
    }

    // optional uint32 bg2_delay = 5 [default = 50];
    if (has_bg2_delay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bg2_delay());
    }

    // optional uint32 max_mismatch_count = 6 [default = 50];
    if (has_max_mismatch_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_mismatch_count());
    }

    // optional bool double_bg = 7 [default = false];
    if (has_double_bg()) {
      total_size += 1 + 1;
    }

    // optional float learn_rate = 8 [default = 0.5];
    if (has_learn_rate()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BgVibeParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BgVibeParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BgVibeParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BgVibeParameter::MergeFrom(const BgVibeParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_num_samples()) {
      set_num_samples(from.num_samples());
    }
    if (from.has_min_match()) {
      set_min_match(from.min_match());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_subsample_factor()) {
      set_subsample_factor(from.subsample_factor());
    }
    if (from.has_bg2_delay()) {
      set_bg2_delay(from.bg2_delay());
    }
    if (from.has_max_mismatch_count()) {
      set_max_mismatch_count(from.max_mismatch_count());
    }
    if (from.has_double_bg()) {
      set_double_bg(from.double_bg());
    }
    if (from.has_learn_rate()) {
      set_learn_rate(from.learn_rate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BgVibeParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BgVibeParameter::CopyFrom(const BgVibeParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BgVibeParameter::IsInitialized() const {

  return true;
}

void BgVibeParameter::Swap(BgVibeParameter* other) {
  if (other != this) {
    std::swap(num_samples_, other->num_samples_);
    std::swap(min_match_, other->min_match_);
    std::swap(radius_, other->radius_);
    std::swap(subsample_factor_, other->subsample_factor_);
    std::swap(bg2_delay_, other->bg2_delay_);
    std::swap(max_mismatch_count_, other->max_mismatch_count_);
    std::swap(double_bg_, other->double_bg_);
    std::swap(learn_rate_, other->learn_rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BgVibeParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BgVibeParameter_descriptor_;
  metadata.reflection = BgVibeParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BgOperation::kMorphologyOpenTimesFieldNumber;
const int BgOperation::kDilateTimesFieldNumber;
#endif  // !_MSC_VER

BgOperation::BgOperation()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.BgOperation)
}

void BgOperation::InitAsDefaultInstance() {
}

BgOperation::BgOperation(const BgOperation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.BgOperation)
}

void BgOperation::SharedCtor() {
  _cached_size_ = 0;
  morphology_open_times_ = 1u;
  dilate_times_ = 1u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BgOperation::~BgOperation() {
  // @@protoc_insertion_point(destructor:vas.BgOperation)
  SharedDtor();
}

void BgOperation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BgOperation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BgOperation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BgOperation_descriptor_;
}

const BgOperation& BgOperation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

BgOperation* BgOperation::default_instance_ = NULL;

BgOperation* BgOperation::New() const {
  return new BgOperation;
}

void BgOperation::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    morphology_open_times_ = 1u;
    dilate_times_ = 1u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BgOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.BgOperation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 morphology_open_times = 1 [default = 1];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &morphology_open_times_)));
          set_has_morphology_open_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_dilate_times;
        break;
      }

      // optional uint32 dilate_times = 2 [default = 1];
      case 2: {
        if (tag == 16) {
         parse_dilate_times:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dilate_times_)));
          set_has_dilate_times();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.BgOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.BgOperation)
  return false;
#undef DO_
}

void BgOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.BgOperation)
  // optional uint32 morphology_open_times = 1 [default = 1];
  if (has_morphology_open_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->morphology_open_times(), output);
  }

  // optional uint32 dilate_times = 2 [default = 1];
  if (has_dilate_times()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->dilate_times(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.BgOperation)
}

::google::protobuf::uint8* BgOperation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.BgOperation)
  // optional uint32 morphology_open_times = 1 [default = 1];
  if (has_morphology_open_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->morphology_open_times(), target);
  }

  // optional uint32 dilate_times = 2 [default = 1];
  if (has_dilate_times()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->dilate_times(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.BgOperation)
  return target;
}

int BgOperation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 morphology_open_times = 1 [default = 1];
    if (has_morphology_open_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->morphology_open_times());
    }

    // optional uint32 dilate_times = 2 [default = 1];
    if (has_dilate_times()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dilate_times());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BgOperation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BgOperation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BgOperation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BgOperation::MergeFrom(const BgOperation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_morphology_open_times()) {
      set_morphology_open_times(from.morphology_open_times());
    }
    if (from.has_dilate_times()) {
      set_dilate_times(from.dilate_times());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BgOperation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BgOperation::CopyFrom(const BgOperation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BgOperation::IsInitialized() const {

  return true;
}

void BgOperation::Swap(BgOperation* other) {
  if (other != this) {
    std::swap(morphology_open_times_, other->morphology_open_times_);
    std::swap(dilate_times_, other->dilate_times_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BgOperation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BgOperation_descriptor_;
  metadata.reflection = BgOperation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BgParameter::kBgMethodFieldNumber;
const int BgParameter::kStableThresholdFieldNumber;
const int BgParameter::kGuassianParameterFieldNumber;
const int BgParameter::kVibeParameterFieldNumber;
const int BgParameter::kBgOperationFieldNumber;
const int BgParameter::kBgStatusFieldNumber;
const int BgParameter::kBgWidthFieldNumber;
const int BgParameter::kBgHeightFieldNumber;
#endif  // !_MSC_VER

BgParameter::BgParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.BgParameter)
}

void BgParameter::InitAsDefaultInstance() {
  guassian_parameter_ = const_cast< ::vas::BgGuassianParameter*>(&::vas::BgGuassianParameter::default_instance());
  vibe_parameter_ = const_cast< ::vas::BgVibeParameter*>(&::vas::BgVibeParameter::default_instance());
  bg_operation_ = const_cast< ::vas::BgOperation*>(&::vas::BgOperation::default_instance());
}

BgParameter::BgParameter(const BgParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.BgParameter)
}

void BgParameter::SharedCtor() {
  _cached_size_ = 0;
  bg_method_ = 2;
  stable_threshold_ = 0.5f;
  guassian_parameter_ = NULL;
  vibe_parameter_ = NULL;
  bg_operation_ = NULL;
  bg_status_ = 0;
  bg_width_ = 420u;
  bg_height_ = 320u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BgParameter::~BgParameter() {
  // @@protoc_insertion_point(destructor:vas.BgParameter)
  SharedDtor();
}

void BgParameter::SharedDtor() {
  if (this != default_instance_) {
    delete guassian_parameter_;
    delete vibe_parameter_;
    delete bg_operation_;
  }
}

void BgParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BgParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BgParameter_descriptor_;
}

const BgParameter& BgParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

BgParameter* BgParameter::default_instance_ = NULL;

BgParameter* BgParameter::New() const {
  return new BgParameter;
}

void BgParameter::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    bg_method_ = 2;
    stable_threshold_ = 0.5f;
    if (has_guassian_parameter()) {
      if (guassian_parameter_ != NULL) guassian_parameter_->::vas::BgGuassianParameter::Clear();
    }
    if (has_vibe_parameter()) {
      if (vibe_parameter_ != NULL) vibe_parameter_->::vas::BgVibeParameter::Clear();
    }
    if (has_bg_operation()) {
      if (bg_operation_ != NULL) bg_operation_->::vas::BgOperation::Clear();
    }
    bg_status_ = 0;
    bg_width_ = 420u;
    bg_height_ = 320u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BgParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.BgParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vas.BgMethod bg_method = 1 [default = GUASSIAN_CPU];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::BgMethod_IsValid(value)) {
            set_bg_method(static_cast< ::vas::BgMethod >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_stable_threshold;
        break;
      }

      // optional float stable_threshold = 2 [default = 0.5];
      case 2: {
        if (tag == 21) {
         parse_stable_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &stable_threshold_)));
          set_has_stable_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_guassian_parameter;
        break;
      }

      // optional .vas.BgGuassianParameter guassian_parameter = 3;
      case 3: {
        if (tag == 26) {
         parse_guassian_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_guassian_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_vibe_parameter;
        break;
      }

      // optional .vas.BgVibeParameter vibe_parameter = 4;
      case 4: {
        if (tag == 34) {
         parse_vibe_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vibe_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_bg_operation;
        break;
      }

      // optional .vas.BgOperation bg_operation = 5;
      case 5: {
        if (tag == 42) {
         parse_bg_operation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bg_operation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_bg_status;
        break;
      }

      // optional .vas.BgStatus bg_status = 6 [default = BG_UNINIALIZED];
      case 6: {
        if (tag == 48) {
         parse_bg_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::BgStatus_IsValid(value)) {
            set_bg_status(static_cast< ::vas::BgStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_bg_width;
        break;
      }

      // optional uint32 bg_width = 7 [default = 420];
      case 7: {
        if (tag == 56) {
         parse_bg_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bg_width_)));
          set_has_bg_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_bg_height;
        break;
      }

      // optional uint32 bg_height = 8 [default = 320];
      case 8: {
        if (tag == 64) {
         parse_bg_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bg_height_)));
          set_has_bg_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.BgParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.BgParameter)
  return false;
#undef DO_
}

void BgParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.BgParameter)
  // optional .vas.BgMethod bg_method = 1 [default = GUASSIAN_CPU];
  if (has_bg_method()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->bg_method(), output);
  }

  // optional float stable_threshold = 2 [default = 0.5];
  if (has_stable_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->stable_threshold(), output);
  }

  // optional .vas.BgGuassianParameter guassian_parameter = 3;
  if (has_guassian_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->guassian_parameter(), output);
  }

  // optional .vas.BgVibeParameter vibe_parameter = 4;
  if (has_vibe_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->vibe_parameter(), output);
  }

  // optional .vas.BgOperation bg_operation = 5;
  if (has_bg_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->bg_operation(), output);
  }

  // optional .vas.BgStatus bg_status = 6 [default = BG_UNINIALIZED];
  if (has_bg_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->bg_status(), output);
  }

  // optional uint32 bg_width = 7 [default = 420];
  if (has_bg_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->bg_width(), output);
  }

  // optional uint32 bg_height = 8 [default = 320];
  if (has_bg_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->bg_height(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.BgParameter)
}

::google::protobuf::uint8* BgParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.BgParameter)
  // optional .vas.BgMethod bg_method = 1 [default = GUASSIAN_CPU];
  if (has_bg_method()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->bg_method(), target);
  }

  // optional float stable_threshold = 2 [default = 0.5];
  if (has_stable_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->stable_threshold(), target);
  }

  // optional .vas.BgGuassianParameter guassian_parameter = 3;
  if (has_guassian_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->guassian_parameter(), target);
  }

  // optional .vas.BgVibeParameter vibe_parameter = 4;
  if (has_vibe_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->vibe_parameter(), target);
  }

  // optional .vas.BgOperation bg_operation = 5;
  if (has_bg_operation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->bg_operation(), target);
  }

  // optional .vas.BgStatus bg_status = 6 [default = BG_UNINIALIZED];
  if (has_bg_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->bg_status(), target);
  }

  // optional uint32 bg_width = 7 [default = 420];
  if (has_bg_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->bg_width(), target);
  }

  // optional uint32 bg_height = 8 [default = 320];
  if (has_bg_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->bg_height(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.BgParameter)
  return target;
}

int BgParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vas.BgMethod bg_method = 1 [default = GUASSIAN_CPU];
    if (has_bg_method()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->bg_method());
    }

    // optional float stable_threshold = 2 [default = 0.5];
    if (has_stable_threshold()) {
      total_size += 1 + 4;
    }

    // optional .vas.BgGuassianParameter guassian_parameter = 3;
    if (has_guassian_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->guassian_parameter());
    }

    // optional .vas.BgVibeParameter vibe_parameter = 4;
    if (has_vibe_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vibe_parameter());
    }

    // optional .vas.BgOperation bg_operation = 5;
    if (has_bg_operation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bg_operation());
    }

    // optional .vas.BgStatus bg_status = 6 [default = BG_UNINIALIZED];
    if (has_bg_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->bg_status());
    }

    // optional uint32 bg_width = 7 [default = 420];
    if (has_bg_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bg_width());
    }

    // optional uint32 bg_height = 8 [default = 320];
    if (has_bg_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bg_height());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BgParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BgParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BgParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BgParameter::MergeFrom(const BgParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bg_method()) {
      set_bg_method(from.bg_method());
    }
    if (from.has_stable_threshold()) {
      set_stable_threshold(from.stable_threshold());
    }
    if (from.has_guassian_parameter()) {
      mutable_guassian_parameter()->::vas::BgGuassianParameter::MergeFrom(from.guassian_parameter());
    }
    if (from.has_vibe_parameter()) {
      mutable_vibe_parameter()->::vas::BgVibeParameter::MergeFrom(from.vibe_parameter());
    }
    if (from.has_bg_operation()) {
      mutable_bg_operation()->::vas::BgOperation::MergeFrom(from.bg_operation());
    }
    if (from.has_bg_status()) {
      set_bg_status(from.bg_status());
    }
    if (from.has_bg_width()) {
      set_bg_width(from.bg_width());
    }
    if (from.has_bg_height()) {
      set_bg_height(from.bg_height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BgParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BgParameter::CopyFrom(const BgParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BgParameter::IsInitialized() const {

  return true;
}

void BgParameter::Swap(BgParameter* other) {
  if (other != this) {
    std::swap(bg_method_, other->bg_method_);
    std::swap(stable_threshold_, other->stable_threshold_);
    std::swap(guassian_parameter_, other->guassian_parameter_);
    std::swap(vibe_parameter_, other->vibe_parameter_);
    std::swap(bg_operation_, other->bg_operation_);
    std::swap(bg_status_, other->bg_status_);
    std::swap(bg_width_, other->bg_width_);
    std::swap(bg_height_, other->bg_height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BgParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BgParameter_descriptor_;
  metadata.reflection = BgParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColorThreshold::kLowerFieldNumber;
const int ColorThreshold::kUpperFieldNumber;
#endif  // !_MSC_VER

ColorThreshold::ColorThreshold()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.ColorThreshold)
}

void ColorThreshold::InitAsDefaultInstance() {
}

ColorThreshold::ColorThreshold(const ColorThreshold& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.ColorThreshold)
}

void ColorThreshold::SharedCtor() {
  _cached_size_ = 0;
  lower_ = 0;
  upper_ = 255;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColorThreshold::~ColorThreshold() {
  // @@protoc_insertion_point(destructor:vas.ColorThreshold)
  SharedDtor();
}

void ColorThreshold::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ColorThreshold::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColorThreshold::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColorThreshold_descriptor_;
}

const ColorThreshold& ColorThreshold::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

ColorThreshold* ColorThreshold::default_instance_ = NULL;

ColorThreshold* ColorThreshold::New() const {
  return new ColorThreshold;
}

void ColorThreshold::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    lower_ = 0;
    upper_ = 255;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColorThreshold::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.ColorThreshold)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float lower = 1 [default = 0];
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lower_)));
          set_has_lower();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_upper;
        break;
      }

      // optional float upper = 2 [default = 255];
      case 2: {
        if (tag == 21) {
         parse_upper:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &upper_)));
          set_has_upper();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.ColorThreshold)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.ColorThreshold)
  return false;
#undef DO_
}

void ColorThreshold::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.ColorThreshold)
  // optional float lower = 1 [default = 0];
  if (has_lower()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->lower(), output);
  }

  // optional float upper = 2 [default = 255];
  if (has_upper()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->upper(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.ColorThreshold)
}

::google::protobuf::uint8* ColorThreshold::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.ColorThreshold)
  // optional float lower = 1 [default = 0];
  if (has_lower()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->lower(), target);
  }

  // optional float upper = 2 [default = 255];
  if (has_upper()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->upper(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.ColorThreshold)
  return target;
}

int ColorThreshold::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float lower = 1 [default = 0];
    if (has_lower()) {
      total_size += 1 + 4;
    }

    // optional float upper = 2 [default = 255];
    if (has_upper()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColorThreshold::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColorThreshold* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColorThreshold*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColorThreshold::MergeFrom(const ColorThreshold& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lower()) {
      set_lower(from.lower());
    }
    if (from.has_upper()) {
      set_upper(from.upper());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColorThreshold::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColorThreshold::CopyFrom(const ColorThreshold& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorThreshold::IsInitialized() const {

  return true;
}

void ColorThreshold::Swap(ColorThreshold* other) {
  if (other != this) {
    std::swap(lower_, other->lower_);
    std::swap(upper_, other->upper_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColorThreshold::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColorThreshold_descriptor_;
  metadata.reflection = ColorThreshold_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FilterParameter::kContourAreaThresholdFieldNumber;
const int FilterParameter::kContourPerimeterThresholdFieldNumber;
const int FilterParameter::kAreaPerimeterRatioThresholdFieldNumber;
const int FilterParameter::kFilterTypeFieldNumber;
const int FilterParameter::kRgbTh1FieldNumber;
const int FilterParameter::kRgbTh2FieldNumber;
const int FilterParameter::kYcbcrTh1FieldNumber;
const int FilterParameter::kYcbcrTh2FieldNumber;
const int FilterParameter::kColorFitRatioFieldNumber;
const int FilterParameter::kFilterWidthFieldNumber;
const int FilterParameter::kFilterHeightFieldNumber;
const int FilterParameter::kFilterMethodFieldNumber;
#endif  // !_MSC_VER

FilterParameter::FilterParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.FilterParameter)
}

void FilterParameter::InitAsDefaultInstance() {
  rgb_th_1_ = const_cast< ::vas::ColorThreshold*>(&::vas::ColorThreshold::default_instance());
  rgb_th_2_ = const_cast< ::vas::ColorThreshold*>(&::vas::ColorThreshold::default_instance());
  ycbcr_th_1_ = const_cast< ::vas::ColorThreshold*>(&::vas::ColorThreshold::default_instance());
  ycbcr_th_2_ = const_cast< ::vas::ColorThreshold*>(&::vas::ColorThreshold::default_instance());
}

FilterParameter::FilterParameter(const FilterParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.FilterParameter)
}

void FilterParameter::SharedCtor() {
  _cached_size_ = 0;
  contour_area_threshold_ = 500u;
  contour_perimeter_threshold_ = 10u;
  area_perimeter_ratio_threshold_ = 0.01f;
  filter_type_ = 1;
  rgb_th_1_ = NULL;
  rgb_th_2_ = NULL;
  ycbcr_th_1_ = NULL;
  ycbcr_th_2_ = NULL;
  color_fit_ratio_ = 0.5f;
  filter_width_ = 420u;
  filter_height_ = 320u;
  filter_method_ = 4;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilterParameter::~FilterParameter() {
  // @@protoc_insertion_point(destructor:vas.FilterParameter)
  SharedDtor();
}

void FilterParameter::SharedDtor() {
  if (this != default_instance_) {
    delete rgb_th_1_;
    delete rgb_th_2_;
    delete ycbcr_th_1_;
    delete ycbcr_th_2_;
  }
}

void FilterParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FilterParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilterParameter_descriptor_;
}

const FilterParameter& FilterParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

FilterParameter* FilterParameter::default_instance_ = NULL;

FilterParameter* FilterParameter::New() const {
  return new FilterParameter;
}

void FilterParameter::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    contour_area_threshold_ = 500u;
    contour_perimeter_threshold_ = 10u;
    area_perimeter_ratio_threshold_ = 0.01f;
    filter_type_ = 1;
    if (has_rgb_th_1()) {
      if (rgb_th_1_ != NULL) rgb_th_1_->::vas::ColorThreshold::Clear();
    }
    if (has_rgb_th_2()) {
      if (rgb_th_2_ != NULL) rgb_th_2_->::vas::ColorThreshold::Clear();
    }
    if (has_ycbcr_th_1()) {
      if (ycbcr_th_1_ != NULL) ycbcr_th_1_->::vas::ColorThreshold::Clear();
    }
    if (has_ycbcr_th_2()) {
      if (ycbcr_th_2_ != NULL) ycbcr_th_2_->::vas::ColorThreshold::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 3840) {
    color_fit_ratio_ = 0.5f;
    filter_width_ = 420u;
    filter_height_ = 320u;
    filter_method_ = 4;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FilterParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.FilterParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 contour_area_threshold = 1 [default = 500];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &contour_area_threshold_)));
          set_has_contour_area_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_contour_perimeter_threshold;
        break;
      }

      // optional uint32 contour_perimeter_threshold = 2 [default = 10];
      case 2: {
        if (tag == 16) {
         parse_contour_perimeter_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &contour_perimeter_threshold_)));
          set_has_contour_perimeter_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_area_perimeter_ratio_threshold;
        break;
      }

      // optional float area_perimeter_ratio_threshold = 3 [default = 0.01];
      case 3: {
        if (tag == 29) {
         parse_area_perimeter_ratio_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &area_perimeter_ratio_threshold_)));
          set_has_area_perimeter_ratio_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_rgb_th_1;
        break;
      }

      // optional .vas.ColorThreshold rgb_th_1 = 4;
      case 4: {
        if (tag == 34) {
         parse_rgb_th_1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rgb_th_1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_rgb_th_2;
        break;
      }

      // optional .vas.ColorThreshold rgb_th_2 = 5;
      case 5: {
        if (tag == 42) {
         parse_rgb_th_2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rgb_th_2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ycbcr_th_1;
        break;
      }

      // optional .vas.ColorThreshold ycbcr_th_1 = 6;
      case 6: {
        if (tag == 50) {
         parse_ycbcr_th_1:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ycbcr_th_1()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_ycbcr_th_2;
        break;
      }

      // optional .vas.ColorThreshold ycbcr_th_2 = 7;
      case 7: {
        if (tag == 58) {
         parse_ycbcr_th_2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ycbcr_th_2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_color_fit_ratio;
        break;
      }

      // optional float color_fit_ratio = 8 [default = 0.5];
      case 8: {
        if (tag == 69) {
         parse_color_fit_ratio:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &color_fit_ratio_)));
          set_has_color_fit_ratio();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_filter_width;
        break;
      }

      // optional uint32 filter_width = 9 [default = 420];
      case 9: {
        if (tag == 72) {
         parse_filter_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &filter_width_)));
          set_has_filter_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_filter_height;
        break;
      }

      // optional uint32 filter_height = 10 [default = 320];
      case 10: {
        if (tag == 80) {
         parse_filter_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &filter_height_)));
          set_has_filter_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_filter_method;
        break;
      }

      // optional .vas.FilterMethod filter_method = 11 [default = PURE_CONTOUR_AREA];
      case 11: {
        if (tag == 88) {
         parse_filter_method:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::FilterMethod_IsValid(value)) {
            set_filter_method(static_cast< ::vas::FilterMethod >(value));
          } else {
            mutable_unknown_fields()->AddVarint(11, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_filter_type;
        break;
      }

      // optional .vas.FilterType filter_type = 12 [default = SMOKE_FILTER];
      case 12: {
        if (tag == 96) {
         parse_filter_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::FilterType_IsValid(value)) {
            set_filter_type(static_cast< ::vas::FilterType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(12, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.FilterParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.FilterParameter)
  return false;
#undef DO_
}

void FilterParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.FilterParameter)
  // optional uint32 contour_area_threshold = 1 [default = 500];
  if (has_contour_area_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->contour_area_threshold(), output);
  }

  // optional uint32 contour_perimeter_threshold = 2 [default = 10];
  if (has_contour_perimeter_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->contour_perimeter_threshold(), output);
  }

  // optional float area_perimeter_ratio_threshold = 3 [default = 0.01];
  if (has_area_perimeter_ratio_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->area_perimeter_ratio_threshold(), output);
  }

  // optional .vas.ColorThreshold rgb_th_1 = 4;
  if (has_rgb_th_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->rgb_th_1(), output);
  }

  // optional .vas.ColorThreshold rgb_th_2 = 5;
  if (has_rgb_th_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->rgb_th_2(), output);
  }

  // optional .vas.ColorThreshold ycbcr_th_1 = 6;
  if (has_ycbcr_th_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->ycbcr_th_1(), output);
  }

  // optional .vas.ColorThreshold ycbcr_th_2 = 7;
  if (has_ycbcr_th_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->ycbcr_th_2(), output);
  }

  // optional float color_fit_ratio = 8 [default = 0.5];
  if (has_color_fit_ratio()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->color_fit_ratio(), output);
  }

  // optional uint32 filter_width = 9 [default = 420];
  if (has_filter_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->filter_width(), output);
  }

  // optional uint32 filter_height = 10 [default = 320];
  if (has_filter_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->filter_height(), output);
  }

  // optional .vas.FilterMethod filter_method = 11 [default = PURE_CONTOUR_AREA];
  if (has_filter_method()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->filter_method(), output);
  }

  // optional .vas.FilterType filter_type = 12 [default = SMOKE_FILTER];
  if (has_filter_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->filter_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.FilterParameter)
}

::google::protobuf::uint8* FilterParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.FilterParameter)
  // optional uint32 contour_area_threshold = 1 [default = 500];
  if (has_contour_area_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->contour_area_threshold(), target);
  }

  // optional uint32 contour_perimeter_threshold = 2 [default = 10];
  if (has_contour_perimeter_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->contour_perimeter_threshold(), target);
  }

  // optional float area_perimeter_ratio_threshold = 3 [default = 0.01];
  if (has_area_perimeter_ratio_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->area_perimeter_ratio_threshold(), target);
  }

  // optional .vas.ColorThreshold rgb_th_1 = 4;
  if (has_rgb_th_1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->rgb_th_1(), target);
  }

  // optional .vas.ColorThreshold rgb_th_2 = 5;
  if (has_rgb_th_2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->rgb_th_2(), target);
  }

  // optional .vas.ColorThreshold ycbcr_th_1 = 6;
  if (has_ycbcr_th_1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->ycbcr_th_1(), target);
  }

  // optional .vas.ColorThreshold ycbcr_th_2 = 7;
  if (has_ycbcr_th_2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->ycbcr_th_2(), target);
  }

  // optional float color_fit_ratio = 8 [default = 0.5];
  if (has_color_fit_ratio()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->color_fit_ratio(), target);
  }

  // optional uint32 filter_width = 9 [default = 420];
  if (has_filter_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->filter_width(), target);
  }

  // optional uint32 filter_height = 10 [default = 320];
  if (has_filter_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->filter_height(), target);
  }

  // optional .vas.FilterMethod filter_method = 11 [default = PURE_CONTOUR_AREA];
  if (has_filter_method()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->filter_method(), target);
  }

  // optional .vas.FilterType filter_type = 12 [default = SMOKE_FILTER];
  if (has_filter_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->filter_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.FilterParameter)
  return target;
}

int FilterParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 contour_area_threshold = 1 [default = 500];
    if (has_contour_area_threshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->contour_area_threshold());
    }

    // optional uint32 contour_perimeter_threshold = 2 [default = 10];
    if (has_contour_perimeter_threshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->contour_perimeter_threshold());
    }

    // optional float area_perimeter_ratio_threshold = 3 [default = 0.01];
    if (has_area_perimeter_ratio_threshold()) {
      total_size += 1 + 4;
    }

    // optional .vas.FilterType filter_type = 12 [default = SMOKE_FILTER];
    if (has_filter_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filter_type());
    }

    // optional .vas.ColorThreshold rgb_th_1 = 4;
    if (has_rgb_th_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rgb_th_1());
    }

    // optional .vas.ColorThreshold rgb_th_2 = 5;
    if (has_rgb_th_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rgb_th_2());
    }

    // optional .vas.ColorThreshold ycbcr_th_1 = 6;
    if (has_ycbcr_th_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ycbcr_th_1());
    }

    // optional .vas.ColorThreshold ycbcr_th_2 = 7;
    if (has_ycbcr_th_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ycbcr_th_2());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float color_fit_ratio = 8 [default = 0.5];
    if (has_color_fit_ratio()) {
      total_size += 1 + 4;
    }

    // optional uint32 filter_width = 9 [default = 420];
    if (has_filter_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->filter_width());
    }

    // optional uint32 filter_height = 10 [default = 320];
    if (has_filter_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->filter_height());
    }

    // optional .vas.FilterMethod filter_method = 11 [default = PURE_CONTOUR_AREA];
    if (has_filter_method()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filter_method());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilterParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FilterParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FilterParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FilterParameter::MergeFrom(const FilterParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_contour_area_threshold()) {
      set_contour_area_threshold(from.contour_area_threshold());
    }
    if (from.has_contour_perimeter_threshold()) {
      set_contour_perimeter_threshold(from.contour_perimeter_threshold());
    }
    if (from.has_area_perimeter_ratio_threshold()) {
      set_area_perimeter_ratio_threshold(from.area_perimeter_ratio_threshold());
    }
    if (from.has_filter_type()) {
      set_filter_type(from.filter_type());
    }
    if (from.has_rgb_th_1()) {
      mutable_rgb_th_1()->::vas::ColorThreshold::MergeFrom(from.rgb_th_1());
    }
    if (from.has_rgb_th_2()) {
      mutable_rgb_th_2()->::vas::ColorThreshold::MergeFrom(from.rgb_th_2());
    }
    if (from.has_ycbcr_th_1()) {
      mutable_ycbcr_th_1()->::vas::ColorThreshold::MergeFrom(from.ycbcr_th_1());
    }
    if (from.has_ycbcr_th_2()) {
      mutable_ycbcr_th_2()->::vas::ColorThreshold::MergeFrom(from.ycbcr_th_2());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_color_fit_ratio()) {
      set_color_fit_ratio(from.color_fit_ratio());
    }
    if (from.has_filter_width()) {
      set_filter_width(from.filter_width());
    }
    if (from.has_filter_height()) {
      set_filter_height(from.filter_height());
    }
    if (from.has_filter_method()) {
      set_filter_method(from.filter_method());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FilterParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FilterParameter::CopyFrom(const FilterParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterParameter::IsInitialized() const {

  return true;
}

void FilterParameter::Swap(FilterParameter* other) {
  if (other != this) {
    std::swap(contour_area_threshold_, other->contour_area_threshold_);
    std::swap(contour_perimeter_threshold_, other->contour_perimeter_threshold_);
    std::swap(area_perimeter_ratio_threshold_, other->area_perimeter_ratio_threshold_);
    std::swap(filter_type_, other->filter_type_);
    std::swap(rgb_th_1_, other->rgb_th_1_);
    std::swap(rgb_th_2_, other->rgb_th_2_);
    std::swap(ycbcr_th_1_, other->ycbcr_th_1_);
    std::swap(ycbcr_th_2_, other->ycbcr_th_2_);
    std::swap(color_fit_ratio_, other->color_fit_ratio_);
    std::swap(filter_width_, other->filter_width_);
    std::swap(filter_height_, other->filter_height_);
    std::swap(filter_method_, other->filter_method_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FilterParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FilterParameter_descriptor_;
  metadata.reflection = FilterParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CaffeClassifierParameter::kConfienceScoreFieldNumber;
const int CaffeClassifierParameter::kInputSizeFieldNumber;
const int CaffeClassifierParameter::kModelVersionFieldNumber;
#endif  // !_MSC_VER

CaffeClassifierParameter::CaffeClassifierParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.CaffeClassifierParameter)
}

void CaffeClassifierParameter::InitAsDefaultInstance() {
}

CaffeClassifierParameter::CaffeClassifierParameter(const CaffeClassifierParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.CaffeClassifierParameter)
}

void CaffeClassifierParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  confience_score_ = 0.5f;
  input_size_ = 224u;
  model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CaffeClassifierParameter::~CaffeClassifierParameter() {
  // @@protoc_insertion_point(destructor:vas.CaffeClassifierParameter)
  SharedDtor();
}

void CaffeClassifierParameter::SharedDtor() {
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_version_;
  }
  if (this != default_instance_) {
  }
}

void CaffeClassifierParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CaffeClassifierParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CaffeClassifierParameter_descriptor_;
}

const CaffeClassifierParameter& CaffeClassifierParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

CaffeClassifierParameter* CaffeClassifierParameter::default_instance_ = NULL;

CaffeClassifierParameter* CaffeClassifierParameter::New() const {
  return new CaffeClassifierParameter;
}

void CaffeClassifierParameter::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    confience_score_ = 0.5f;
    input_size_ = 224u;
    if (has_model_version()) {
      if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        model_version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CaffeClassifierParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.CaffeClassifierParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float confience_score = 1 [default = 0.5];
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &confience_score_)));
          set_has_confience_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_input_size;
        break;
      }

      // optional uint32 input_size = 2 [default = 224];
      case 2: {
        if (tag == 16) {
         parse_input_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &input_size_)));
          set_has_input_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_model_version;
        break;
      }

      // optional string model_version = 3;
      case 3: {
        if (tag == 26) {
         parse_model_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_version().data(), this->model_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "model_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.CaffeClassifierParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.CaffeClassifierParameter)
  return false;
#undef DO_
}

void CaffeClassifierParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.CaffeClassifierParameter)
  // optional float confience_score = 1 [default = 0.5];
  if (has_confience_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->confience_score(), output);
  }

  // optional uint32 input_size = 2 [default = 224];
  if (has_input_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->input_size(), output);
  }

  // optional string model_version = 3;
  if (has_model_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_version().data(), this->model_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->model_version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.CaffeClassifierParameter)
}

::google::protobuf::uint8* CaffeClassifierParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.CaffeClassifierParameter)
  // optional float confience_score = 1 [default = 0.5];
  if (has_confience_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->confience_score(), target);
  }

  // optional uint32 input_size = 2 [default = 224];
  if (has_input_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->input_size(), target);
  }

  // optional string model_version = 3;
  if (has_model_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_version().data(), this->model_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->model_version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.CaffeClassifierParameter)
  return target;
}

int CaffeClassifierParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float confience_score = 1 [default = 0.5];
    if (has_confience_score()) {
      total_size += 1 + 4;
    }

    // optional uint32 input_size = 2 [default = 224];
    if (has_input_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->input_size());
    }

    // optional string model_version = 3;
    if (has_model_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model_version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CaffeClassifierParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CaffeClassifierParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CaffeClassifierParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CaffeClassifierParameter::MergeFrom(const CaffeClassifierParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_confience_score()) {
      set_confience_score(from.confience_score());
    }
    if (from.has_input_size()) {
      set_input_size(from.input_size());
    }
    if (from.has_model_version()) {
      set_model_version(from.model_version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CaffeClassifierParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CaffeClassifierParameter::CopyFrom(const CaffeClassifierParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaffeClassifierParameter::IsInitialized() const {

  return true;
}

void CaffeClassifierParameter::Swap(CaffeClassifierParameter* other) {
  if (other != this) {
    std::swap(confience_score_, other->confience_score_);
    std::swap(input_size_, other->input_size_);
    std::swap(model_version_, other->model_version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CaffeClassifierParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CaffeClassifierParameter_descriptor_;
  metadata.reflection = CaffeClassifierParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DetectParameter::kServiceIdFieldNumber;
const int DetectParameter::kRegTypeFieldNumber;
const int DetectParameter::kSmokeDetectSensitityFieldNumber;
const int DetectParameter::kFireDetectSensitityFieldNumber;
const int DetectParameter::kNumHistoryFieldNumber;
const int DetectParameter::kRegWidthFieldNumber;
const int DetectParameter::kRegHeightFieldNumber;
const int DetectParameter::kRegIntervalFieldNumber;
const int DetectParameter::kBgParameterFieldNumber;
const int DetectParameter::kFilterParameterFieldNumber;
const int DetectParameter::kCaffeParameterFieldNumber;
const int DetectParameter::kDetectStatusFieldNumber;
const int DetectParameter::kMergeForeRectsFieldNumber;
const int DetectParameter::kShowResultFrameFieldNumber;
const int DetectParameter::kShowBgFieldNumber;
const int DetectParameter::kShowRegFrameFieldNumber;
const int DetectParameter::kPrintRegCountFieldNumber;
const int DetectParameter::kShowSmokeHotFrameFieldNumber;
const int DetectParameter::kShowFireHotFrameFieldNumber;
const int DetectParameter::kSaveRegFrameFieldNumber;
const int DetectParameter::kSaveVideoFieldNumber;
const int DetectParameter::kMoveAreaForRegOnlyFieldNumber;
const int DetectParameter::kShowMoveAreaForRegOnlyFieldNumber;
#endif  // !_MSC_VER

DetectParameter::DetectParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.DetectParameter)
}

void DetectParameter::InitAsDefaultInstance() {
  bg_parameter_ = const_cast< ::vas::BgParameter*>(&::vas::BgParameter::default_instance());
  filter_parameter_ = const_cast< ::vas::FilterParameter*>(&::vas::FilterParameter::default_instance());
  caffe_parameter_ = const_cast< ::vas::CaffeClassifierParameter*>(&::vas::CaffeClassifierParameter::default_instance());
}

DetectParameter::DetectParameter(const DetectParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.DetectParameter)
}

void DetectParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  smoke_detect_sensitity_ = 0.2f;
  fire_detect_sensitity_ = 0.2f;
  num_history_ = 50u;
  reg_width_ = 800u;
  reg_height_ = 576u;
  reg_interval_ = 20u;
  bg_parameter_ = NULL;
  filter_parameter_ = NULL;
  caffe_parameter_ = NULL;
  detect_status_ = 1;
  merge_fore_rects_ = false;
  show_result_frame_ = false;
  show_bg_ = false;
  show_reg_frame_ = false;
  print_reg_count_ = false;
  show_smoke_hot_frame_ = false;
  show_fire_hot_frame_ = false;
  save_reg_frame_ = false;
  save_video_ = false;
  move_area_for_reg_only_ = false;
  show_move_area_for_reg_only_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DetectParameter::~DetectParameter() {
  // @@protoc_insertion_point(destructor:vas.DetectParameter)
  SharedDtor();
}

void DetectParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
    delete bg_parameter_;
    delete filter_parameter_;
    delete caffe_parameter_;
  }
}

void DetectParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DetectParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetectParameter_descriptor_;
}

const DetectParameter& DetectParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

DetectParameter* DetectParameter::default_instance_ = NULL;

DetectParameter* DetectParameter::New() const {
  return new DetectParameter;
}

void DetectParameter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DetectParameter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 253) {
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    smoke_detect_sensitity_ = 0.2f;
    fire_detect_sensitity_ = 0.2f;
    num_history_ = 50u;
    reg_width_ = 800u;
    reg_height_ = 576u;
    reg_interval_ = 20u;
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(merge_fore_rects_, show_reg_frame_);
    if (has_bg_parameter()) {
      if (bg_parameter_ != NULL) bg_parameter_->::vas::BgParameter::Clear();
    }
    if (has_filter_parameter()) {
      if (filter_parameter_ != NULL) filter_parameter_->::vas::FilterParameter::Clear();
    }
    if (has_caffe_parameter()) {
      if (caffe_parameter_ != NULL) caffe_parameter_->::vas::CaffeClassifierParameter::Clear();
    }
    detect_status_ = 1;
  }
  if (_has_bits_[16 / 32] & 8323072) {
    ZR_(print_reg_count_, show_move_area_for_reg_only_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  reg_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DetectParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.DetectParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reg_type;
        break;
      }

      // repeated string reg_type = 2;
      case 2: {
        if (tag == 18) {
         parse_reg_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_reg_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->reg_type(this->reg_type_size() - 1).data(),
            this->reg_type(this->reg_type_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "reg_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reg_type;
        if (input->ExpectTag(32)) goto parse_reg_width;
        break;
      }

      // optional uint32 reg_width = 4 [default = 800];
      case 4: {
        if (tag == 32) {
         parse_reg_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reg_width_)));
          set_has_reg_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reg_height;
        break;
      }

      // optional uint32 reg_height = 5 [default = 576];
      case 5: {
        if (tag == 40) {
         parse_reg_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reg_height_)));
          set_has_reg_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_reg_interval;
        break;
      }

      // optional uint32 reg_interval = 6 [default = 20];
      case 6: {
        if (tag == 48) {
         parse_reg_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reg_interval_)));
          set_has_reg_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_bg_parameter;
        break;
      }

      // optional .vas.BgParameter bg_parameter = 7;
      case 7: {
        if (tag == 58) {
         parse_bg_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bg_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_filter_parameter;
        break;
      }

      // optional .vas.FilterParameter filter_parameter = 8;
      case 8: {
        if (tag == 66) {
         parse_filter_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_filter_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_caffe_parameter;
        break;
      }

      // optional .vas.CaffeClassifierParameter caffe_parameter = 9;
      case 9: {
        if (tag == 74) {
         parse_caffe_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_caffe_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_detect_status;
        break;
      }

      // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
      case 10: {
        if (tag == 80) {
         parse_detect_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::DetectStatus_IsValid(value)) {
            set_detect_status(static_cast< ::vas::DetectStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_smoke_detect_sensitity;
        break;
      }

      // optional float smoke_detect_sensitity = 11 [default = 0.2];
      case 11: {
        if (tag == 93) {
         parse_smoke_detect_sensitity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &smoke_detect_sensitity_)));
          set_has_smoke_detect_sensitity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_num_history;
        break;
      }

      // optional uint32 num_history = 12 [default = 50];
      case 12: {
        if (tag == 96) {
         parse_num_history:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_history_)));
          set_has_num_history();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_show_result_frame;
        break;
      }

      // optional bool show_result_frame = 13 [default = false];
      case 13: {
        if (tag == 104) {
         parse_show_result_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_result_frame_)));
          set_has_show_result_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_print_reg_count;
        break;
      }

      // optional bool print_reg_count = 14 [default = false];
      case 14: {
        if (tag == 112) {
         parse_print_reg_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &print_reg_count_)));
          set_has_print_reg_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_show_bg;
        break;
      }

      // optional bool show_bg = 15 [default = false];
      case 15: {
        if (tag == 120) {
         parse_show_bg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_bg_)));
          set_has_show_bg();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_show_reg_frame;
        break;
      }

      // optional bool show_reg_frame = 16 [default = false];
      case 16: {
        if (tag == 128) {
         parse_show_reg_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_reg_frame_)));
          set_has_show_reg_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_show_smoke_hot_frame;
        break;
      }

      // optional bool show_smoke_hot_frame = 17 [default = false];
      case 17: {
        if (tag == 136) {
         parse_show_smoke_hot_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_smoke_hot_frame_)));
          set_has_show_smoke_hot_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_save_reg_frame;
        break;
      }

      // optional bool save_reg_frame = 18 [default = false];
      case 18: {
        if (tag == 144) {
         parse_save_reg_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &save_reg_frame_)));
          set_has_save_reg_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_save_video;
        break;
      }

      // optional bool save_video = 19 [default = false];
      case 19: {
        if (tag == 152) {
         parse_save_video:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &save_video_)));
          set_has_save_video();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_merge_fore_rects;
        break;
      }

      // optional bool merge_fore_rects = 20 [default = false];
      case 20: {
        if (tag == 160) {
         parse_merge_fore_rects:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &merge_fore_rects_)));
          set_has_merge_fore_rects();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_move_area_for_reg_only;
        break;
      }

      // optional bool move_area_for_reg_only = 21 [default = false];
      case 21: {
        if (tag == 168) {
         parse_move_area_for_reg_only:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &move_area_for_reg_only_)));
          set_has_move_area_for_reg_only();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_show_move_area_for_reg_only;
        break;
      }

      // optional bool show_move_area_for_reg_only = 22 [default = false];
      case 22: {
        if (tag == 176) {
         parse_show_move_area_for_reg_only:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_move_area_for_reg_only_)));
          set_has_show_move_area_for_reg_only();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_show_fire_hot_frame;
        break;
      }

      // optional bool show_fire_hot_frame = 23 [default = false];
      case 23: {
        if (tag == 184) {
         parse_show_fire_hot_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_fire_hot_frame_)));
          set_has_show_fire_hot_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(197)) goto parse_fire_detect_sensitity;
        break;
      }

      // optional float fire_detect_sensitity = 24 [default = 0.2];
      case 24: {
        if (tag == 197) {
         parse_fire_detect_sensitity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fire_detect_sensitity_)));
          set_has_fire_detect_sensitity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.DetectParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.DetectParameter)
  return false;
#undef DO_
}

void DetectParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.DetectParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // repeated string reg_type = 2;
  for (int i = 0; i < this->reg_type_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->reg_type(i).data(), this->reg_type(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "reg_type");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->reg_type(i), output);
  }

  // optional uint32 reg_width = 4 [default = 800];
  if (has_reg_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->reg_width(), output);
  }

  // optional uint32 reg_height = 5 [default = 576];
  if (has_reg_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->reg_height(), output);
  }

  // optional uint32 reg_interval = 6 [default = 20];
  if (has_reg_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->reg_interval(), output);
  }

  // optional .vas.BgParameter bg_parameter = 7;
  if (has_bg_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->bg_parameter(), output);
  }

  // optional .vas.FilterParameter filter_parameter = 8;
  if (has_filter_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->filter_parameter(), output);
  }

  // optional .vas.CaffeClassifierParameter caffe_parameter = 9;
  if (has_caffe_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->caffe_parameter(), output);
  }

  // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
  if (has_detect_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->detect_status(), output);
  }

  // optional float smoke_detect_sensitity = 11 [default = 0.2];
  if (has_smoke_detect_sensitity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->smoke_detect_sensitity(), output);
  }

  // optional uint32 num_history = 12 [default = 50];
  if (has_num_history()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->num_history(), output);
  }

  // optional bool show_result_frame = 13 [default = false];
  if (has_show_result_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->show_result_frame(), output);
  }

  // optional bool print_reg_count = 14 [default = false];
  if (has_print_reg_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->print_reg_count(), output);
  }

  // optional bool show_bg = 15 [default = false];
  if (has_show_bg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->show_bg(), output);
  }

  // optional bool show_reg_frame = 16 [default = false];
  if (has_show_reg_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->show_reg_frame(), output);
  }

  // optional bool show_smoke_hot_frame = 17 [default = false];
  if (has_show_smoke_hot_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->show_smoke_hot_frame(), output);
  }

  // optional bool save_reg_frame = 18 [default = false];
  if (has_save_reg_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->save_reg_frame(), output);
  }

  // optional bool save_video = 19 [default = false];
  if (has_save_video()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(19, this->save_video(), output);
  }

  // optional bool merge_fore_rects = 20 [default = false];
  if (has_merge_fore_rects()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(20, this->merge_fore_rects(), output);
  }

  // optional bool move_area_for_reg_only = 21 [default = false];
  if (has_move_area_for_reg_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(21, this->move_area_for_reg_only(), output);
  }

  // optional bool show_move_area_for_reg_only = 22 [default = false];
  if (has_show_move_area_for_reg_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(22, this->show_move_area_for_reg_only(), output);
  }

  // optional bool show_fire_hot_frame = 23 [default = false];
  if (has_show_fire_hot_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(23, this->show_fire_hot_frame(), output);
  }

  // optional float fire_detect_sensitity = 24 [default = 0.2];
  if (has_fire_detect_sensitity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(24, this->fire_detect_sensitity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.DetectParameter)
}

::google::protobuf::uint8* DetectParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.DetectParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // repeated string reg_type = 2;
  for (int i = 0; i < this->reg_type_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->reg_type(i).data(), this->reg_type(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "reg_type");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->reg_type(i), target);
  }

  // optional uint32 reg_width = 4 [default = 800];
  if (has_reg_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->reg_width(), target);
  }

  // optional uint32 reg_height = 5 [default = 576];
  if (has_reg_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->reg_height(), target);
  }

  // optional uint32 reg_interval = 6 [default = 20];
  if (has_reg_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->reg_interval(), target);
  }

  // optional .vas.BgParameter bg_parameter = 7;
  if (has_bg_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->bg_parameter(), target);
  }

  // optional .vas.FilterParameter filter_parameter = 8;
  if (has_filter_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->filter_parameter(), target);
  }

  // optional .vas.CaffeClassifierParameter caffe_parameter = 9;
  if (has_caffe_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->caffe_parameter(), target);
  }

  // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
  if (has_detect_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->detect_status(), target);
  }

  // optional float smoke_detect_sensitity = 11 [default = 0.2];
  if (has_smoke_detect_sensitity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->smoke_detect_sensitity(), target);
  }

  // optional uint32 num_history = 12 [default = 50];
  if (has_num_history()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->num_history(), target);
  }

  // optional bool show_result_frame = 13 [default = false];
  if (has_show_result_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->show_result_frame(), target);
  }

  // optional bool print_reg_count = 14 [default = false];
  if (has_print_reg_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->print_reg_count(), target);
  }

  // optional bool show_bg = 15 [default = false];
  if (has_show_bg()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->show_bg(), target);
  }

  // optional bool show_reg_frame = 16 [default = false];
  if (has_show_reg_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->show_reg_frame(), target);
  }

  // optional bool show_smoke_hot_frame = 17 [default = false];
  if (has_show_smoke_hot_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->show_smoke_hot_frame(), target);
  }

  // optional bool save_reg_frame = 18 [default = false];
  if (has_save_reg_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->save_reg_frame(), target);
  }

  // optional bool save_video = 19 [default = false];
  if (has_save_video()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(19, this->save_video(), target);
  }

  // optional bool merge_fore_rects = 20 [default = false];
  if (has_merge_fore_rects()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(20, this->merge_fore_rects(), target);
  }

  // optional bool move_area_for_reg_only = 21 [default = false];
  if (has_move_area_for_reg_only()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(21, this->move_area_for_reg_only(), target);
  }

  // optional bool show_move_area_for_reg_only = 22 [default = false];
  if (has_show_move_area_for_reg_only()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(22, this->show_move_area_for_reg_only(), target);
  }

  // optional bool show_fire_hot_frame = 23 [default = false];
  if (has_show_fire_hot_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(23, this->show_fire_hot_frame(), target);
  }

  // optional float fire_detect_sensitity = 24 [default = 0.2];
  if (has_fire_detect_sensitity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(24, this->fire_detect_sensitity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.DetectParameter)
  return target;
}

int DetectParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional float smoke_detect_sensitity = 11 [default = 0.2];
    if (has_smoke_detect_sensitity()) {
      total_size += 1 + 4;
    }

    // optional float fire_detect_sensitity = 24 [default = 0.2];
    if (has_fire_detect_sensitity()) {
      total_size += 2 + 4;
    }

    // optional uint32 num_history = 12 [default = 50];
    if (has_num_history()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_history());
    }

    // optional uint32 reg_width = 4 [default = 800];
    if (has_reg_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reg_width());
    }

    // optional uint32 reg_height = 5 [default = 576];
    if (has_reg_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reg_height());
    }

    // optional uint32 reg_interval = 6 [default = 20];
    if (has_reg_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reg_interval());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .vas.BgParameter bg_parameter = 7;
    if (has_bg_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bg_parameter());
    }

    // optional .vas.FilterParameter filter_parameter = 8;
    if (has_filter_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->filter_parameter());
    }

    // optional .vas.CaffeClassifierParameter caffe_parameter = 9;
    if (has_caffe_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->caffe_parameter());
    }

    // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
    if (has_detect_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->detect_status());
    }

    // optional bool merge_fore_rects = 20 [default = false];
    if (has_merge_fore_rects()) {
      total_size += 2 + 1;
    }

    // optional bool show_result_frame = 13 [default = false];
    if (has_show_result_frame()) {
      total_size += 1 + 1;
    }

    // optional bool show_bg = 15 [default = false];
    if (has_show_bg()) {
      total_size += 1 + 1;
    }

    // optional bool show_reg_frame = 16 [default = false];
    if (has_show_reg_frame()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bool print_reg_count = 14 [default = false];
    if (has_print_reg_count()) {
      total_size += 1 + 1;
    }

    // optional bool show_smoke_hot_frame = 17 [default = false];
    if (has_show_smoke_hot_frame()) {
      total_size += 2 + 1;
    }

    // optional bool show_fire_hot_frame = 23 [default = false];
    if (has_show_fire_hot_frame()) {
      total_size += 2 + 1;
    }

    // optional bool save_reg_frame = 18 [default = false];
    if (has_save_reg_frame()) {
      total_size += 2 + 1;
    }

    // optional bool save_video = 19 [default = false];
    if (has_save_video()) {
      total_size += 2 + 1;
    }

    // optional bool move_area_for_reg_only = 21 [default = false];
    if (has_move_area_for_reg_only()) {
      total_size += 2 + 1;
    }

    // optional bool show_move_area_for_reg_only = 22 [default = false];
    if (has_show_move_area_for_reg_only()) {
      total_size += 2 + 1;
    }

  }
  // repeated string reg_type = 2;
  total_size += 1 * this->reg_type_size();
  for (int i = 0; i < this->reg_type_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->reg_type(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DetectParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DetectParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DetectParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DetectParameter::MergeFrom(const DetectParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  reg_type_.MergeFrom(from.reg_type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_smoke_detect_sensitity()) {
      set_smoke_detect_sensitity(from.smoke_detect_sensitity());
    }
    if (from.has_fire_detect_sensitity()) {
      set_fire_detect_sensitity(from.fire_detect_sensitity());
    }
    if (from.has_num_history()) {
      set_num_history(from.num_history());
    }
    if (from.has_reg_width()) {
      set_reg_width(from.reg_width());
    }
    if (from.has_reg_height()) {
      set_reg_height(from.reg_height());
    }
    if (from.has_reg_interval()) {
      set_reg_interval(from.reg_interval());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_bg_parameter()) {
      mutable_bg_parameter()->::vas::BgParameter::MergeFrom(from.bg_parameter());
    }
    if (from.has_filter_parameter()) {
      mutable_filter_parameter()->::vas::FilterParameter::MergeFrom(from.filter_parameter());
    }
    if (from.has_caffe_parameter()) {
      mutable_caffe_parameter()->::vas::CaffeClassifierParameter::MergeFrom(from.caffe_parameter());
    }
    if (from.has_detect_status()) {
      set_detect_status(from.detect_status());
    }
    if (from.has_merge_fore_rects()) {
      set_merge_fore_rects(from.merge_fore_rects());
    }
    if (from.has_show_result_frame()) {
      set_show_result_frame(from.show_result_frame());
    }
    if (from.has_show_bg()) {
      set_show_bg(from.show_bg());
    }
    if (from.has_show_reg_frame()) {
      set_show_reg_frame(from.show_reg_frame());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_print_reg_count()) {
      set_print_reg_count(from.print_reg_count());
    }
    if (from.has_show_smoke_hot_frame()) {
      set_show_smoke_hot_frame(from.show_smoke_hot_frame());
    }
    if (from.has_show_fire_hot_frame()) {
      set_show_fire_hot_frame(from.show_fire_hot_frame());
    }
    if (from.has_save_reg_frame()) {
      set_save_reg_frame(from.save_reg_frame());
    }
    if (from.has_save_video()) {
      set_save_video(from.save_video());
    }
    if (from.has_move_area_for_reg_only()) {
      set_move_area_for_reg_only(from.move_area_for_reg_only());
    }
    if (from.has_show_move_area_for_reg_only()) {
      set_show_move_area_for_reg_only(from.show_move_area_for_reg_only());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DetectParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DetectParameter::CopyFrom(const DetectParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectParameter::IsInitialized() const {

  return true;
}

void DetectParameter::Swap(DetectParameter* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    reg_type_.Swap(&other->reg_type_);
    std::swap(smoke_detect_sensitity_, other->smoke_detect_sensitity_);
    std::swap(fire_detect_sensitity_, other->fire_detect_sensitity_);
    std::swap(num_history_, other->num_history_);
    std::swap(reg_width_, other->reg_width_);
    std::swap(reg_height_, other->reg_height_);
    std::swap(reg_interval_, other->reg_interval_);
    std::swap(bg_parameter_, other->bg_parameter_);
    std::swap(filter_parameter_, other->filter_parameter_);
    std::swap(caffe_parameter_, other->caffe_parameter_);
    std::swap(detect_status_, other->detect_status_);
    std::swap(merge_fore_rects_, other->merge_fore_rects_);
    std::swap(show_result_frame_, other->show_result_frame_);
    std::swap(show_bg_, other->show_bg_);
    std::swap(show_reg_frame_, other->show_reg_frame_);
    std::swap(print_reg_count_, other->print_reg_count_);
    std::swap(show_smoke_hot_frame_, other->show_smoke_hot_frame_);
    std::swap(show_fire_hot_frame_, other->show_fire_hot_frame_);
    std::swap(save_reg_frame_, other->save_reg_frame_);
    std::swap(save_video_, other->save_video_);
    std::swap(move_area_for_reg_only_, other->move_area_for_reg_only_);
    std::swap(show_move_area_for_reg_only_, other->show_move_area_for_reg_only_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DetectParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DetectParameter_descriptor_;
  metadata.reflection = DetectParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SsdDetecterParameter::kServiceIdFieldNumber;
const int SsdDetecterParameter::kRegTypeFieldNumber;
const int SsdDetecterParameter::kRegWidthFieldNumber;
const int SsdDetecterParameter::kRegHeightFieldNumber;
const int SsdDetecterParameter::kDetectStatusFieldNumber;
const int SsdDetecterParameter::kShowResultFrameFieldNumber;
const int SsdDetecterParameter::kShowRegFrameFieldNumber;
const int SsdDetecterParameter::kSaveVideoFieldNumber;
const int SsdDetecterParameter::kSaveRegFrameFieldNumber;
const int SsdDetecterParameter::kRegIntervalFieldNumber;
const int SsdDetecterParameter::kConfidenceThresholdFieldNumber;
#endif  // !_MSC_VER

SsdDetecterParameter::SsdDetecterParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.SsdDetecterParameter)
}

void SsdDetecterParameter::InitAsDefaultInstance() {
}

SsdDetecterParameter::SsdDetecterParameter(const SsdDetecterParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.SsdDetecterParameter)
}

void SsdDetecterParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  reg_width_ = 800u;
  reg_height_ = 576u;
  detect_status_ = 1;
  show_result_frame_ = false;
  show_reg_frame_ = false;
  save_video_ = false;
  save_reg_frame_ = false;
  reg_interval_ = 20u;
  confidence_threshold_ = 0.5f;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SsdDetecterParameter::~SsdDetecterParameter() {
  // @@protoc_insertion_point(destructor:vas.SsdDetecterParameter)
  SharedDtor();
}

void SsdDetecterParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
  }
}

void SsdDetecterParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SsdDetecterParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SsdDetecterParameter_descriptor_;
}

const SsdDetecterParameter& SsdDetecterParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

SsdDetecterParameter* SsdDetecterParameter::default_instance_ = NULL;

SsdDetecterParameter* SsdDetecterParameter::New() const {
  return new SsdDetecterParameter;
}

void SsdDetecterParameter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SsdDetecterParameter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 253) {
    ZR_(show_result_frame_, save_video_);
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    reg_width_ = 800u;
    reg_height_ = 576u;
    detect_status_ = 1;
  }
  if (_has_bits_[8 / 32] & 1792) {
    save_reg_frame_ = false;
    reg_interval_ = 20u;
    confidence_threshold_ = 0.5f;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  reg_type_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SsdDetecterParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.SsdDetecterParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reg_type;
        break;
      }

      // repeated string reg_type = 2;
      case 2: {
        if (tag == 18) {
         parse_reg_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_reg_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->reg_type(this->reg_type_size() - 1).data(),
            this->reg_type(this->reg_type_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "reg_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reg_type;
        if (input->ExpectTag(32)) goto parse_reg_width;
        break;
      }

      // optional uint32 reg_width = 4 [default = 800];
      case 4: {
        if (tag == 32) {
         parse_reg_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reg_width_)));
          set_has_reg_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reg_height;
        break;
      }

      // optional uint32 reg_height = 5 [default = 576];
      case 5: {
        if (tag == 40) {
         parse_reg_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reg_height_)));
          set_has_reg_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_reg_interval;
        break;
      }

      // optional uint32 reg_interval = 6 [default = 20];
      case 6: {
        if (tag == 48) {
         parse_reg_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reg_interval_)));
          set_has_reg_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_detect_status;
        break;
      }

      // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
      case 10: {
        if (tag == 80) {
         parse_detect_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::DetectStatus_IsValid(value)) {
            set_detect_status(static_cast< ::vas::DetectStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_show_result_frame;
        break;
      }

      // optional bool show_result_frame = 13 [default = false];
      case 13: {
        if (tag == 104) {
         parse_show_result_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_result_frame_)));
          set_has_show_result_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_show_reg_frame;
        break;
      }

      // optional bool show_reg_frame = 16 [default = false];
      case 16: {
        if (tag == 128) {
         parse_show_reg_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_reg_frame_)));
          set_has_show_reg_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_save_reg_frame;
        break;
      }

      // optional bool save_reg_frame = 18 [default = false];
      case 18: {
        if (tag == 144) {
         parse_save_reg_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &save_reg_frame_)));
          set_has_save_reg_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_save_video;
        break;
      }

      // optional bool save_video = 19 [default = false];
      case 19: {
        if (tag == 152) {
         parse_save_video:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &save_video_)));
          set_has_save_video();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(173)) goto parse_confidence_threshold;
        break;
      }

      // optional float confidence_threshold = 21 [default = 0.5];
      case 21: {
        if (tag == 173) {
         parse_confidence_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &confidence_threshold_)));
          set_has_confidence_threshold();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.SsdDetecterParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.SsdDetecterParameter)
  return false;
#undef DO_
}

void SsdDetecterParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.SsdDetecterParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // repeated string reg_type = 2;
  for (int i = 0; i < this->reg_type_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->reg_type(i).data(), this->reg_type(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "reg_type");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->reg_type(i), output);
  }

  // optional uint32 reg_width = 4 [default = 800];
  if (has_reg_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->reg_width(), output);
  }

  // optional uint32 reg_height = 5 [default = 576];
  if (has_reg_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->reg_height(), output);
  }

  // optional uint32 reg_interval = 6 [default = 20];
  if (has_reg_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->reg_interval(), output);
  }

  // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
  if (has_detect_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->detect_status(), output);
  }

  // optional bool show_result_frame = 13 [default = false];
  if (has_show_result_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->show_result_frame(), output);
  }

  // optional bool show_reg_frame = 16 [default = false];
  if (has_show_reg_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->show_reg_frame(), output);
  }

  // optional bool save_reg_frame = 18 [default = false];
  if (has_save_reg_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->save_reg_frame(), output);
  }

  // optional bool save_video = 19 [default = false];
  if (has_save_video()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(19, this->save_video(), output);
  }

  // optional float confidence_threshold = 21 [default = 0.5];
  if (has_confidence_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(21, this->confidence_threshold(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.SsdDetecterParameter)
}

::google::protobuf::uint8* SsdDetecterParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.SsdDetecterParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // repeated string reg_type = 2;
  for (int i = 0; i < this->reg_type_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->reg_type(i).data(), this->reg_type(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "reg_type");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->reg_type(i), target);
  }

  // optional uint32 reg_width = 4 [default = 800];
  if (has_reg_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->reg_width(), target);
  }

  // optional uint32 reg_height = 5 [default = 576];
  if (has_reg_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->reg_height(), target);
  }

  // optional uint32 reg_interval = 6 [default = 20];
  if (has_reg_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->reg_interval(), target);
  }

  // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
  if (has_detect_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->detect_status(), target);
  }

  // optional bool show_result_frame = 13 [default = false];
  if (has_show_result_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->show_result_frame(), target);
  }

  // optional bool show_reg_frame = 16 [default = false];
  if (has_show_reg_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->show_reg_frame(), target);
  }

  // optional bool save_reg_frame = 18 [default = false];
  if (has_save_reg_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->save_reg_frame(), target);
  }

  // optional bool save_video = 19 [default = false];
  if (has_save_video()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(19, this->save_video(), target);
  }

  // optional float confidence_threshold = 21 [default = 0.5];
  if (has_confidence_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(21, this->confidence_threshold(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.SsdDetecterParameter)
  return target;
}

int SsdDetecterParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional uint32 reg_width = 4 [default = 800];
    if (has_reg_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reg_width());
    }

    // optional uint32 reg_height = 5 [default = 576];
    if (has_reg_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reg_height());
    }

    // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
    if (has_detect_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->detect_status());
    }

    // optional bool show_result_frame = 13 [default = false];
    if (has_show_result_frame()) {
      total_size += 1 + 1;
    }

    // optional bool show_reg_frame = 16 [default = false];
    if (has_show_reg_frame()) {
      total_size += 2 + 1;
    }

    // optional bool save_video = 19 [default = false];
    if (has_save_video()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool save_reg_frame = 18 [default = false];
    if (has_save_reg_frame()) {
      total_size += 2 + 1;
    }

    // optional uint32 reg_interval = 6 [default = 20];
    if (has_reg_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->reg_interval());
    }

    // optional float confidence_threshold = 21 [default = 0.5];
    if (has_confidence_threshold()) {
      total_size += 2 + 4;
    }

  }
  // repeated string reg_type = 2;
  total_size += 1 * this->reg_type_size();
  for (int i = 0; i < this->reg_type_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->reg_type(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SsdDetecterParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SsdDetecterParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SsdDetecterParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SsdDetecterParameter::MergeFrom(const SsdDetecterParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  reg_type_.MergeFrom(from.reg_type_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_reg_width()) {
      set_reg_width(from.reg_width());
    }
    if (from.has_reg_height()) {
      set_reg_height(from.reg_height());
    }
    if (from.has_detect_status()) {
      set_detect_status(from.detect_status());
    }
    if (from.has_show_result_frame()) {
      set_show_result_frame(from.show_result_frame());
    }
    if (from.has_show_reg_frame()) {
      set_show_reg_frame(from.show_reg_frame());
    }
    if (from.has_save_video()) {
      set_save_video(from.save_video());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_save_reg_frame()) {
      set_save_reg_frame(from.save_reg_frame());
    }
    if (from.has_reg_interval()) {
      set_reg_interval(from.reg_interval());
    }
    if (from.has_confidence_threshold()) {
      set_confidence_threshold(from.confidence_threshold());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SsdDetecterParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SsdDetecterParameter::CopyFrom(const SsdDetecterParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SsdDetecterParameter::IsInitialized() const {

  return true;
}

void SsdDetecterParameter::Swap(SsdDetecterParameter* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    reg_type_.Swap(&other->reg_type_);
    std::swap(reg_width_, other->reg_width_);
    std::swap(reg_height_, other->reg_height_);
    std::swap(detect_status_, other->detect_status_);
    std::swap(show_result_frame_, other->show_result_frame_);
    std::swap(show_reg_frame_, other->show_reg_frame_);
    std::swap(save_video_, other->save_video_);
    std::swap(save_reg_frame_, other->save_reg_frame_);
    std::swap(reg_interval_, other->reg_interval_);
    std::swap(confidence_threshold_, other->confidence_threshold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SsdDetecterParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SsdDetecterParameter_descriptor_;
  metadata.reflection = SsdDetecterParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CaffeModelPath::kDeployFilePathFieldNumber;
const int CaffeModelPath::kTrainedModelPathFieldNumber;
const int CaffeModelPath::kLabelFilePathFieldNumber;
const int CaffeModelPath::kMeanFilePathFieldNumber;
const int CaffeModelPath::kInputSizeFieldNumber;
const int CaffeModelPath::kModelVersionFieldNumber;
const int CaffeModelPath::kUseGpuFieldNumber;
#endif  // !_MSC_VER

CaffeModelPath::CaffeModelPath()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.CaffeModelPath)
}

void CaffeModelPath::InitAsDefaultInstance() {
}

CaffeModelPath::CaffeModelPath(const CaffeModelPath& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.CaffeModelPath)
}

void CaffeModelPath::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  deploy_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trained_model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  label_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mean_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  input_size_ = 224u;
  model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  use_gpu_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CaffeModelPath::~CaffeModelPath() {
  // @@protoc_insertion_point(destructor:vas.CaffeModelPath)
  SharedDtor();
}

void CaffeModelPath::SharedDtor() {
  if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deploy_file_path_;
  }
  if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trained_model_path_;
  }
  if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_file_path_;
  }
  if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mean_file_path_;
  }
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_version_;
  }
  if (this != default_instance_) {
  }
}

void CaffeModelPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CaffeModelPath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CaffeModelPath_descriptor_;
}

const CaffeModelPath& CaffeModelPath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

CaffeModelPath* CaffeModelPath::default_instance_ = NULL;

CaffeModelPath* CaffeModelPath::New() const {
  return new CaffeModelPath;
}

void CaffeModelPath::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    if (has_deploy_file_path()) {
      if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        deploy_file_path_->clear();
      }
    }
    if (has_trained_model_path()) {
      if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        trained_model_path_->clear();
      }
    }
    if (has_label_file_path()) {
      if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        label_file_path_->clear();
      }
    }
    if (has_mean_file_path()) {
      if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        mean_file_path_->clear();
      }
    }
    input_size_ = 224u;
    if (has_model_version()) {
      if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        model_version_->clear();
      }
    }
    use_gpu_ = true;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CaffeModelPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.CaffeModelPath)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string deploy_file_path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deploy_file_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->deploy_file_path().data(), this->deploy_file_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "deploy_file_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_trained_model_path;
        break;
      }

      // optional string trained_model_path = 2;
      case 2: {
        if (tag == 18) {
         parse_trained_model_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trained_model_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->trained_model_path().data(), this->trained_model_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "trained_model_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_label_file_path;
        break;
      }

      // optional string label_file_path = 3;
      case 3: {
        if (tag == 26) {
         parse_label_file_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label_file_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label_file_path().data(), this->label_file_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "label_file_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_mean_file_path;
        break;
      }

      // optional string mean_file_path = 4;
      case 4: {
        if (tag == 34) {
         parse_mean_file_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mean_file_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mean_file_path().data(), this->mean_file_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mean_file_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_input_size;
        break;
      }

      // optional uint32 input_size = 5 [default = 224];
      case 5: {
        if (tag == 40) {
         parse_input_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &input_size_)));
          set_has_input_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_model_version;
        break;
      }

      // optional string model_version = 6;
      case 6: {
        if (tag == 50) {
         parse_model_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_version().data(), this->model_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "model_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_use_gpu;
        break;
      }

      // optional bool use_gpu = 7 [default = true];
      case 7: {
        if (tag == 56) {
         parse_use_gpu:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_gpu_)));
          set_has_use_gpu();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.CaffeModelPath)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.CaffeModelPath)
  return false;
#undef DO_
}

void CaffeModelPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.CaffeModelPath)
  // optional string deploy_file_path = 1;
  if (has_deploy_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->deploy_file_path().data(), this->deploy_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "deploy_file_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->deploy_file_path(), output);
  }

  // optional string trained_model_path = 2;
  if (has_trained_model_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->trained_model_path().data(), this->trained_model_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "trained_model_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->trained_model_path(), output);
  }

  // optional string label_file_path = 3;
  if (has_label_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label_file_path().data(), this->label_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "label_file_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->label_file_path(), output);
  }

  // optional string mean_file_path = 4;
  if (has_mean_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mean_file_path().data(), this->mean_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mean_file_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->mean_file_path(), output);
  }

  // optional uint32 input_size = 5 [default = 224];
  if (has_input_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->input_size(), output);
  }

  // optional string model_version = 6;
  if (has_model_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_version().data(), this->model_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->model_version(), output);
  }

  // optional bool use_gpu = 7 [default = true];
  if (has_use_gpu()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->use_gpu(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.CaffeModelPath)
}

::google::protobuf::uint8* CaffeModelPath::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.CaffeModelPath)
  // optional string deploy_file_path = 1;
  if (has_deploy_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->deploy_file_path().data(), this->deploy_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "deploy_file_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->deploy_file_path(), target);
  }

  // optional string trained_model_path = 2;
  if (has_trained_model_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->trained_model_path().data(), this->trained_model_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "trained_model_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->trained_model_path(), target);
  }

  // optional string label_file_path = 3;
  if (has_label_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label_file_path().data(), this->label_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "label_file_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->label_file_path(), target);
  }

  // optional string mean_file_path = 4;
  if (has_mean_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mean_file_path().data(), this->mean_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mean_file_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->mean_file_path(), target);
  }

  // optional uint32 input_size = 5 [default = 224];
  if (has_input_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->input_size(), target);
  }

  // optional string model_version = 6;
  if (has_model_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_version().data(), this->model_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->model_version(), target);
  }

  // optional bool use_gpu = 7 [default = true];
  if (has_use_gpu()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->use_gpu(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.CaffeModelPath)
  return target;
}

int CaffeModelPath::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string deploy_file_path = 1;
    if (has_deploy_file_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deploy_file_path());
    }

    // optional string trained_model_path = 2;
    if (has_trained_model_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trained_model_path());
    }

    // optional string label_file_path = 3;
    if (has_label_file_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label_file_path());
    }

    // optional string mean_file_path = 4;
    if (has_mean_file_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mean_file_path());
    }

    // optional uint32 input_size = 5 [default = 224];
    if (has_input_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->input_size());
    }

    // optional string model_version = 6;
    if (has_model_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model_version());
    }

    // optional bool use_gpu = 7 [default = true];
    if (has_use_gpu()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CaffeModelPath::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CaffeModelPath* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CaffeModelPath*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CaffeModelPath::MergeFrom(const CaffeModelPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_deploy_file_path()) {
      set_deploy_file_path(from.deploy_file_path());
    }
    if (from.has_trained_model_path()) {
      set_trained_model_path(from.trained_model_path());
    }
    if (from.has_label_file_path()) {
      set_label_file_path(from.label_file_path());
    }
    if (from.has_mean_file_path()) {
      set_mean_file_path(from.mean_file_path());
    }
    if (from.has_input_size()) {
      set_input_size(from.input_size());
    }
    if (from.has_model_version()) {
      set_model_version(from.model_version());
    }
    if (from.has_use_gpu()) {
      set_use_gpu(from.use_gpu());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CaffeModelPath::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CaffeModelPath::CopyFrom(const CaffeModelPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaffeModelPath::IsInitialized() const {

  return true;
}

void CaffeModelPath::Swap(CaffeModelPath* other) {
  if (other != this) {
    std::swap(deploy_file_path_, other->deploy_file_path_);
    std::swap(trained_model_path_, other->trained_model_path_);
    std::swap(label_file_path_, other->label_file_path_);
    std::swap(mean_file_path_, other->mean_file_path_);
    std::swap(input_size_, other->input_size_);
    std::swap(model_version_, other->model_version_);
    std::swap(use_gpu_, other->use_gpu_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CaffeModelPath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CaffeModelPath_descriptor_;
  metadata.reflection = CaffeModelPath_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SsdModelPath::kDeployFilePathFieldNumber;
const int SsdModelPath::kTrainedModelPathFieldNumber;
const int SsdModelPath::kLabelFilePathFieldNumber;
const int SsdModelPath::kMeanFilePathFieldNumber;
const int SsdModelPath::kMeanValueFieldNumber;
const int SsdModelPath::kModelVersionFieldNumber;
const int SsdModelPath::kUseGpuFieldNumber;
#endif  // !_MSC_VER

SsdModelPath::SsdModelPath()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.SsdModelPath)
}

void SsdModelPath::InitAsDefaultInstance() {
}

SsdModelPath::SsdModelPath(const SsdModelPath& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.SsdModelPath)
}

void SsdModelPath::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  deploy_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trained_model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  label_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mean_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mean_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  use_gpu_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SsdModelPath::~SsdModelPath() {
  // @@protoc_insertion_point(destructor:vas.SsdModelPath)
  SharedDtor();
}

void SsdModelPath::SharedDtor() {
  if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deploy_file_path_;
  }
  if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trained_model_path_;
  }
  if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_file_path_;
  }
  if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mean_file_path_;
  }
  if (mean_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mean_value_;
  }
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_version_;
  }
  if (this != default_instance_) {
  }
}

void SsdModelPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SsdModelPath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SsdModelPath_descriptor_;
}

const SsdModelPath& SsdModelPath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

SsdModelPath* SsdModelPath::default_instance_ = NULL;

SsdModelPath* SsdModelPath::New() const {
  return new SsdModelPath;
}

void SsdModelPath::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    if (has_deploy_file_path()) {
      if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        deploy_file_path_->clear();
      }
    }
    if (has_trained_model_path()) {
      if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        trained_model_path_->clear();
      }
    }
    if (has_label_file_path()) {
      if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        label_file_path_->clear();
      }
    }
    if (has_mean_file_path()) {
      if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        mean_file_path_->clear();
      }
    }
    if (has_mean_value()) {
      if (mean_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        mean_value_->clear();
      }
    }
    if (has_model_version()) {
      if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        model_version_->clear();
      }
    }
    use_gpu_ = true;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SsdModelPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.SsdModelPath)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string deploy_file_path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deploy_file_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->deploy_file_path().data(), this->deploy_file_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "deploy_file_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_trained_model_path;
        break;
      }

      // optional string trained_model_path = 2;
      case 2: {
        if (tag == 18) {
         parse_trained_model_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trained_model_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->trained_model_path().data(), this->trained_model_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "trained_model_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_label_file_path;
        break;
      }

      // optional string label_file_path = 3;
      case 3: {
        if (tag == 26) {
         parse_label_file_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label_file_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label_file_path().data(), this->label_file_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "label_file_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_mean_file_path;
        break;
      }

      // optional string mean_file_path = 4;
      case 4: {
        if (tag == 34) {
         parse_mean_file_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mean_file_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mean_file_path().data(), this->mean_file_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mean_file_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mean_value;
        break;
      }

      // optional string mean_value = 5;
      case 5: {
        if (tag == 42) {
         parse_mean_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mean_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mean_value().data(), this->mean_value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mean_value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_model_version;
        break;
      }

      // optional string model_version = 6;
      case 6: {
        if (tag == 50) {
         parse_model_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model_version().data(), this->model_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "model_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_use_gpu;
        break;
      }

      // optional bool use_gpu = 7 [default = true];
      case 7: {
        if (tag == 56) {
         parse_use_gpu:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_gpu_)));
          set_has_use_gpu();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.SsdModelPath)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.SsdModelPath)
  return false;
#undef DO_
}

void SsdModelPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.SsdModelPath)
  // optional string deploy_file_path = 1;
  if (has_deploy_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->deploy_file_path().data(), this->deploy_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "deploy_file_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->deploy_file_path(), output);
  }

  // optional string trained_model_path = 2;
  if (has_trained_model_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->trained_model_path().data(), this->trained_model_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "trained_model_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->trained_model_path(), output);
  }

  // optional string label_file_path = 3;
  if (has_label_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label_file_path().data(), this->label_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "label_file_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->label_file_path(), output);
  }

  // optional string mean_file_path = 4;
  if (has_mean_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mean_file_path().data(), this->mean_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mean_file_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->mean_file_path(), output);
  }

  // optional string mean_value = 5;
  if (has_mean_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mean_value().data(), this->mean_value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mean_value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->mean_value(), output);
  }

  // optional string model_version = 6;
  if (has_model_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_version().data(), this->model_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->model_version(), output);
  }

  // optional bool use_gpu = 7 [default = true];
  if (has_use_gpu()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->use_gpu(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.SsdModelPath)
}

::google::protobuf::uint8* SsdModelPath::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.SsdModelPath)
  // optional string deploy_file_path = 1;
  if (has_deploy_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->deploy_file_path().data(), this->deploy_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "deploy_file_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->deploy_file_path(), target);
  }

  // optional string trained_model_path = 2;
  if (has_trained_model_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->trained_model_path().data(), this->trained_model_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "trained_model_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->trained_model_path(), target);
  }

  // optional string label_file_path = 3;
  if (has_label_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label_file_path().data(), this->label_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "label_file_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->label_file_path(), target);
  }

  // optional string mean_file_path = 4;
  if (has_mean_file_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mean_file_path().data(), this->mean_file_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mean_file_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->mean_file_path(), target);
  }

  // optional string mean_value = 5;
  if (has_mean_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mean_value().data(), this->mean_value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mean_value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->mean_value(), target);
  }

  // optional string model_version = 6;
  if (has_model_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model_version().data(), this->model_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->model_version(), target);
  }

  // optional bool use_gpu = 7 [default = true];
  if (has_use_gpu()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->use_gpu(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.SsdModelPath)
  return target;
}

int SsdModelPath::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string deploy_file_path = 1;
    if (has_deploy_file_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deploy_file_path());
    }

    // optional string trained_model_path = 2;
    if (has_trained_model_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trained_model_path());
    }

    // optional string label_file_path = 3;
    if (has_label_file_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label_file_path());
    }

    // optional string mean_file_path = 4;
    if (has_mean_file_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mean_file_path());
    }

    // optional string mean_value = 5;
    if (has_mean_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mean_value());
    }

    // optional string model_version = 6;
    if (has_model_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model_version());
    }

    // optional bool use_gpu = 7 [default = true];
    if (has_use_gpu()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SsdModelPath::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SsdModelPath* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SsdModelPath*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SsdModelPath::MergeFrom(const SsdModelPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_deploy_file_path()) {
      set_deploy_file_path(from.deploy_file_path());
    }
    if (from.has_trained_model_path()) {
      set_trained_model_path(from.trained_model_path());
    }
    if (from.has_label_file_path()) {
      set_label_file_path(from.label_file_path());
    }
    if (from.has_mean_file_path()) {
      set_mean_file_path(from.mean_file_path());
    }
    if (from.has_mean_value()) {
      set_mean_value(from.mean_value());
    }
    if (from.has_model_version()) {
      set_model_version(from.model_version());
    }
    if (from.has_use_gpu()) {
      set_use_gpu(from.use_gpu());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SsdModelPath::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SsdModelPath::CopyFrom(const SsdModelPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SsdModelPath::IsInitialized() const {

  return true;
}

void SsdModelPath::Swap(SsdModelPath* other) {
  if (other != this) {
    std::swap(deploy_file_path_, other->deploy_file_path_);
    std::swap(trained_model_path_, other->trained_model_path_);
    std::swap(label_file_path_, other->label_file_path_);
    std::swap(mean_file_path_, other->mean_file_path_);
    std::swap(mean_value_, other->mean_value_);
    std::swap(model_version_, other->model_version_);
    std::swap(use_gpu_, other->use_gpu_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SsdModelPath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SsdModelPath_descriptor_;
  metadata.reflection = SsdModelPath_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceParameter::kServiceIdFieldNumber;
const int ServiceParameter::kDecodeParameterFieldNumber;
const int ServiceParameter::kDetectParameterFieldNumber;
const int ServiceParameter::kServiceStatusFieldNumber;
const int ServiceParameter::kRegMsgSubscribeFieldNumber;
#endif  // !_MSC_VER

ServiceParameter::ServiceParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.ServiceParameter)
}

void ServiceParameter::InitAsDefaultInstance() {
  decode_parameter_ = const_cast< ::vas::DecodeParameter*>(&::vas::DecodeParameter::default_instance());
  detect_parameter_ = const_cast< ::vas::DetectParameter*>(&::vas::DetectParameter::default_instance());
}

ServiceParameter::ServiceParameter(const ServiceParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.ServiceParameter)
}

void ServiceParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  decode_parameter_ = NULL;
  detect_parameter_ = NULL;
  service_status_ = 0;
  reg_msg_subscribe_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceParameter::~ServiceParameter() {
  // @@protoc_insertion_point(destructor:vas.ServiceParameter)
  SharedDtor();
}

void ServiceParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
    delete decode_parameter_;
    delete detect_parameter_;
  }
}

void ServiceParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServiceParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceParameter_descriptor_;
}

const ServiceParameter& ServiceParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

ServiceParameter* ServiceParameter::default_instance_ = NULL;

ServiceParameter* ServiceParameter::New() const {
  return new ServiceParameter;
}

void ServiceParameter::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    if (has_decode_parameter()) {
      if (decode_parameter_ != NULL) decode_parameter_->::vas::DecodeParameter::Clear();
    }
    if (has_detect_parameter()) {
      if (detect_parameter_ != NULL) detect_parameter_->::vas::DetectParameter::Clear();
    }
    service_status_ = 0;
    reg_msg_subscribe_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServiceParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.ServiceParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_decode_parameter;
        break;
      }

      // optional .vas.DecodeParameter decode_parameter = 2;
      case 2: {
        if (tag == 18) {
         parse_decode_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decode_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_detect_parameter;
        break;
      }

      // optional .vas.DetectParameter detect_parameter = 3;
      case 3: {
        if (tag == 26) {
         parse_detect_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_detect_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_service_status;
        break;
      }

      // optional .vas.ServiceStatus service_status = 4;
      case 4: {
        if (tag == 32) {
         parse_service_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::ServiceStatus_IsValid(value)) {
            set_service_status(static_cast< ::vas::ServiceStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reg_msg_subscribe;
        break;
      }

      // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
      case 5: {
        if (tag == 40) {
         parse_reg_msg_subscribe:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::RegMsgSubscribe_IsValid(value)) {
            set_reg_msg_subscribe(static_cast< ::vas::RegMsgSubscribe >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.ServiceParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.ServiceParameter)
  return false;
#undef DO_
}

void ServiceParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.ServiceParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // optional .vas.DecodeParameter decode_parameter = 2;
  if (has_decode_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->decode_parameter(), output);
  }

  // optional .vas.DetectParameter detect_parameter = 3;
  if (has_detect_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->detect_parameter(), output);
  }

  // optional .vas.ServiceStatus service_status = 4;
  if (has_service_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->service_status(), output);
  }

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  if (has_reg_msg_subscribe()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->reg_msg_subscribe(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.ServiceParameter)
}

::google::protobuf::uint8* ServiceParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.ServiceParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // optional .vas.DecodeParameter decode_parameter = 2;
  if (has_decode_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->decode_parameter(), target);
  }

  // optional .vas.DetectParameter detect_parameter = 3;
  if (has_detect_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->detect_parameter(), target);
  }

  // optional .vas.ServiceStatus service_status = 4;
  if (has_service_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->service_status(), target);
  }

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  if (has_reg_msg_subscribe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->reg_msg_subscribe(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.ServiceParameter)
  return target;
}

int ServiceParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional .vas.DecodeParameter decode_parameter = 2;
    if (has_decode_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decode_parameter());
    }

    // optional .vas.DetectParameter detect_parameter = 3;
    if (has_detect_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->detect_parameter());
    }

    // optional .vas.ServiceStatus service_status = 4;
    if (has_service_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->service_status());
    }

    // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
    if (has_reg_msg_subscribe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reg_msg_subscribe());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServiceParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServiceParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServiceParameter::MergeFrom(const ServiceParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_decode_parameter()) {
      mutable_decode_parameter()->::vas::DecodeParameter::MergeFrom(from.decode_parameter());
    }
    if (from.has_detect_parameter()) {
      mutable_detect_parameter()->::vas::DetectParameter::MergeFrom(from.detect_parameter());
    }
    if (from.has_service_status()) {
      set_service_status(from.service_status());
    }
    if (from.has_reg_msg_subscribe()) {
      set_reg_msg_subscribe(from.reg_msg_subscribe());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServiceParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServiceParameter::CopyFrom(const ServiceParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceParameter::IsInitialized() const {

  return true;
}

void ServiceParameter::Swap(ServiceParameter* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    std::swap(decode_parameter_, other->decode_parameter_);
    std::swap(detect_parameter_, other->detect_parameter_);
    std::swap(service_status_, other->service_status_);
    std::swap(reg_msg_subscribe_, other->reg_msg_subscribe_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServiceParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServiceParameter_descriptor_;
  metadata.reflection = ServiceParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SsdServiceParameter::kServiceIdFieldNumber;
const int SsdServiceParameter::kDecodeParameterFieldNumber;
const int SsdServiceParameter::kDetectParameterFieldNumber;
const int SsdServiceParameter::kServiceStatusFieldNumber;
const int SsdServiceParameter::kRegMsgSubscribeFieldNumber;
#endif  // !_MSC_VER

SsdServiceParameter::SsdServiceParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.SsdServiceParameter)
}

void SsdServiceParameter::InitAsDefaultInstance() {
  decode_parameter_ = const_cast< ::vas::DecodeParameter*>(&::vas::DecodeParameter::default_instance());
  detect_parameter_ = const_cast< ::vas::SsdDetecterParameter*>(&::vas::SsdDetecterParameter::default_instance());
}

SsdServiceParameter::SsdServiceParameter(const SsdServiceParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.SsdServiceParameter)
}

void SsdServiceParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  decode_parameter_ = NULL;
  detect_parameter_ = NULL;
  service_status_ = 0;
  reg_msg_subscribe_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SsdServiceParameter::~SsdServiceParameter() {
  // @@protoc_insertion_point(destructor:vas.SsdServiceParameter)
  SharedDtor();
}

void SsdServiceParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
    delete decode_parameter_;
    delete detect_parameter_;
  }
}

void SsdServiceParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SsdServiceParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SsdServiceParameter_descriptor_;
}

const SsdServiceParameter& SsdServiceParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

SsdServiceParameter* SsdServiceParameter::default_instance_ = NULL;

SsdServiceParameter* SsdServiceParameter::New() const {
  return new SsdServiceParameter;
}

void SsdServiceParameter::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    if (has_decode_parameter()) {
      if (decode_parameter_ != NULL) decode_parameter_->::vas::DecodeParameter::Clear();
    }
    if (has_detect_parameter()) {
      if (detect_parameter_ != NULL) detect_parameter_->::vas::SsdDetecterParameter::Clear();
    }
    service_status_ = 0;
    reg_msg_subscribe_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SsdServiceParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.SsdServiceParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_decode_parameter;
        break;
      }

      // optional .vas.DecodeParameter decode_parameter = 2;
      case 2: {
        if (tag == 18) {
         parse_decode_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decode_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_detect_parameter;
        break;
      }

      // optional .vas.SsdDetecterParameter detect_parameter = 3;
      case 3: {
        if (tag == 26) {
         parse_detect_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_detect_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_service_status;
        break;
      }

      // optional .vas.ServiceStatus service_status = 4;
      case 4: {
        if (tag == 32) {
         parse_service_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::ServiceStatus_IsValid(value)) {
            set_service_status(static_cast< ::vas::ServiceStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reg_msg_subscribe;
        break;
      }

      // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
      case 5: {
        if (tag == 40) {
         parse_reg_msg_subscribe:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::RegMsgSubscribe_IsValid(value)) {
            set_reg_msg_subscribe(static_cast< ::vas::RegMsgSubscribe >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.SsdServiceParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.SsdServiceParameter)
  return false;
#undef DO_
}

void SsdServiceParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.SsdServiceParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // optional .vas.DecodeParameter decode_parameter = 2;
  if (has_decode_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->decode_parameter(), output);
  }

  // optional .vas.SsdDetecterParameter detect_parameter = 3;
  if (has_detect_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->detect_parameter(), output);
  }

  // optional .vas.ServiceStatus service_status = 4;
  if (has_service_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->service_status(), output);
  }

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  if (has_reg_msg_subscribe()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->reg_msg_subscribe(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.SsdServiceParameter)
}

::google::protobuf::uint8* SsdServiceParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.SsdServiceParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // optional .vas.DecodeParameter decode_parameter = 2;
  if (has_decode_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->decode_parameter(), target);
  }

  // optional .vas.SsdDetecterParameter detect_parameter = 3;
  if (has_detect_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->detect_parameter(), target);
  }

  // optional .vas.ServiceStatus service_status = 4;
  if (has_service_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->service_status(), target);
  }

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  if (has_reg_msg_subscribe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->reg_msg_subscribe(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.SsdServiceParameter)
  return target;
}

int SsdServiceParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional .vas.DecodeParameter decode_parameter = 2;
    if (has_decode_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decode_parameter());
    }

    // optional .vas.SsdDetecterParameter detect_parameter = 3;
    if (has_detect_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->detect_parameter());
    }

    // optional .vas.ServiceStatus service_status = 4;
    if (has_service_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->service_status());
    }

    // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
    if (has_reg_msg_subscribe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reg_msg_subscribe());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SsdServiceParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SsdServiceParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SsdServiceParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SsdServiceParameter::MergeFrom(const SsdServiceParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_decode_parameter()) {
      mutable_decode_parameter()->::vas::DecodeParameter::MergeFrom(from.decode_parameter());
    }
    if (from.has_detect_parameter()) {
      mutable_detect_parameter()->::vas::SsdDetecterParameter::MergeFrom(from.detect_parameter());
    }
    if (from.has_service_status()) {
      set_service_status(from.service_status());
    }
    if (from.has_reg_msg_subscribe()) {
      set_reg_msg_subscribe(from.reg_msg_subscribe());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SsdServiceParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SsdServiceParameter::CopyFrom(const SsdServiceParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SsdServiceParameter::IsInitialized() const {

  return true;
}

void SsdServiceParameter::Swap(SsdServiceParameter* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    std::swap(decode_parameter_, other->decode_parameter_);
    std::swap(detect_parameter_, other->detect_parameter_);
    std::swap(service_status_, other->service_status_);
    std::swap(reg_msg_subscribe_, other->reg_msg_subscribe_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SsdServiceParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SsdServiceParameter_descriptor_;
  metadata.reflection = SsdServiceParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NvrServiceParameter::kServiceIdFieldNumber;
const int NvrServiceParameter::kNvrChannelFieldNumber;
const int NvrServiceParameter::kDetectParameterFieldNumber;
const int NvrServiceParameter::kServiceStatusFieldNumber;
const int NvrServiceParameter::kRegMsgSubscribeFieldNumber;
#endif  // !_MSC_VER

NvrServiceParameter::NvrServiceParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.NvrServiceParameter)
}

void NvrServiceParameter::InitAsDefaultInstance() {
  nvr_channel_ = const_cast< ::vas::NvrChannel*>(&::vas::NvrChannel::default_instance());
  detect_parameter_ = const_cast< ::vas::DetectParameter*>(&::vas::DetectParameter::default_instance());
}

NvrServiceParameter::NvrServiceParameter(const NvrServiceParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.NvrServiceParameter)
}

void NvrServiceParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nvr_channel_ = NULL;
  detect_parameter_ = NULL;
  service_status_ = 0;
  reg_msg_subscribe_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NvrServiceParameter::~NvrServiceParameter() {
  // @@protoc_insertion_point(destructor:vas.NvrServiceParameter)
  SharedDtor();
}

void NvrServiceParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
    delete nvr_channel_;
    delete detect_parameter_;
  }
}

void NvrServiceParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NvrServiceParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NvrServiceParameter_descriptor_;
}

const NvrServiceParameter& NvrServiceParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

NvrServiceParameter* NvrServiceParameter::default_instance_ = NULL;

NvrServiceParameter* NvrServiceParameter::New() const {
  return new NvrServiceParameter;
}

void NvrServiceParameter::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    if (has_nvr_channel()) {
      if (nvr_channel_ != NULL) nvr_channel_->::vas::NvrChannel::Clear();
    }
    if (has_detect_parameter()) {
      if (detect_parameter_ != NULL) detect_parameter_->::vas::DetectParameter::Clear();
    }
    service_status_ = 0;
    reg_msg_subscribe_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NvrServiceParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.NvrServiceParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_nvr_channel;
        break;
      }

      // optional .vas.NvrChannel nvr_channel = 2;
      case 2: {
        if (tag == 18) {
         parse_nvr_channel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_nvr_channel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_detect_parameter;
        break;
      }

      // optional .vas.DetectParameter detect_parameter = 3;
      case 3: {
        if (tag == 26) {
         parse_detect_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_detect_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_service_status;
        break;
      }

      // optional .vas.ServiceStatus service_status = 4;
      case 4: {
        if (tag == 32) {
         parse_service_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::ServiceStatus_IsValid(value)) {
            set_service_status(static_cast< ::vas::ServiceStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_reg_msg_subscribe;
        break;
      }

      // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
      case 5: {
        if (tag == 40) {
         parse_reg_msg_subscribe:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::RegMsgSubscribe_IsValid(value)) {
            set_reg_msg_subscribe(static_cast< ::vas::RegMsgSubscribe >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.NvrServiceParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.NvrServiceParameter)
  return false;
#undef DO_
}

void NvrServiceParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.NvrServiceParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // optional .vas.NvrChannel nvr_channel = 2;
  if (has_nvr_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->nvr_channel(), output);
  }

  // optional .vas.DetectParameter detect_parameter = 3;
  if (has_detect_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->detect_parameter(), output);
  }

  // optional .vas.ServiceStatus service_status = 4;
  if (has_service_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->service_status(), output);
  }

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  if (has_reg_msg_subscribe()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->reg_msg_subscribe(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.NvrServiceParameter)
}

::google::protobuf::uint8* NvrServiceParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.NvrServiceParameter)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // optional .vas.NvrChannel nvr_channel = 2;
  if (has_nvr_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->nvr_channel(), target);
  }

  // optional .vas.DetectParameter detect_parameter = 3;
  if (has_detect_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->detect_parameter(), target);
  }

  // optional .vas.ServiceStatus service_status = 4;
  if (has_service_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->service_status(), target);
  }

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  if (has_reg_msg_subscribe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->reg_msg_subscribe(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.NvrServiceParameter)
  return target;
}

int NvrServiceParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional .vas.NvrChannel nvr_channel = 2;
    if (has_nvr_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nvr_channel());
    }

    // optional .vas.DetectParameter detect_parameter = 3;
    if (has_detect_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->detect_parameter());
    }

    // optional .vas.ServiceStatus service_status = 4;
    if (has_service_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->service_status());
    }

    // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
    if (has_reg_msg_subscribe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reg_msg_subscribe());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NvrServiceParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NvrServiceParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NvrServiceParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NvrServiceParameter::MergeFrom(const NvrServiceParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_nvr_channel()) {
      mutable_nvr_channel()->::vas::NvrChannel::MergeFrom(from.nvr_channel());
    }
    if (from.has_detect_parameter()) {
      mutable_detect_parameter()->::vas::DetectParameter::MergeFrom(from.detect_parameter());
    }
    if (from.has_service_status()) {
      set_service_status(from.service_status());
    }
    if (from.has_reg_msg_subscribe()) {
      set_reg_msg_subscribe(from.reg_msg_subscribe());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NvrServiceParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NvrServiceParameter::CopyFrom(const NvrServiceParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvrServiceParameter::IsInitialized() const {

  return true;
}

void NvrServiceParameter::Swap(NvrServiceParameter* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    std::swap(nvr_channel_, other->nvr_channel_);
    std::swap(detect_parameter_, other->detect_parameter_);
    std::swap(service_status_, other->service_status_);
    std::swap(reg_msg_subscribe_, other->reg_msg_subscribe_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NvrServiceParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NvrServiceParameter_descriptor_;
  metadata.reflection = NvrServiceParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceList::kLastUpdateTimeFieldNumber;
const int ServiceList::kServiceParamterFieldNumber;
#endif  // !_MSC_VER

ServiceList::ServiceList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.ServiceList)
}

void ServiceList::InitAsDefaultInstance() {
}

ServiceList::ServiceList(const ServiceList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.ServiceList)
}

void ServiceList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  last_update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceList::~ServiceList() {
  // @@protoc_insertion_point(destructor:vas.ServiceList)
  SharedDtor();
}

void ServiceList::SharedDtor() {
  if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete last_update_time_;
  }
  if (this != default_instance_) {
  }
}

void ServiceList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServiceList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceList_descriptor_;
}

const ServiceList& ServiceList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

ServiceList* ServiceList::default_instance_ = NULL;

ServiceList* ServiceList::New() const {
  return new ServiceList;
}

void ServiceList::Clear() {
  if (has_last_update_time()) {
    if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      last_update_time_->clear();
    }
  }
  service_paramter_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServiceList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.ServiceList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string last_update_time = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_last_update_time()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->last_update_time().data(), this->last_update_time().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "last_update_time");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_paramter;
        break;
      }

      // repeated .vas.ServiceParameter service_paramter = 2;
      case 2: {
        if (tag == 18) {
         parse_service_paramter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_service_paramter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_paramter;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.ServiceList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.ServiceList)
  return false;
#undef DO_
}

void ServiceList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.ServiceList)
  // optional string last_update_time = 1;
  if (has_last_update_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->last_update_time().data(), this->last_update_time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "last_update_time");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->last_update_time(), output);
  }

  // repeated .vas.ServiceParameter service_paramter = 2;
  for (int i = 0; i < this->service_paramter_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->service_paramter(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.ServiceList)
}

::google::protobuf::uint8* ServiceList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.ServiceList)
  // optional string last_update_time = 1;
  if (has_last_update_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->last_update_time().data(), this->last_update_time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "last_update_time");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->last_update_time(), target);
  }

  // repeated .vas.ServiceParameter service_paramter = 2;
  for (int i = 0; i < this->service_paramter_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->service_paramter(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.ServiceList)
  return target;
}

int ServiceList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string last_update_time = 1;
    if (has_last_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->last_update_time());
    }

  }
  // repeated .vas.ServiceParameter service_paramter = 2;
  total_size += 1 * this->service_paramter_size();
  for (int i = 0; i < this->service_paramter_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->service_paramter(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServiceList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServiceList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServiceList::MergeFrom(const ServiceList& from) {
  GOOGLE_CHECK_NE(&from, this);
  service_paramter_.MergeFrom(from.service_paramter_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_last_update_time()) {
      set_last_update_time(from.last_update_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServiceList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServiceList::CopyFrom(const ServiceList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceList::IsInitialized() const {

  return true;
}

void ServiceList::Swap(ServiceList* other) {
  if (other != this) {
    std::swap(last_update_time_, other->last_update_time_);
    service_paramter_.Swap(&other->service_paramter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServiceList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServiceList_descriptor_;
  metadata.reflection = ServiceList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SsdServiceList::kLastUpdateTimeFieldNumber;
const int SsdServiceList::kServiceParamterFieldNumber;
#endif  // !_MSC_VER

SsdServiceList::SsdServiceList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.SsdServiceList)
}

void SsdServiceList::InitAsDefaultInstance() {
}

SsdServiceList::SsdServiceList(const SsdServiceList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.SsdServiceList)
}

void SsdServiceList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  last_update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SsdServiceList::~SsdServiceList() {
  // @@protoc_insertion_point(destructor:vas.SsdServiceList)
  SharedDtor();
}

void SsdServiceList::SharedDtor() {
  if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete last_update_time_;
  }
  if (this != default_instance_) {
  }
}

void SsdServiceList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SsdServiceList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SsdServiceList_descriptor_;
}

const SsdServiceList& SsdServiceList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

SsdServiceList* SsdServiceList::default_instance_ = NULL;

SsdServiceList* SsdServiceList::New() const {
  return new SsdServiceList;
}

void SsdServiceList::Clear() {
  if (has_last_update_time()) {
    if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      last_update_time_->clear();
    }
  }
  service_paramter_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SsdServiceList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.SsdServiceList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string last_update_time = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_last_update_time()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->last_update_time().data(), this->last_update_time().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "last_update_time");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_paramter;
        break;
      }

      // repeated .vas.SsdServiceParameter service_paramter = 2;
      case 2: {
        if (tag == 18) {
         parse_service_paramter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_service_paramter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_paramter;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.SsdServiceList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.SsdServiceList)
  return false;
#undef DO_
}

void SsdServiceList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.SsdServiceList)
  // optional string last_update_time = 1;
  if (has_last_update_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->last_update_time().data(), this->last_update_time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "last_update_time");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->last_update_time(), output);
  }

  // repeated .vas.SsdServiceParameter service_paramter = 2;
  for (int i = 0; i < this->service_paramter_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->service_paramter(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.SsdServiceList)
}

::google::protobuf::uint8* SsdServiceList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.SsdServiceList)
  // optional string last_update_time = 1;
  if (has_last_update_time()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->last_update_time().data(), this->last_update_time().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "last_update_time");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->last_update_time(), target);
  }

  // repeated .vas.SsdServiceParameter service_paramter = 2;
  for (int i = 0; i < this->service_paramter_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->service_paramter(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.SsdServiceList)
  return target;
}

int SsdServiceList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string last_update_time = 1;
    if (has_last_update_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->last_update_time());
    }

  }
  // repeated .vas.SsdServiceParameter service_paramter = 2;
  total_size += 1 * this->service_paramter_size();
  for (int i = 0; i < this->service_paramter_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->service_paramter(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SsdServiceList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SsdServiceList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SsdServiceList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SsdServiceList::MergeFrom(const SsdServiceList& from) {
  GOOGLE_CHECK_NE(&from, this);
  service_paramter_.MergeFrom(from.service_paramter_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_last_update_time()) {
      set_last_update_time(from.last_update_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SsdServiceList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SsdServiceList::CopyFrom(const SsdServiceList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SsdServiceList::IsInitialized() const {

  return true;
}

void SsdServiceList::Swap(SsdServiceList* other) {
  if (other != this) {
    std::swap(last_update_time_, other->last_update_time_);
    service_paramter_.Swap(&other->service_paramter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SsdServiceList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SsdServiceList_descriptor_;
  metadata.reflection = SsdServiceList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NvrServiceList::kNvrParamterFieldNumber;
const int NvrServiceList::kServiceParameterFieldNumber;
#endif  // !_MSC_VER

NvrServiceList::NvrServiceList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.NvrServiceList)
}

void NvrServiceList::InitAsDefaultInstance() {
  nvr_paramter_ = const_cast< ::vas::NvrParameter*>(&::vas::NvrParameter::default_instance());
}

NvrServiceList::NvrServiceList(const NvrServiceList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.NvrServiceList)
}

void NvrServiceList::SharedCtor() {
  _cached_size_ = 0;
  nvr_paramter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NvrServiceList::~NvrServiceList() {
  // @@protoc_insertion_point(destructor:vas.NvrServiceList)
  SharedDtor();
}

void NvrServiceList::SharedDtor() {
  if (this != default_instance_) {
    delete nvr_paramter_;
  }
}

void NvrServiceList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NvrServiceList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NvrServiceList_descriptor_;
}

const NvrServiceList& NvrServiceList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

NvrServiceList* NvrServiceList::default_instance_ = NULL;

NvrServiceList* NvrServiceList::New() const {
  return new NvrServiceList;
}

void NvrServiceList::Clear() {
  if (has_nvr_paramter()) {
    if (nvr_paramter_ != NULL) nvr_paramter_->::vas::NvrParameter::Clear();
  }
  service_parameter_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NvrServiceList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.NvrServiceList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vas.NvrParameter nvr_paramter = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_nvr_paramter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_parameter;
        break;
      }

      // repeated .vas.NvrServiceParameter service_parameter = 2;
      case 2: {
        if (tag == 18) {
         parse_service_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_service_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_parameter;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.NvrServiceList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.NvrServiceList)
  return false;
#undef DO_
}

void NvrServiceList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.NvrServiceList)
  // optional .vas.NvrParameter nvr_paramter = 1;
  if (has_nvr_paramter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->nvr_paramter(), output);
  }

  // repeated .vas.NvrServiceParameter service_parameter = 2;
  for (int i = 0; i < this->service_parameter_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->service_parameter(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.NvrServiceList)
}

::google::protobuf::uint8* NvrServiceList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.NvrServiceList)
  // optional .vas.NvrParameter nvr_paramter = 1;
  if (has_nvr_paramter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nvr_paramter(), target);
  }

  // repeated .vas.NvrServiceParameter service_parameter = 2;
  for (int i = 0; i < this->service_parameter_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->service_parameter(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.NvrServiceList)
  return target;
}

int NvrServiceList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vas.NvrParameter nvr_paramter = 1;
    if (has_nvr_paramter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nvr_paramter());
    }

  }
  // repeated .vas.NvrServiceParameter service_parameter = 2;
  total_size += 1 * this->service_parameter_size();
  for (int i = 0; i < this->service_parameter_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->service_parameter(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NvrServiceList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NvrServiceList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NvrServiceList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NvrServiceList::MergeFrom(const NvrServiceList& from) {
  GOOGLE_CHECK_NE(&from, this);
  service_parameter_.MergeFrom(from.service_parameter_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nvr_paramter()) {
      mutable_nvr_paramter()->::vas::NvrParameter::MergeFrom(from.nvr_paramter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NvrServiceList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NvrServiceList::CopyFrom(const NvrServiceList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvrServiceList::IsInitialized() const {

  return true;
}

void NvrServiceList::Swap(NvrServiceList* other) {
  if (other != this) {
    std::swap(nvr_paramter_, other->nvr_paramter_);
    service_parameter_.Swap(&other->service_parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NvrServiceList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NvrServiceList_descriptor_;
  metadata.reflection = NvrServiceList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasComParameter::kIpFieldNumber;
const int VasComParameter::kPortFieldNumber;
const int VasComParameter::kAppStateFieldNumber;
const int VasComParameter::kHeartbeatIntervalFieldNumber;
#endif  // !_MSC_VER

VasComParameter::VasComParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasComParameter)
}

void VasComParameter::InitAsDefaultInstance() {
}

VasComParameter::VasComParameter(const VasComParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasComParameter)
}

void VasComParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = GOOGLE_LONGLONG(8001);
  app_state_ = 2;
  heartbeat_interval_ = 10;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasComParameter::~VasComParameter() {
  // @@protoc_insertion_point(destructor:vas.VasComParameter)
  SharedDtor();
}

void VasComParameter::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void VasComParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasComParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasComParameter_descriptor_;
}

const VasComParameter& VasComParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasComParameter* VasComParameter::default_instance_ = NULL;

VasComParameter* VasComParameter::New() const {
  return new VasComParameter;
}

void VasComParameter::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
    port_ = GOOGLE_LONGLONG(8001);
    app_state_ = 2;
    heartbeat_interval_ = 10;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasComParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasComParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string ip = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // optional int64 port = 2 [default = 8001];
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_app_state;
        break;
      }

      // optional .vas.EnAppState app_state = 3 [default = ST_STOPPED];
      case 3: {
        if (tag == 24) {
         parse_app_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vas::EnAppState_IsValid(value)) {
            set_app_state(static_cast< ::vas::EnAppState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_heartbeat_interval;
        break;
      }

      // optional int32 heartbeat_interval = 4 [default = 10];
      case 4: {
        if (tag == 32) {
         parse_heartbeat_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heartbeat_interval_)));
          set_has_heartbeat_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasComParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasComParameter)
  return false;
#undef DO_
}

void VasComParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasComParameter)
  // optional string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip(), output);
  }

  // optional int64 port = 2 [default = 8001];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->port(), output);
  }

  // optional .vas.EnAppState app_state = 3 [default = ST_STOPPED];
  if (has_app_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->app_state(), output);
  }

  // optional int32 heartbeat_interval = 4 [default = 10];
  if (has_heartbeat_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->heartbeat_interval(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasComParameter)
}

::google::protobuf::uint8* VasComParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasComParameter)
  // optional string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ip(), target);
  }

  // optional int64 port = 2 [default = 8001];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->port(), target);
  }

  // optional .vas.EnAppState app_state = 3 [default = ST_STOPPED];
  if (has_app_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->app_state(), target);
  }

  // optional int32 heartbeat_interval = 4 [default = 10];
  if (has_heartbeat_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->heartbeat_interval(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasComParameter)
  return target;
}

int VasComParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional int64 port = 2 [default = 8001];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->port());
    }

    // optional .vas.EnAppState app_state = 3 [default = ST_STOPPED];
    if (has_app_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->app_state());
    }

    // optional int32 heartbeat_interval = 4 [default = 10];
    if (has_heartbeat_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heartbeat_interval());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasComParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasComParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasComParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasComParameter::MergeFrom(const VasComParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_app_state()) {
      set_app_state(from.app_state());
    }
    if (from.has_heartbeat_interval()) {
      set_heartbeat_interval(from.heartbeat_interval());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasComParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasComParameter::CopyFrom(const VasComParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasComParameter::IsInitialized() const {

  return true;
}

void VasComParameter::Swap(VasComParameter* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(app_state_, other->app_state_);
    std::swap(heartbeat_interval_, other->heartbeat_interval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasComParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasComParameter_descriptor_;
  metadata.reflection = VasComParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasComputeNode::kNodeIdFieldNumber;
const int VasComputeNode::kNodeNameFieldNumber;
const int VasComputeNode::kCenterIdFieldNumber;
const int VasComputeNode::kComVersionFieldNumber;
const int VasComputeNode::kRetryCountFieldNumber;
#endif  // !_MSC_VER

VasComputeNode::VasComputeNode()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasComputeNode)
}

void VasComputeNode::InitAsDefaultInstance() {
}

VasComputeNode::VasComputeNode(const VasComputeNode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasComputeNode)
}

void VasComputeNode::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  node_id_ = 0;
  node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  center_id_ = 0;
  com_version_ = 0;
  retry_count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasComputeNode::~VasComputeNode() {
  // @@protoc_insertion_point(destructor:vas.VasComputeNode)
  SharedDtor();
}

void VasComputeNode::SharedDtor() {
  if (node_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_name_;
  }
  if (this != default_instance_) {
  }
}

void VasComputeNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasComputeNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasComputeNode_descriptor_;
}

const VasComputeNode& VasComputeNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasComputeNode* VasComputeNode::default_instance_ = NULL;

VasComputeNode* VasComputeNode::New() const {
  return new VasComputeNode;
}

void VasComputeNode::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VasComputeNode*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(node_id_, retry_count_);
    if (has_node_name()) {
      if (node_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        node_name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasComputeNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasComputeNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 node_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_node_name;
        break;
      }

      // optional string node_name = 2;
      case 2: {
        if (tag == 18) {
         parse_node_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_node_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->node_name().data(), this->node_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "node_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_center_id;
        break;
      }

      // optional int32 center_id = 3;
      case 3: {
        if (tag == 24) {
         parse_center_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &center_id_)));
          set_has_center_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_com_version;
        break;
      }

      // optional int32 com_version = 4;
      case 4: {
        if (tag == 32) {
         parse_com_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &com_version_)));
          set_has_com_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_retry_count;
        break;
      }

      // optional int32 retry_count = 5;
      case 5: {
        if (tag == 40) {
         parse_retry_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retry_count_)));
          set_has_retry_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasComputeNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasComputeNode)
  return false;
#undef DO_
}

void VasComputeNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasComputeNode)
  // optional int32 node_id = 1;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->node_id(), output);
  }

  // optional string node_name = 2;
  if (has_node_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->node_name().data(), this->node_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "node_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->node_name(), output);
  }

  // optional int32 center_id = 3;
  if (has_center_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->center_id(), output);
  }

  // optional int32 com_version = 4;
  if (has_com_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->com_version(), output);
  }

  // optional int32 retry_count = 5;
  if (has_retry_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->retry_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasComputeNode)
}

::google::protobuf::uint8* VasComputeNode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasComputeNode)
  // optional int32 node_id = 1;
  if (has_node_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->node_id(), target);
  }

  // optional string node_name = 2;
  if (has_node_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->node_name().data(), this->node_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "node_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->node_name(), target);
  }

  // optional int32 center_id = 3;
  if (has_center_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->center_id(), target);
  }

  // optional int32 com_version = 4;
  if (has_com_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->com_version(), target);
  }

  // optional int32 retry_count = 5;
  if (has_retry_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->retry_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasComputeNode)
  return target;
}

int VasComputeNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional string node_name = 2;
    if (has_node_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->node_name());
    }

    // optional int32 center_id = 3;
    if (has_center_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->center_id());
    }

    // optional int32 com_version = 4;
    if (has_com_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->com_version());
    }

    // optional int32 retry_count = 5;
    if (has_retry_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retry_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasComputeNode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasComputeNode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasComputeNode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasComputeNode::MergeFrom(const VasComputeNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_node_name()) {
      set_node_name(from.node_name());
    }
    if (from.has_center_id()) {
      set_center_id(from.center_id());
    }
    if (from.has_com_version()) {
      set_com_version(from.com_version());
    }
    if (from.has_retry_count()) {
      set_retry_count(from.retry_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasComputeNode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasComputeNode::CopyFrom(const VasComputeNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasComputeNode::IsInitialized() const {

  return true;
}

void VasComputeNode::Swap(VasComputeNode* other) {
  if (other != this) {
    std::swap(node_id_, other->node_id_);
    std::swap(node_name_, other->node_name_);
    std::swap(center_id_, other->center_id_);
    std::swap(com_version_, other->com_version_);
    std::swap(retry_count_, other->retry_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasComputeNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasComputeNode_descriptor_;
  metadata.reflection = VasComputeNode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasClientParameter::kComParamFieldNumber;
const int VasClientParameter::kNodeParamFieldNumber;
#endif  // !_MSC_VER

VasClientParameter::VasClientParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasClientParameter)
}

void VasClientParameter::InitAsDefaultInstance() {
  com_param_ = const_cast< ::vas::VasComParameter*>(&::vas::VasComParameter::default_instance());
  node_param_ = const_cast< ::vas::VasComputeNode*>(&::vas::VasComputeNode::default_instance());
}

VasClientParameter::VasClientParameter(const VasClientParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasClientParameter)
}

void VasClientParameter::SharedCtor() {
  _cached_size_ = 0;
  com_param_ = NULL;
  node_param_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasClientParameter::~VasClientParameter() {
  // @@protoc_insertion_point(destructor:vas.VasClientParameter)
  SharedDtor();
}

void VasClientParameter::SharedDtor() {
  if (this != default_instance_) {
    delete com_param_;
    delete node_param_;
  }
}

void VasClientParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasClientParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasClientParameter_descriptor_;
}

const VasClientParameter& VasClientParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasClientParameter* VasClientParameter::default_instance_ = NULL;

VasClientParameter* VasClientParameter::New() const {
  return new VasClientParameter;
}

void VasClientParameter::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_com_param()) {
      if (com_param_ != NULL) com_param_->::vas::VasComParameter::Clear();
    }
    if (has_node_param()) {
      if (node_param_ != NULL) node_param_->::vas::VasComputeNode::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasClientParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasClientParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vas.VasComParameter com_param = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_com_param()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_node_param;
        break;
      }

      // optional .vas.VasComputeNode node_param = 2;
      case 2: {
        if (tag == 18) {
         parse_node_param:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node_param()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasClientParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasClientParameter)
  return false;
#undef DO_
}

void VasClientParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasClientParameter)
  // optional .vas.VasComParameter com_param = 1;
  if (has_com_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->com_param(), output);
  }

  // optional .vas.VasComputeNode node_param = 2;
  if (has_node_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->node_param(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasClientParameter)
}

::google::protobuf::uint8* VasClientParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasClientParameter)
  // optional .vas.VasComParameter com_param = 1;
  if (has_com_param()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->com_param(), target);
  }

  // optional .vas.VasComputeNode node_param = 2;
  if (has_node_param()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->node_param(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasClientParameter)
  return target;
}

int VasClientParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vas.VasComParameter com_param = 1;
    if (has_com_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->com_param());
    }

    // optional .vas.VasComputeNode node_param = 2;
    if (has_node_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node_param());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasClientParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasClientParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasClientParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasClientParameter::MergeFrom(const VasClientParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_com_param()) {
      mutable_com_param()->::vas::VasComParameter::MergeFrom(from.com_param());
    }
    if (from.has_node_param()) {
      mutable_node_param()->::vas::VasComputeNode::MergeFrom(from.node_param());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasClientParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasClientParameter::CopyFrom(const VasClientParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasClientParameter::IsInitialized() const {

  return true;
}

void VasClientParameter::Swap(VasClientParameter* other) {
  if (other != this) {
    std::swap(com_param_, other->com_param_);
    std::swap(node_param_, other->node_param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasClientParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasClientParameter_descriptor_;
  metadata.reflection = VasClientParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasMsgFilterParam::kServiceIdFieldNumber;
const int VasMsgFilterParam::kIntervalSecFieldNumber;
#endif  // !_MSC_VER

VasMsgFilterParam::VasMsgFilterParam()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasMsgFilterParam)
}

void VasMsgFilterParam::InitAsDefaultInstance() {
}

VasMsgFilterParam::VasMsgFilterParam(const VasMsgFilterParam& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasMsgFilterParam)
}

void VasMsgFilterParam::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  interval_sec_ = 5;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasMsgFilterParam::~VasMsgFilterParam() {
  // @@protoc_insertion_point(destructor:vas.VasMsgFilterParam)
  SharedDtor();
}

void VasMsgFilterParam::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
  }
}

void VasMsgFilterParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasMsgFilterParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasMsgFilterParam_descriptor_;
}

const VasMsgFilterParam& VasMsgFilterParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasMsgFilterParam* VasMsgFilterParam::default_instance_ = NULL;

VasMsgFilterParam* VasMsgFilterParam::New() const {
  return new VasMsgFilterParam;
}

void VasMsgFilterParam::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    interval_sec_ = 5;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasMsgFilterParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasMsgFilterParam)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_interval_sec;
        break;
      }

      // optional int32 interval_sec = 2 [default = 5];
      case 2: {
        if (tag == 16) {
         parse_interval_sec:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &interval_sec_)));
          set_has_interval_sec();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasMsgFilterParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasMsgFilterParam)
  return false;
#undef DO_
}

void VasMsgFilterParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasMsgFilterParam)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_id(), output);
  }

  // optional int32 interval_sec = 2 [default = 5];
  if (has_interval_sec()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->interval_sec(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasMsgFilterParam)
}

::google::protobuf::uint8* VasMsgFilterParam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasMsgFilterParam)
  // optional string service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->service_id(), target);
  }

  // optional int32 interval_sec = 2 [default = 5];
  if (has_interval_sec()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->interval_sec(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasMsgFilterParam)
  return target;
}

int VasMsgFilterParam::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional int32 interval_sec = 2 [default = 5];
    if (has_interval_sec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->interval_sec());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasMsgFilterParam::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasMsgFilterParam* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasMsgFilterParam*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasMsgFilterParam::MergeFrom(const VasMsgFilterParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_interval_sec()) {
      set_interval_sec(from.interval_sec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasMsgFilterParam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasMsgFilterParam::CopyFrom(const VasMsgFilterParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasMsgFilterParam::IsInitialized() const {

  return true;
}

void VasMsgFilterParam::Swap(VasMsgFilterParam* other) {
  if (other != this) {
    std::swap(service_id_, other->service_id_);
    std::swap(interval_sec_, other->interval_sec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasMsgFilterParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasMsgFilterParam_descriptor_;
  metadata.reflection = VasMsgFilterParam_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasHeartbeatParameter::kAppKeyFieldNumber;
const int VasHeartbeatParameter::kNodeIdFieldNumber;
const int VasHeartbeatParameter::kServiceListFieldNumber;
const int VasHeartbeatParameter::kTimestampFieldNumber;
#endif  // !_MSC_VER

VasHeartbeatParameter::VasHeartbeatParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasHeartbeatParameter)
}

void VasHeartbeatParameter::InitAsDefaultInstance() {
}

VasHeartbeatParameter::VasHeartbeatParameter(const VasHeartbeatParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasHeartbeatParameter)
}

void VasHeartbeatParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  app_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_id_ = 0;
  service_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasHeartbeatParameter::~VasHeartbeatParameter() {
  // @@protoc_insertion_point(destructor:vas.VasHeartbeatParameter)
  SharedDtor();
}

void VasHeartbeatParameter::SharedDtor() {
  if (app_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete app_key_;
  }
  if (service_list_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_list_;
  }
  if (this != default_instance_) {
  }
}

void VasHeartbeatParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasHeartbeatParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasHeartbeatParameter_descriptor_;
}

const VasHeartbeatParameter& VasHeartbeatParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasHeartbeatParameter* VasHeartbeatParameter::default_instance_ = NULL;

VasHeartbeatParameter* VasHeartbeatParameter::New() const {
  return new VasHeartbeatParameter;
}

void VasHeartbeatParameter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VasHeartbeatParameter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(timestamp_, node_id_);
    if (has_app_key()) {
      if (app_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        app_key_->clear();
      }
    }
    if (has_service_list()) {
      if (service_list_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_list_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasHeartbeatParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasHeartbeatParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string app_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_app_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->app_key().data(), this->app_key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "app_key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_node_id;
        break;
      }

      // optional int32 node_id = 2;
      case 2: {
        if (tag == 16) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_service_list;
        break;
      }

      // optional string service_list = 3;
      case 3: {
        if (tag == 26) {
         parse_service_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_list()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_list().data(), this->service_list().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_list");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 4;
      case 4: {
        if (tag == 32) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasHeartbeatParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasHeartbeatParameter)
  return false;
#undef DO_
}

void VasHeartbeatParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasHeartbeatParameter)
  // optional string app_key = 1;
  if (has_app_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->app_key().data(), this->app_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "app_key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->app_key(), output);
  }

  // optional int32 node_id = 2;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->node_id(), output);
  }

  // optional string service_list = 3;
  if (has_service_list()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_list().data(), this->service_list().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_list");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->service_list(), output);
  }

  // optional int64 timestamp = 4;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->timestamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasHeartbeatParameter)
}

::google::protobuf::uint8* VasHeartbeatParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasHeartbeatParameter)
  // optional string app_key = 1;
  if (has_app_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->app_key().data(), this->app_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "app_key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->app_key(), target);
  }

  // optional int32 node_id = 2;
  if (has_node_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->node_id(), target);
  }

  // optional string service_list = 3;
  if (has_service_list()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_list().data(), this->service_list().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_list");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->service_list(), target);
  }

  // optional int64 timestamp = 4;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->timestamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasHeartbeatParameter)
  return target;
}

int VasHeartbeatParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string app_key = 1;
    if (has_app_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->app_key());
    }

    // optional int32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional string service_list = 3;
    if (has_service_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_list());
    }

    // optional int64 timestamp = 4;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasHeartbeatParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasHeartbeatParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasHeartbeatParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasHeartbeatParameter::MergeFrom(const VasHeartbeatParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_app_key()) {
      set_app_key(from.app_key());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_service_list()) {
      set_service_list(from.service_list());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasHeartbeatParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasHeartbeatParameter::CopyFrom(const VasHeartbeatParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasHeartbeatParameter::IsInitialized() const {

  return true;
}

void VasHeartbeatParameter::Swap(VasHeartbeatParameter* other) {
  if (other != this) {
    std::swap(app_key_, other->app_key_);
    std::swap(node_id_, other->node_id_);
    std::swap(service_list_, other->service_list_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasHeartbeatParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasHeartbeatParameter_descriptor_;
  metadata.reflection = VasHeartbeatParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasHeartbeat::kPsiNameFieldNumber;
const int VasHeartbeat::kParamsFieldNumber;
#endif  // !_MSC_VER

VasHeartbeat::VasHeartbeat()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasHeartbeat)
}

void VasHeartbeat::InitAsDefaultInstance() {
  params_ = const_cast< ::vas::VasHeartbeatParameter*>(&::vas::VasHeartbeatParameter::default_instance());
}

VasHeartbeat::VasHeartbeat(const VasHeartbeat& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasHeartbeat)
}

void VasHeartbeat::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  params_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasHeartbeat::~VasHeartbeat() {
  // @@protoc_insertion_point(destructor:vas.VasHeartbeat)
  SharedDtor();
}

void VasHeartbeat::SharedDtor() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (this != default_instance_) {
    delete params_;
  }
}

void VasHeartbeat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasHeartbeat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasHeartbeat_descriptor_;
}

const VasHeartbeat& VasHeartbeat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasHeartbeat* VasHeartbeat::default_instance_ = NULL;

VasHeartbeat* VasHeartbeat::New() const {
  return new VasHeartbeat;
}

void VasHeartbeat::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_psi_name()) {
      if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        psi_name_->clear();
      }
    }
    if (has_params()) {
      if (params_ != NULL) params_->::vas::VasHeartbeatParameter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasHeartbeat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasHeartbeat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string psi_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_psi_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->psi_name().data(), this->psi_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "psi_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_params;
        break;
      }

      // optional .vas.VasHeartbeatParameter params = 2;
      case 2: {
        if (tag == 18) {
         parse_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_params()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasHeartbeat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasHeartbeat)
  return false;
#undef DO_
}

void VasHeartbeat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasHeartbeat)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->psi_name(), output);
  }

  // optional .vas.VasHeartbeatParameter params = 2;
  if (has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->params(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasHeartbeat)
}

::google::protobuf::uint8* VasHeartbeat::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasHeartbeat)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->psi_name(), target);
  }

  // optional .vas.VasHeartbeatParameter params = 2;
  if (has_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->params(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasHeartbeat)
  return target;
}

int VasHeartbeat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string psi_name = 1;
    if (has_psi_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->psi_name());
    }

    // optional .vas.VasHeartbeatParameter params = 2;
    if (has_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->params());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasHeartbeat::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasHeartbeat* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasHeartbeat*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasHeartbeat::MergeFrom(const VasHeartbeat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_psi_name()) {
      set_psi_name(from.psi_name());
    }
    if (from.has_params()) {
      mutable_params()->::vas::VasHeartbeatParameter::MergeFrom(from.params());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasHeartbeat::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasHeartbeat::CopyFrom(const VasHeartbeat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasHeartbeat::IsInitialized() const {

  return true;
}

void VasHeartbeat::Swap(VasHeartbeat* other) {
  if (other != this) {
    std::swap(psi_name_, other->psi_name_);
    std::swap(params_, other->params_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasHeartbeat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasHeartbeat_descriptor_;
  metadata.reflection = VasHeartbeat_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasRetrunParamter::kPsiNameFieldNumber;
const int VasRetrunParamter::kNodeIdFieldNumber;
const int VasRetrunParamter::kTimestampFieldNumber;
#endif  // !_MSC_VER

VasRetrunParamter::VasRetrunParamter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasRetrunParamter)
}

void VasRetrunParamter::InitAsDefaultInstance() {
}

VasRetrunParamter::VasRetrunParamter(const VasRetrunParamter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasRetrunParamter)
}

void VasRetrunParamter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_id_ = 0;
  timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasRetrunParamter::~VasRetrunParamter() {
  // @@protoc_insertion_point(destructor:vas.VasRetrunParamter)
  SharedDtor();
}

void VasRetrunParamter::SharedDtor() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (this != default_instance_) {
  }
}

void VasRetrunParamter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasRetrunParamter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasRetrunParamter_descriptor_;
}

const VasRetrunParamter& VasRetrunParamter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasRetrunParamter* VasRetrunParamter::default_instance_ = NULL;

VasRetrunParamter* VasRetrunParamter::New() const {
  return new VasRetrunParamter;
}

void VasRetrunParamter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VasRetrunParamter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(timestamp_, node_id_);
    if (has_psi_name()) {
      if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        psi_name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasRetrunParamter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasRetrunParamter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string psi_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_psi_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->psi_name().data(), this->psi_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "psi_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_node_id;
        break;
      }

      // optional int32 node_id = 2;
      case 2: {
        if (tag == 16) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 3;
      case 3: {
        if (tag == 24) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasRetrunParamter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasRetrunParamter)
  return false;
#undef DO_
}

void VasRetrunParamter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasRetrunParamter)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->psi_name(), output);
  }

  // optional int32 node_id = 2;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->node_id(), output);
  }

  // optional int64 timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->timestamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasRetrunParamter)
}

::google::protobuf::uint8* VasRetrunParamter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasRetrunParamter)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->psi_name(), target);
  }

  // optional int32 node_id = 2;
  if (has_node_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->node_id(), target);
  }

  // optional int64 timestamp = 3;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->timestamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasRetrunParamter)
  return target;
}

int VasRetrunParamter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string psi_name = 1;
    if (has_psi_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->psi_name());
    }

    // optional int32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional int64 timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasRetrunParamter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasRetrunParamter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasRetrunParamter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasRetrunParamter::MergeFrom(const VasRetrunParamter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_psi_name()) {
      set_psi_name(from.psi_name());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasRetrunParamter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasRetrunParamter::CopyFrom(const VasRetrunParamter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasRetrunParamter::IsInitialized() const {

  return true;
}

void VasRetrunParamter::Swap(VasRetrunParamter* other) {
  if (other != this) {
    std::swap(psi_name_, other->psi_name_);
    std::swap(node_id_, other->node_id_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasRetrunParamter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasRetrunParamter_descriptor_;
  metadata.reflection = VasRetrunParamter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasReturn::kRetCodeFieldNumber;
const int VasReturn::kRetMsgFieldNumber;
const int VasReturn::kParamsFieldNumber;
#endif  // !_MSC_VER

VasReturn::VasReturn()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasReturn)
}

void VasReturn::InitAsDefaultInstance() {
  params_ = const_cast< ::vas::VasRetrunParamter*>(&::vas::VasRetrunParamter::default_instance());
}

VasReturn::VasReturn(const VasReturn& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasReturn)
}

void VasReturn::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ret_code_ = 0;
  ret_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  params_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasReturn::~VasReturn() {
  // @@protoc_insertion_point(destructor:vas.VasReturn)
  SharedDtor();
}

void VasReturn::SharedDtor() {
  if (ret_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ret_msg_;
  }
  if (this != default_instance_) {
    delete params_;
  }
}

void VasReturn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasReturn::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasReturn_descriptor_;
}

const VasReturn& VasReturn::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasReturn* VasReturn::default_instance_ = NULL;

VasReturn* VasReturn::New() const {
  return new VasReturn;
}

void VasReturn::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    ret_code_ = 0;
    if (has_ret_msg()) {
      if (ret_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ret_msg_->clear();
      }
    }
    if (has_params()) {
      if (params_ != NULL) params_->::vas::VasRetrunParamter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasReturn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasReturn)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 ret_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_code_)));
          set_has_ret_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ret_msg;
        break;
      }

      // optional string ret_msg = 2;
      case 2: {
        if (tag == 18) {
         parse_ret_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ret_msg()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ret_msg().data(), this->ret_msg().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ret_msg");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_params;
        break;
      }

      // optional .vas.VasRetrunParamter params = 3;
      case 3: {
        if (tag == 26) {
         parse_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_params()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasReturn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasReturn)
  return false;
#undef DO_
}

void VasReturn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasReturn)
  // optional int32 ret_code = 1;
  if (has_ret_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret_code(), output);
  }

  // optional string ret_msg = 2;
  if (has_ret_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ret_msg().data(), this->ret_msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ret_msg");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ret_msg(), output);
  }

  // optional .vas.VasRetrunParamter params = 3;
  if (has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->params(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasReturn)
}

::google::protobuf::uint8* VasReturn::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasReturn)
  // optional int32 ret_code = 1;
  if (has_ret_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret_code(), target);
  }

  // optional string ret_msg = 2;
  if (has_ret_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ret_msg().data(), this->ret_msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ret_msg");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ret_msg(), target);
  }

  // optional .vas.VasRetrunParamter params = 3;
  if (has_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->params(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasReturn)
  return target;
}

int VasReturn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 ret_code = 1;
    if (has_ret_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret_code());
    }

    // optional string ret_msg = 2;
    if (has_ret_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ret_msg());
    }

    // optional .vas.VasRetrunParamter params = 3;
    if (has_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->params());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasReturn::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasReturn* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasReturn*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasReturn::MergeFrom(const VasReturn& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret_code()) {
      set_ret_code(from.ret_code());
    }
    if (from.has_ret_msg()) {
      set_ret_msg(from.ret_msg());
    }
    if (from.has_params()) {
      mutable_params()->::vas::VasRetrunParamter::MergeFrom(from.params());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasReturn::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasReturn::CopyFrom(const VasReturn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasReturn::IsInitialized() const {

  return true;
}

void VasReturn::Swap(VasReturn* other) {
  if (other != this) {
    std::swap(ret_code_, other->ret_code_);
    std::swap(ret_msg_, other->ret_msg_);
    std::swap(params_, other->params_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasReturn::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasReturn_descriptor_;
  metadata.reflection = VasReturn_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegRes::kRegTypeFieldNumber;
const int RegRes::kScoreFieldNumber;
const int RegRes::kXFieldNumber;
const int RegRes::kYFieldNumber;
const int RegRes::kWidthFieldNumber;
const int RegRes::kHeightFieldNumber;
#endif  // !_MSC_VER

RegRes::RegRes()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.RegRes)
}

void RegRes::InitAsDefaultInstance() {
}

RegRes::RegRes(const RegRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.RegRes)
}

void RegRes::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  reg_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  score_ = 0;
  x_ = 0;
  y_ = 0;
  width_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegRes::~RegRes() {
  // @@protoc_insertion_point(destructor:vas.RegRes)
  SharedDtor();
}

void RegRes::SharedDtor() {
  if (reg_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reg_type_;
  }
  if (this != default_instance_) {
  }
}

void RegRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegRes_descriptor_;
}

const RegRes& RegRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

RegRes* RegRes::default_instance_ = NULL;

RegRes* RegRes::New() const {
  return new RegRes;
}

void RegRes::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RegRes*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(score_, height_);
    if (has_reg_type()) {
      if (reg_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        reg_type_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.RegRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string reg_type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_reg_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->reg_type().data(), this->reg_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "reg_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_score;
        break;
      }

      // optional float score = 2;
      case 2: {
        if (tag == 21) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_x;
        break;
      }

      // optional int32 x = 3;
      case 3: {
        if (tag == 24) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_y;
        break;
      }

      // optional int32 y = 4;
      case 4: {
        if (tag == 32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_width;
        break;
      }

      // optional int32 width = 5;
      case 5: {
        if (tag == 40) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_height;
        break;
      }

      // optional int32 height = 6;
      case 6: {
        if (tag == 48) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.RegRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.RegRes)
  return false;
#undef DO_
}

void RegRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.RegRes)
  // optional string reg_type = 1;
  if (has_reg_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->reg_type().data(), this->reg_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "reg_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->reg_type(), output);
  }

  // optional float score = 2;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->score(), output);
  }

  // optional int32 x = 3;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->x(), output);
  }

  // optional int32 y = 4;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->y(), output);
  }

  // optional int32 width = 5;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->width(), output);
  }

  // optional int32 height = 6;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->height(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.RegRes)
}

::google::protobuf::uint8* RegRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.RegRes)
  // optional string reg_type = 1;
  if (has_reg_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->reg_type().data(), this->reg_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "reg_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->reg_type(), target);
  }

  // optional float score = 2;
  if (has_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->score(), target);
  }

  // optional int32 x = 3;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->x(), target);
  }

  // optional int32 y = 4;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->y(), target);
  }

  // optional int32 width = 5;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->width(), target);
  }

  // optional int32 height = 6;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->height(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.RegRes)
  return target;
}

int RegRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string reg_type = 1;
    if (has_reg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->reg_type());
    }

    // optional float score = 2;
    if (has_score()) {
      total_size += 1 + 4;
    }

    // optional int32 x = 3;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 4;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional int32 width = 5;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // optional int32 height = 6;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegRes::MergeFrom(const RegRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reg_type()) {
      set_reg_type(from.reg_type());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegRes::CopyFrom(const RegRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegRes::IsInitialized() const {

  return true;
}

void RegRes::Swap(RegRes* other) {
  if (other != this) {
    std::swap(reg_type_, other->reg_type_);
    std::swap(score_, other->score_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegRes_descriptor_;
  metadata.reflection = RegRes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasResultParameter::kNodeIdFieldNumber;
const int VasResultParameter::kServiceIdFieldNumber;
const int VasResultParameter::kResultRectsFieldNumber;
const int VasResultParameter::kTimestampFieldNumber;
#endif  // !_MSC_VER

VasResultParameter::VasResultParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasResultParameter)
}

void VasResultParameter::InitAsDefaultInstance() {
}

VasResultParameter::VasResultParameter(const VasResultParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasResultParameter)
}

void VasResultParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  node_id_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasResultParameter::~VasResultParameter() {
  // @@protoc_insertion_point(destructor:vas.VasResultParameter)
  SharedDtor();
}

void VasResultParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (this != default_instance_) {
  }
}

void VasResultParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasResultParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasResultParameter_descriptor_;
}

const VasResultParameter& VasResultParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasResultParameter* VasResultParameter::default_instance_ = NULL;

VasResultParameter* VasResultParameter::New() const {
  return new VasResultParameter;
}

void VasResultParameter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VasResultParameter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 11) {
    ZR_(timestamp_, node_id_);
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  result_rects_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasResultParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasResultParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 node_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_id;
        break;
      }

      // optional string service_id = 2;
      case 2: {
        if (tag == 18) {
         parse_service_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_result_rects;
        break;
      }

      // repeated .vas.RegRes result_rects = 3;
      case 3: {
        if (tag == 26) {
         parse_result_rects:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_result_rects()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_result_rects;
        if (input->ExpectTag(32)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 4;
      case 4: {
        if (tag == 32) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasResultParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasResultParameter)
  return false;
#undef DO_
}

void VasResultParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasResultParameter)
  // optional int32 node_id = 1;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->node_id(), output);
  }

  // optional string service_id = 2;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->service_id(), output);
  }

  // repeated .vas.RegRes result_rects = 3;
  for (int i = 0; i < this->result_rects_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->result_rects(i), output);
  }

  // optional int64 timestamp = 4;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->timestamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasResultParameter)
}

::google::protobuf::uint8* VasResultParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasResultParameter)
  // optional int32 node_id = 1;
  if (has_node_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->node_id(), target);
  }

  // optional string service_id = 2;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->service_id(), target);
  }

  // repeated .vas.RegRes result_rects = 3;
  for (int i = 0; i < this->result_rects_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->result_rects(i), target);
  }

  // optional int64 timestamp = 4;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->timestamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasResultParameter)
  return target;
}

int VasResultParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional string service_id = 2;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional int64 timestamp = 4;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

  }
  // repeated .vas.RegRes result_rects = 3;
  total_size += 1 * this->result_rects_size();
  for (int i = 0; i < this->result_rects_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->result_rects(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasResultParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasResultParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasResultParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasResultParameter::MergeFrom(const VasResultParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  result_rects_.MergeFrom(from.result_rects_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasResultParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasResultParameter::CopyFrom(const VasResultParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasResultParameter::IsInitialized() const {

  return true;
}

void VasResultParameter::Swap(VasResultParameter* other) {
  if (other != this) {
    std::swap(node_id_, other->node_id_);
    std::swap(service_id_, other->service_id_);
    result_rects_.Swap(&other->result_rects_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasResultParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasResultParameter_descriptor_;
  metadata.reflection = VasResultParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasResult::kPsiNameFieldNumber;
const int VasResult::kParamsFieldNumber;
#endif  // !_MSC_VER

VasResult::VasResult()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasResult)
}

void VasResult::InitAsDefaultInstance() {
  params_ = const_cast< ::vas::VasResultParameter*>(&::vas::VasResultParameter::default_instance());
}

VasResult::VasResult(const VasResult& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasResult)
}

void VasResult::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  params_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasResult::~VasResult() {
  // @@protoc_insertion_point(destructor:vas.VasResult)
  SharedDtor();
}

void VasResult::SharedDtor() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (this != default_instance_) {
    delete params_;
  }
}

void VasResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasResult::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasResult_descriptor_;
}

const VasResult& VasResult::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasResult* VasResult::default_instance_ = NULL;

VasResult* VasResult::New() const {
  return new VasResult;
}

void VasResult::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_psi_name()) {
      if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        psi_name_->clear();
      }
    }
    if (has_params()) {
      if (params_ != NULL) params_->::vas::VasResultParameter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string psi_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_psi_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->psi_name().data(), this->psi_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "psi_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_params;
        break;
      }

      // optional .vas.VasResultParameter params = 2;
      case 2: {
        if (tag == 18) {
         parse_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_params()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasResult)
  return false;
#undef DO_
}

void VasResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasResult)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->psi_name(), output);
  }

  // optional .vas.VasResultParameter params = 2;
  if (has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->params(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasResult)
}

::google::protobuf::uint8* VasResult::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasResult)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->psi_name(), target);
  }

  // optional .vas.VasResultParameter params = 2;
  if (has_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->params(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasResult)
  return target;
}

int VasResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string psi_name = 1;
    if (has_psi_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->psi_name());
    }

    // optional .vas.VasResultParameter params = 2;
    if (has_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->params());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasResult::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasResult* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasResult*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasResult::MergeFrom(const VasResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_psi_name()) {
      set_psi_name(from.psi_name());
    }
    if (from.has_params()) {
      mutable_params()->::vas::VasResultParameter::MergeFrom(from.params());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasResult::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasResult::CopyFrom(const VasResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasResult::IsInitialized() const {

  return true;
}

void VasResult::Swap(VasResult* other) {
  if (other != this) {
    std::swap(psi_name_, other->psi_name_);
    std::swap(params_, other->params_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasResult::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasResult_descriptor_;
  metadata.reflection = VasResult_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasFeedbackParameter::kNodeIdFieldNumber;
const int VasFeedbackParameter::kServiceIdFieldNumber;
const int VasFeedbackParameter::kAddressTypeFieldNumber;
const int VasFeedbackParameter::kDeviceIdFieldNumber;
const int VasFeedbackParameter::kDeviceChannelFieldNumber;
const int VasFeedbackParameter::kAddressFieldNumber;
const int VasFeedbackParameter::kFeedbackCodeFieldNumber;
const int VasFeedbackParameter::kFeedbackInfoFieldNumber;
const int VasFeedbackParameter::kTimestampFieldNumber;
#endif  // !_MSC_VER

VasFeedbackParameter::VasFeedbackParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasFeedbackParameter)
}

void VasFeedbackParameter::InitAsDefaultInstance() {
}

VasFeedbackParameter::VasFeedbackParameter(const VasFeedbackParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasFeedbackParameter)
}

void VasFeedbackParameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  node_id_ = 0;
  service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  feedback_code_ = 0;
  feedback_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasFeedbackParameter::~VasFeedbackParameter() {
  // @@protoc_insertion_point(destructor:vas.VasFeedbackParameter)
  SharedDtor();
}

void VasFeedbackParameter::SharedDtor() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (address_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_type_;
  }
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_id_;
  }
  if (device_channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_channel_;
  }
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (feedback_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete feedback_info_;
  }
  if (this != default_instance_) {
  }
}

void VasFeedbackParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasFeedbackParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasFeedbackParameter_descriptor_;
}

const VasFeedbackParameter& VasFeedbackParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasFeedbackParameter* VasFeedbackParameter::default_instance_ = NULL;

VasFeedbackParameter* VasFeedbackParameter::New() const {
  return new VasFeedbackParameter;
}

void VasFeedbackParameter::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<VasFeedbackParameter*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(node_id_, feedback_code_);
    if (has_service_id()) {
      if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        service_id_->clear();
      }
    }
    if (has_address_type()) {
      if (address_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_type_->clear();
      }
    }
    if (has_device_id()) {
      if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        device_id_->clear();
      }
    }
    if (has_device_channel()) {
      if (device_channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        device_channel_->clear();
      }
    }
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
    if (has_feedback_info()) {
      if (feedback_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        feedback_info_->clear();
      }
    }
  }
  timestamp_ = GOOGLE_LONGLONG(0);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasFeedbackParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasFeedbackParameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 node_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_service_id;
        break;
      }

      // optional string service_id = 2;
      case 2: {
        if (tag == 18) {
         parse_service_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service_id().data(), this->service_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "service_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_address_type;
        break;
      }

      // optional string address_type = 3;
      case 3: {
        if (tag == 26) {
         parse_address_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address_type().data(), this->address_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "address_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_device_id;
        break;
      }

      // optional string device_id = 4;
      case 4: {
        if (tag == 34) {
         parse_device_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->device_id().data(), this->device_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "device_id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_device_channel;
        break;
      }

      // optional string device_channel = 5;
      case 5: {
        if (tag == 42) {
         parse_device_channel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_channel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->device_channel().data(), this->device_channel().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "device_channel");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_address;
        break;
      }

      // optional string address = 6;
      case 6: {
        if (tag == 50) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_feedback_code;
        break;
      }

      // optional int32 feedback_code = 7;
      case 7: {
        if (tag == 56) {
         parse_feedback_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &feedback_code_)));
          set_has_feedback_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_feedback_info;
        break;
      }

      // optional string feedback_info = 8;
      case 8: {
        if (tag == 66) {
         parse_feedback_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_feedback_info()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->feedback_info().data(), this->feedback_info().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "feedback_info");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_timestamp;
        break;
      }

      // optional int64 timestamp = 9;
      case 9: {
        if (tag == 72) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasFeedbackParameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasFeedbackParameter)
  return false;
#undef DO_
}

void VasFeedbackParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasFeedbackParameter)
  // optional int32 node_id = 1;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->node_id(), output);
  }

  // optional string service_id = 2;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->service_id(), output);
  }

  // optional string address_type = 3;
  if (has_address_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address_type().data(), this->address_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->address_type(), output);
  }

  // optional string device_id = 4;
  if (has_device_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_id().data(), this->device_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "device_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->device_id(), output);
  }

  // optional string device_channel = 5;
  if (has_device_channel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_channel().data(), this->device_channel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "device_channel");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->device_channel(), output);
  }

  // optional string address = 6;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->address(), output);
  }

  // optional int32 feedback_code = 7;
  if (has_feedback_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->feedback_code(), output);
  }

  // optional string feedback_info = 8;
  if (has_feedback_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->feedback_info().data(), this->feedback_info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "feedback_info");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->feedback_info(), output);
  }

  // optional int64 timestamp = 9;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->timestamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasFeedbackParameter)
}

::google::protobuf::uint8* VasFeedbackParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasFeedbackParameter)
  // optional int32 node_id = 1;
  if (has_node_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->node_id(), target);
  }

  // optional string service_id = 2;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service_id().data(), this->service_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "service_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->service_id(), target);
  }

  // optional string address_type = 3;
  if (has_address_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address_type().data(), this->address_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->address_type(), target);
  }

  // optional string device_id = 4;
  if (has_device_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_id().data(), this->device_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "device_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->device_id(), target);
  }

  // optional string device_channel = 5;
  if (has_device_channel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_channel().data(), this->device_channel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "device_channel");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->device_channel(), target);
  }

  // optional string address = 6;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->address(), target);
  }

  // optional int32 feedback_code = 7;
  if (has_feedback_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->feedback_code(), target);
  }

  // optional string feedback_info = 8;
  if (has_feedback_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->feedback_info().data(), this->feedback_info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "feedback_info");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->feedback_info(), target);
  }

  // optional int64 timestamp = 9;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->timestamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasFeedbackParameter)
  return target;
}

int VasFeedbackParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional string service_id = 2;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_id());
    }

    // optional string address_type = 3;
    if (has_address_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address_type());
    }

    // optional string device_id = 4;
    if (has_device_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_id());
    }

    // optional string device_channel = 5;
    if (has_device_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_channel());
    }

    // optional string address = 6;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional int32 feedback_code = 7;
    if (has_feedback_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->feedback_code());
    }

    // optional string feedback_info = 8;
    if (has_feedback_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->feedback_info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int64 timestamp = 9;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timestamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasFeedbackParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasFeedbackParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasFeedbackParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasFeedbackParameter::MergeFrom(const VasFeedbackParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_address_type()) {
      set_address_type(from.address_type());
    }
    if (from.has_device_id()) {
      set_device_id(from.device_id());
    }
    if (from.has_device_channel()) {
      set_device_channel(from.device_channel());
    }
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_feedback_code()) {
      set_feedback_code(from.feedback_code());
    }
    if (from.has_feedback_info()) {
      set_feedback_info(from.feedback_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasFeedbackParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasFeedbackParameter::CopyFrom(const VasFeedbackParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasFeedbackParameter::IsInitialized() const {

  return true;
}

void VasFeedbackParameter::Swap(VasFeedbackParameter* other) {
  if (other != this) {
    std::swap(node_id_, other->node_id_);
    std::swap(service_id_, other->service_id_);
    std::swap(address_type_, other->address_type_);
    std::swap(device_id_, other->device_id_);
    std::swap(device_channel_, other->device_channel_);
    std::swap(address_, other->address_);
    std::swap(feedback_code_, other->feedback_code_);
    std::swap(feedback_info_, other->feedback_info_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasFeedbackParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasFeedbackParameter_descriptor_;
  metadata.reflection = VasFeedbackParameter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VasFeedback::kPsiNameFieldNumber;
const int VasFeedback::kParamsFieldNumber;
#endif  // !_MSC_VER

VasFeedback::VasFeedback()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vas.VasFeedback)
}

void VasFeedback::InitAsDefaultInstance() {
  params_ = const_cast< ::vas::VasFeedbackParameter*>(&::vas::VasFeedbackParameter::default_instance());
}

VasFeedback::VasFeedback(const VasFeedback& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vas.VasFeedback)
}

void VasFeedback::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  params_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VasFeedback::~VasFeedback() {
  // @@protoc_insertion_point(destructor:vas.VasFeedback)
  SharedDtor();
}

void VasFeedback::SharedDtor() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (this != default_instance_) {
    delete params_;
  }
}

void VasFeedback::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VasFeedback::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VasFeedback_descriptor_;
}

const VasFeedback& VasFeedback::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_VasProto_2eprototxt();
  return *default_instance_;
}

VasFeedback* VasFeedback::default_instance_ = NULL;

VasFeedback* VasFeedback::New() const {
  return new VasFeedback;
}

void VasFeedback::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_psi_name()) {
      if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        psi_name_->clear();
      }
    }
    if (has_params()) {
      if (params_ != NULL) params_->::vas::VasFeedbackParameter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VasFeedback::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vas.VasFeedback)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string psi_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_psi_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->psi_name().data(), this->psi_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "psi_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_params;
        break;
      }

      // optional .vas.VasFeedbackParameter params = 2;
      case 2: {
        if (tag == 18) {
         parse_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_params()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vas.VasFeedback)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vas.VasFeedback)
  return false;
#undef DO_
}

void VasFeedback::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vas.VasFeedback)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->psi_name(), output);
  }

  // optional .vas.VasFeedbackParameter params = 2;
  if (has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->params(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:vas.VasFeedback)
}

::google::protobuf::uint8* VasFeedback::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:vas.VasFeedback)
  // optional string psi_name = 1;
  if (has_psi_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->psi_name().data(), this->psi_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "psi_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->psi_name(), target);
  }

  // optional .vas.VasFeedbackParameter params = 2;
  if (has_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->params(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vas.VasFeedback)
  return target;
}

int VasFeedback::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string psi_name = 1;
    if (has_psi_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->psi_name());
    }

    // optional .vas.VasFeedbackParameter params = 2;
    if (has_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->params());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VasFeedback::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VasFeedback* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VasFeedback*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VasFeedback::MergeFrom(const VasFeedback& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_psi_name()) {
      set_psi_name(from.psi_name());
    }
    if (from.has_params()) {
      mutable_params()->::vas::VasFeedbackParameter::MergeFrom(from.params());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VasFeedback::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VasFeedback::CopyFrom(const VasFeedback& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VasFeedback::IsInitialized() const {

  return true;
}

void VasFeedback::Swap(VasFeedback* other) {
  if (other != this) {
    std::swap(psi_name_, other->psi_name_);
    std::swap(params_, other->params_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VasFeedback::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VasFeedback_descriptor_;
  metadata.reflection = VasFeedback_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vas

// @@protoc_insertion_point(global_scope)
