// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: VasProto.prototxt

#ifndef PROTOBUF_VasProto_2eprototxt__INCLUDED
#define PROTOBUF_VasProto_2eprototxt__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace vas {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_VasProto_2eprototxt();
void protobuf_AssignDesc_VasProto_2eprototxt();
void protobuf_ShutdownFile_VasProto_2eprototxt();

class NvrParameter;
class NvrChannel;
class DecodeParameter;
class BgGuassianParameter;
class BgVibeParameter;
class BgOperation;
class BgParameter;
class ColorThreshold;
class FilterParameter;
class CaffeClassifierParameter;
class DetectParameter;
class SsdDetecterParameter;
class CaffeModelPath;
class SsdModelPath;
class ServiceParameter;
class SsdServiceParameter;
class NvrServiceParameter;
class ServiceList;
class SsdServiceList;
class NvrServiceList;
class VasComParameter;
class VasComputeNode;
class VasClientParameter;
class VasMsgFilterParam;
class VasHeartbeatParameter;
class VasHeartbeat;
class VasRetrunParamter;
class VasReturn;
class RegRes;
class VasResultParameter;
class VasResult;
class VasFeedbackParameter;
class VasFeedback;

enum DecodeMethod {
  DECODE_CPU = 0,
  DECODE_GPU = 1
};
bool DecodeMethod_IsValid(int value);
const DecodeMethod DecodeMethod_MIN = DECODE_CPU;
const DecodeMethod DecodeMethod_MAX = DECODE_GPU;
const int DecodeMethod_ARRAYSIZE = DecodeMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* DecodeMethod_descriptor();
inline const ::std::string& DecodeMethod_Name(DecodeMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    DecodeMethod_descriptor(), value);
}
inline bool DecodeMethod_Parse(
    const ::std::string& name, DecodeMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecodeMethod>(
    DecodeMethod_descriptor(), name, value);
}
enum VideoSource {
  VIDEO_FILE = 1,
  RTSP_STREAM = 2,
  NVR = 3
};
bool VideoSource_IsValid(int value);
const VideoSource VideoSource_MIN = VIDEO_FILE;
const VideoSource VideoSource_MAX = NVR;
const int VideoSource_ARRAYSIZE = VideoSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoSource_descriptor();
inline const ::std::string& VideoSource_Name(VideoSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoSource_descriptor(), value);
}
inline bool VideoSource_Parse(
    const ::std::string& name, VideoSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoSource>(
    VideoSource_descriptor(), name, value);
}
enum CamStatus {
  CAM_ONLINE = 1,
  CAM_OFFLINE = 2
};
bool CamStatus_IsValid(int value);
const CamStatus CamStatus_MIN = CAM_ONLINE;
const CamStatus CamStatus_MAX = CAM_OFFLINE;
const int CamStatus_ARRAYSIZE = CamStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* CamStatus_descriptor();
inline const ::std::string& CamStatus_Name(CamStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    CamStatus_descriptor(), value);
}
inline bool CamStatus_Parse(
    const ::std::string& name, CamStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CamStatus>(
    CamStatus_descriptor(), name, value);
}
enum StreamStatus {
  STREAM_UNKNOWN = 0,
  STREAM_CONNECTING = 1,
  STREAM_NORMAL = 2,
  STREAM_FINISH = 3,
  STREAM_STOP = 10,
  STREAM_PAUSE = 4,
  STREAM_NETWORK_FAULT = 5,
  FILE_FAULT = 6,
  STREAM_CPU_DECODE_FAULT = 8,
  STREAM_GPU_DECODE_FAULT = 9
};
bool StreamStatus_IsValid(int value);
const StreamStatus StreamStatus_MIN = STREAM_UNKNOWN;
const StreamStatus StreamStatus_MAX = STREAM_STOP;
const int StreamStatus_ARRAYSIZE = StreamStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamStatus_descriptor();
inline const ::std::string& StreamStatus_Name(StreamStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamStatus_descriptor(), value);
}
inline bool StreamStatus_Parse(
    const ::std::string& name, StreamStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamStatus>(
    StreamStatus_descriptor(), name, value);
}
enum BgStatus {
  BG_UNINIALIZED = 0,
  BG_SETUP = 1,
  BG_UPDATING = 2
};
bool BgStatus_IsValid(int value);
const BgStatus BgStatus_MIN = BG_UNINIALIZED;
const BgStatus BgStatus_MAX = BG_UPDATING;
const int BgStatus_ARRAYSIZE = BgStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* BgStatus_descriptor();
inline const ::std::string& BgStatus_Name(BgStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    BgStatus_descriptor(), value);
}
inline bool BgStatus_Parse(
    const ::std::string& name, BgStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BgStatus>(
    BgStatus_descriptor(), name, value);
}
enum BgMethod {
  VIBE_CPU = 0,
  VIBE_GPU = 1,
  GUASSIAN_CPU = 2,
  GUASSIAN_GPU = 3
};
bool BgMethod_IsValid(int value);
const BgMethod BgMethod_MIN = VIBE_CPU;
const BgMethod BgMethod_MAX = GUASSIAN_GPU;
const int BgMethod_ARRAYSIZE = BgMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* BgMethod_descriptor();
inline const ::std::string& BgMethod_Name(BgMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    BgMethod_descriptor(), value);
}
inline bool BgMethod_Parse(
    const ::std::string& name, BgMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BgMethod>(
    BgMethod_descriptor(), name, value);
}
enum FilterMethod {
  FRAME_COLOR_CPU = 0,
  FRAME_COLOR_GPU = 1,
  CONTOUR_COLOR = 3,
  PURE_CONTOUR_AREA = 4
};
bool FilterMethod_IsValid(int value);
const FilterMethod FilterMethod_MIN = FRAME_COLOR_CPU;
const FilterMethod FilterMethod_MAX = PURE_CONTOUR_AREA;
const int FilterMethod_ARRAYSIZE = FilterMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* FilterMethod_descriptor();
inline const ::std::string& FilterMethod_Name(FilterMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    FilterMethod_descriptor(), value);
}
inline bool FilterMethod_Parse(
    const ::std::string& name, FilterMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FilterMethod>(
    FilterMethod_descriptor(), name, value);
}
enum FilterType {
  SMOKE_FILTER = 1,
  FIRE_FILTER = 2
};
bool FilterType_IsValid(int value);
const FilterType FilterType_MIN = SMOKE_FILTER;
const FilterType FilterType_MAX = FIRE_FILTER;
const int FilterType_ARRAYSIZE = FilterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FilterType_descriptor();
inline const ::std::string& FilterType_Name(FilterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FilterType_descriptor(), value);
}
inline bool FilterType_Parse(
    const ::std::string& name, FilterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FilterType>(
    FilterType_descriptor(), name, value);
}
enum DetectStatus {
  DETECT_ON = 1,
  DETECT_OFF = 2,
  DETECT_PAUSE = 3
};
bool DetectStatus_IsValid(int value);
const DetectStatus DetectStatus_MIN = DETECT_ON;
const DetectStatus DetectStatus_MAX = DETECT_PAUSE;
const int DetectStatus_ARRAYSIZE = DetectStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectStatus_descriptor();
inline const ::std::string& DetectStatus_Name(DetectStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectStatus_descriptor(), value);
}
inline bool DetectStatus_Parse(
    const ::std::string& name, DetectStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectStatus>(
    DetectStatus_descriptor(), name, value);
}
enum ServiceStatus {
  SERVICE_UNKNOWN = 0,
  SERVICE_NORMAL = 1,
  SERVICE_PAUSE = 2,
  SERVICE_STREAM_FALUT = 3,
  SERVICE_DETECTER_FALUT = 4
};
bool ServiceStatus_IsValid(int value);
const ServiceStatus ServiceStatus_MIN = SERVICE_UNKNOWN;
const ServiceStatus ServiceStatus_MAX = SERVICE_DETECTER_FALUT;
const int ServiceStatus_ARRAYSIZE = ServiceStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceStatus_descriptor();
inline const ::std::string& ServiceStatus_Name(ServiceStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceStatus_descriptor(), value);
}
inline bool ServiceStatus_Parse(
    const ::std::string& name, ServiceStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceStatus>(
    ServiceStatus_descriptor(), name, value);
}
enum ServiceCommandReply {
  SERVICE_START_SUCCESS = 1,
  SERVICE_START_FALIED = 2,
  SERVICE_STOP_SUCESS = 3,
  SERVICE_STOP_FALIED = 4,
  SERVICE_PAUSE_SUCCESS = 5,
  SERVICE_PAUSE_FAILED = 6,
  SERVICE_RESUME_SUCCESS = 7,
  SERVICE_RESUME_FAILED = 8
};
bool ServiceCommandReply_IsValid(int value);
const ServiceCommandReply ServiceCommandReply_MIN = SERVICE_START_SUCCESS;
const ServiceCommandReply ServiceCommandReply_MAX = SERVICE_RESUME_FAILED;
const int ServiceCommandReply_ARRAYSIZE = ServiceCommandReply_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceCommandReply_descriptor();
inline const ::std::string& ServiceCommandReply_Name(ServiceCommandReply value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceCommandReply_descriptor(), value);
}
inline bool ServiceCommandReply_Parse(
    const ::std::string& name, ServiceCommandReply* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceCommandReply>(
    ServiceCommandReply_descriptor(), name, value);
}
enum RegMsgSubscribe {
  SUBSCRIBE_ON = 1,
  SUBSCRIBE_OFF = 2
};
bool RegMsgSubscribe_IsValid(int value);
const RegMsgSubscribe RegMsgSubscribe_MIN = SUBSCRIBE_ON;
const RegMsgSubscribe RegMsgSubscribe_MAX = SUBSCRIBE_OFF;
const int RegMsgSubscribe_ARRAYSIZE = RegMsgSubscribe_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegMsgSubscribe_descriptor();
inline const ::std::string& RegMsgSubscribe_Name(RegMsgSubscribe value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegMsgSubscribe_descriptor(), value);
}
inline bool RegMsgSubscribe_Parse(
    const ::std::string& name, RegMsgSubscribe* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegMsgSubscribe>(
    RegMsgSubscribe_descriptor(), name, value);
}
enum EnAppState {
  ST_STARTED = 1,
  ST_STOPPED = 2
};
bool EnAppState_IsValid(int value);
const EnAppState EnAppState_MIN = ST_STARTED;
const EnAppState EnAppState_MAX = ST_STOPPED;
const int EnAppState_ARRAYSIZE = EnAppState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnAppState_descriptor();
inline const ::std::string& EnAppState_Name(EnAppState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnAppState_descriptor(), value);
}
inline bool EnAppState_Parse(
    const ::std::string& name, EnAppState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnAppState>(
    EnAppState_descriptor(), name, value);
}
// ===================================================================

class NvrParameter : public ::google::protobuf::Message {
 public:
  NvrParameter();
  virtual ~NvrParameter();

  NvrParameter(const NvrParameter& from);

  inline NvrParameter& operator=(const NvrParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NvrParameter& default_instance();

  void Swap(NvrParameter* other);

  // implements Message ----------------------------------------------

  NvrParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NvrParameter& from);
  void MergeFrom(const NvrParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 7;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 7;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint64 port = 3 [default = 8000];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint64 port() const;
  inline void set_port(::google::protobuf::uint64 value);

  // optional uint64 connect_timeout = 4 [default = 500000];
  inline bool has_connect_timeout() const;
  inline void clear_connect_timeout();
  static const int kConnectTimeoutFieldNumber = 4;
  inline ::google::protobuf::uint64 connect_timeout() const;
  inline void set_connect_timeout(::google::protobuf::uint64 value);

  // optional uint64 reconnect_time = 5 [default = 1000000];
  inline bool has_reconnect_time() const;
  inline void clear_reconnect_time();
  static const int kReconnectTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 reconnect_time() const;
  inline void set_reconnect_time(::google::protobuf::uint64 value);

  // optional uint64 check_interval = 6 [default = 5000];
  inline bool has_check_interval() const;
  inline void clear_check_interval();
  static const int kCheckIntervalFieldNumber = 6;
  inline ::google::protobuf::uint64 check_interval() const;
  inline void set_check_interval(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vas.NvrParameter)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_connect_timeout();
  inline void clear_has_connect_timeout();
  inline void set_has_reconnect_time();
  inline void clear_has_reconnect_time();
  inline void set_has_check_interval();
  inline void clear_has_check_interval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::std::string* user_name_;
  ::std::string* password_;
  ::google::protobuf::uint64 port_;
  ::google::protobuf::uint64 connect_timeout_;
  ::google::protobuf::uint64 reconnect_time_;
  ::google::protobuf::uint64 check_interval_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static NvrParameter* default_instance_;
};
// -------------------------------------------------------------------

class NvrChannel : public ::google::protobuf::Message {
 public:
  NvrChannel();
  virtual ~NvrChannel();

  NvrChannel(const NvrChannel& from);

  inline NvrChannel& operator=(const NvrChannel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NvrChannel& default_instance();

  void Swap(NvrChannel* other);

  // implements Message ----------------------------------------------

  NvrChannel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NvrChannel& from);
  void MergeFrom(const NvrChannel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional int32 channel_no = 2 [default = 0];
  inline bool has_channel_no() const;
  inline void clear_channel_no();
  static const int kChannelNoFieldNumber = 2;
  inline ::google::protobuf::int32 channel_no() const;
  inline void set_channel_no(::google::protobuf::int32 value);

  // optional .vas.CamStatus cam_status = 3 [default = CAM_OFFLINE];
  inline bool has_cam_status() const;
  inline void clear_cam_status();
  static const int kCamStatusFieldNumber = 3;
  inline ::vas::CamStatus cam_status() const;
  inline void set_cam_status(::vas::CamStatus value);

  // optional int32 interval_time = 4 [default = 20];
  inline bool has_interval_time() const;
  inline void clear_interval_time();
  static const int kIntervalTimeFieldNumber = 4;
  inline ::google::protobuf::int32 interval_time() const;
  inline void set_interval_time(::google::protobuf::int32 value);

  // optional int32 dst_width = 5 [default = 720];
  inline bool has_dst_width() const;
  inline void clear_dst_width();
  static const int kDstWidthFieldNumber = 5;
  inline ::google::protobuf::int32 dst_width() const;
  inline void set_dst_width(::google::protobuf::int32 value);

  // optional int32 dst_height = 6 [default = 576];
  inline bool has_dst_height() const;
  inline void clear_dst_height();
  static const int kDstHeightFieldNumber = 6;
  inline ::google::protobuf::int32 dst_height() const;
  inline void set_dst_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vas.NvrChannel)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_channel_no();
  inline void clear_has_channel_no();
  inline void set_has_cam_status();
  inline void clear_has_cam_status();
  inline void set_has_interval_time();
  inline void clear_has_interval_time();
  inline void set_has_dst_width();
  inline void clear_has_dst_width();
  inline void set_has_dst_height();
  inline void clear_has_dst_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::google::protobuf::int32 channel_no_;
  int cam_status_;
  ::google::protobuf::int32 interval_time_;
  ::google::protobuf::int32 dst_width_;
  ::google::protobuf::int32 dst_height_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static NvrChannel* default_instance_;
};
// -------------------------------------------------------------------

class DecodeParameter : public ::google::protobuf::Message {
 public:
  DecodeParameter();
  virtual ~DecodeParameter();

  DecodeParameter(const DecodeParameter& from);

  inline DecodeParameter& operator=(const DecodeParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecodeParameter& default_instance();

  void Swap(DecodeParameter* other);

  // implements Message ----------------------------------------------

  DecodeParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecodeParameter& from);
  void MergeFrom(const DecodeParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional .vas.DecodeMethod decode_method = 2 [default = DECODE_CPU];
  inline bool has_decode_method() const;
  inline void clear_decode_method();
  static const int kDecodeMethodFieldNumber = 2;
  inline ::vas::DecodeMethod decode_method() const;
  inline void set_decode_method(::vas::DecodeMethod value);

  // optional uint32 dst_width = 3 [default = 800];
  inline bool has_dst_width() const;
  inline void clear_dst_width();
  static const int kDstWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 dst_width() const;
  inline void set_dst_width(::google::protobuf::uint32 value);

  // optional uint32 dst_height = 4 [default = 576];
  inline bool has_dst_height() const;
  inline void clear_dst_height();
  static const int kDstHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 dst_height() const;
  inline void set_dst_height(::google::protobuf::uint32 value);

  // optional uint32 interval_time = 5 [default = 20];
  inline bool has_interval_time() const;
  inline void clear_interval_time();
  static const int kIntervalTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 interval_time() const;
  inline void set_interval_time(::google::protobuf::uint32 value);

  // optional uint32 max_reconnect_times = 6 [default = 3];
  inline bool has_max_reconnect_times() const;
  inline void clear_max_reconnect_times();
  static const int kMaxReconnectTimesFieldNumber = 6;
  inline ::google::protobuf::uint32 max_reconnect_times() const;
  inline void set_max_reconnect_times(::google::protobuf::uint32 value);

  // optional uint32 reconnect_sleep_times = 14 [default = 10000];
  inline bool has_reconnect_sleep_times() const;
  inline void clear_reconnect_sleep_times();
  static const int kReconnectSleepTimesFieldNumber = 14;
  inline ::google::protobuf::uint32 reconnect_sleep_times() const;
  inline void set_reconnect_sleep_times(::google::protobuf::uint32 value);

  // optional uint32 max_decode_error_frames = 15 [default = 500];
  inline bool has_max_decode_error_frames() const;
  inline void clear_max_decode_error_frames();
  static const int kMaxDecodeErrorFramesFieldNumber = 15;
  inline ::google::protobuf::uint32 max_decode_error_frames() const;
  inline void set_max_decode_error_frames(::google::protobuf::uint32 value);

  // optional string url = 7;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 7;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional .vas.StreamStatus stream_status = 9 [default = STREAM_UNKNOWN];
  inline bool has_stream_status() const;
  inline void clear_stream_status();
  static const int kStreamStatusFieldNumber = 9;
  inline ::vas::StreamStatus stream_status() const;
  inline void set_stream_status(::vas::StreamStatus value);

  // optional uint64 total_ms = 10 [default = 1000000000];
  inline bool has_total_ms() const;
  inline void clear_total_ms();
  static const int kTotalMsFieldNumber = 10;
  inline ::google::protobuf::uint64 total_ms() const;
  inline void set_total_ms(::google::protobuf::uint64 value);

  // optional uint64 connect_timeout = 11 [default = 500000];
  inline bool has_connect_timeout() const;
  inline void clear_connect_timeout();
  static const int kConnectTimeoutFieldNumber = 11;
  inline ::google::protobuf::uint64 connect_timeout() const;
  inline void set_connect_timeout(::google::protobuf::uint64 value);

  // optional .vas.VideoSource video_source = 12;
  inline bool has_video_source() const;
  inline void clear_video_source();
  static const int kVideoSourceFieldNumber = 12;
  inline ::vas::VideoSource video_source() const;
  inline void set_video_source(::vas::VideoSource value);

  // optional bool print_decode_count = 13 [default = false];
  inline bool has_print_decode_count() const;
  inline void clear_print_decode_count();
  static const int kPrintDecodeCountFieldNumber = 13;
  inline bool print_decode_count() const;
  inline void set_print_decode_count(bool value);

  // @@protoc_insertion_point(class_scope:vas.DecodeParameter)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_decode_method();
  inline void clear_has_decode_method();
  inline void set_has_dst_width();
  inline void clear_has_dst_width();
  inline void set_has_dst_height();
  inline void clear_has_dst_height();
  inline void set_has_interval_time();
  inline void clear_has_interval_time();
  inline void set_has_max_reconnect_times();
  inline void clear_has_max_reconnect_times();
  inline void set_has_reconnect_sleep_times();
  inline void clear_has_reconnect_sleep_times();
  inline void set_has_max_decode_error_frames();
  inline void clear_has_max_decode_error_frames();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_stream_status();
  inline void clear_has_stream_status();
  inline void set_has_total_ms();
  inline void clear_has_total_ms();
  inline void set_has_connect_timeout();
  inline void clear_has_connect_timeout();
  inline void set_has_video_source();
  inline void clear_has_video_source();
  inline void set_has_print_decode_count();
  inline void clear_has_print_decode_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  int decode_method_;
  ::google::protobuf::uint32 dst_width_;
  ::google::protobuf::uint32 dst_height_;
  ::google::protobuf::uint32 interval_time_;
  ::google::protobuf::uint32 max_reconnect_times_;
  ::google::protobuf::uint32 reconnect_sleep_times_;
  ::std::string* url_;
  ::google::protobuf::uint32 max_decode_error_frames_;
  int stream_status_;
  ::google::protobuf::uint64 total_ms_;
  ::google::protobuf::uint64 connect_timeout_;
  int video_source_;
  bool print_decode_count_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static DecodeParameter* default_instance_;
};
// -------------------------------------------------------------------

class BgGuassianParameter : public ::google::protobuf::Message {
 public:
  BgGuassianParameter();
  virtual ~BgGuassianParameter();

  BgGuassianParameter(const BgGuassianParameter& from);

  inline BgGuassianParameter& operator=(const BgGuassianParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BgGuassianParameter& default_instance();

  void Swap(BgGuassianParameter* other);

  // implements Message ----------------------------------------------

  BgGuassianParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BgGuassianParameter& from);
  void MergeFrom(const BgGuassianParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num_history = 1 [default = 20];
  inline bool has_num_history() const;
  inline void clear_num_history();
  static const int kNumHistoryFieldNumber = 1;
  inline ::google::protobuf::uint32 num_history() const;
  inline void set_num_history(::google::protobuf::uint32 value);

  // optional uint32 var_threshold = 2 [default = 4];
  inline bool has_var_threshold() const;
  inline void clear_var_threshold();
  static const int kVarThresholdFieldNumber = 2;
  inline ::google::protobuf::uint32 var_threshold() const;
  inline void set_var_threshold(::google::protobuf::uint32 value);

  // optional bool shadow_detection = 3 [default = true];
  inline bool has_shadow_detection() const;
  inline void clear_shadow_detection();
  static const int kShadowDetectionFieldNumber = 3;
  inline bool shadow_detection() const;
  inline void set_shadow_detection(bool value);

  // optional float learn_rate = 4 [default = 0.01];
  inline bool has_learn_rate() const;
  inline void clear_learn_rate();
  static const int kLearnRateFieldNumber = 4;
  inline float learn_rate() const;
  inline void set_learn_rate(float value);

  // @@protoc_insertion_point(class_scope:vas.BgGuassianParameter)
 private:
  inline void set_has_num_history();
  inline void clear_has_num_history();
  inline void set_has_var_threshold();
  inline void clear_has_var_threshold();
  inline void set_has_shadow_detection();
  inline void clear_has_shadow_detection();
  inline void set_has_learn_rate();
  inline void clear_has_learn_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_history_;
  ::google::protobuf::uint32 var_threshold_;
  bool shadow_detection_;
  float learn_rate_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static BgGuassianParameter* default_instance_;
};
// -------------------------------------------------------------------

class BgVibeParameter : public ::google::protobuf::Message {
 public:
  BgVibeParameter();
  virtual ~BgVibeParameter();

  BgVibeParameter(const BgVibeParameter& from);

  inline BgVibeParameter& operator=(const BgVibeParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BgVibeParameter& default_instance();

  void Swap(BgVibeParameter* other);

  // implements Message ----------------------------------------------

  BgVibeParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BgVibeParameter& from);
  void MergeFrom(const BgVibeParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num_samples = 1 [default = 20];
  inline bool has_num_samples() const;
  inline void clear_num_samples();
  static const int kNumSamplesFieldNumber = 1;
  inline ::google::protobuf::uint32 num_samples() const;
  inline void set_num_samples(::google::protobuf::uint32 value);

  // optional uint32 min_match = 2 [default = 4];
  inline bool has_min_match() const;
  inline void clear_min_match();
  static const int kMinMatchFieldNumber = 2;
  inline ::google::protobuf::uint32 min_match() const;
  inline void set_min_match(::google::protobuf::uint32 value);

  // optional uint32 radius = 3 [default = 10];
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 3;
  inline ::google::protobuf::uint32 radius() const;
  inline void set_radius(::google::protobuf::uint32 value);

  // optional uint32 subsample_factor = 4 [default = 16];
  inline bool has_subsample_factor() const;
  inline void clear_subsample_factor();
  static const int kSubsampleFactorFieldNumber = 4;
  inline ::google::protobuf::uint32 subsample_factor() const;
  inline void set_subsample_factor(::google::protobuf::uint32 value);

  // optional uint32 bg2_delay = 5 [default = 50];
  inline bool has_bg2_delay() const;
  inline void clear_bg2_delay();
  static const int kBg2DelayFieldNumber = 5;
  inline ::google::protobuf::uint32 bg2_delay() const;
  inline void set_bg2_delay(::google::protobuf::uint32 value);

  // optional uint32 max_mismatch_count = 6 [default = 50];
  inline bool has_max_mismatch_count() const;
  inline void clear_max_mismatch_count();
  static const int kMaxMismatchCountFieldNumber = 6;
  inline ::google::protobuf::uint32 max_mismatch_count() const;
  inline void set_max_mismatch_count(::google::protobuf::uint32 value);

  // optional bool double_bg = 7 [default = false];
  inline bool has_double_bg() const;
  inline void clear_double_bg();
  static const int kDoubleBgFieldNumber = 7;
  inline bool double_bg() const;
  inline void set_double_bg(bool value);

  // optional float learn_rate = 8 [default = 0.5];
  inline bool has_learn_rate() const;
  inline void clear_learn_rate();
  static const int kLearnRateFieldNumber = 8;
  inline float learn_rate() const;
  inline void set_learn_rate(float value);

  // @@protoc_insertion_point(class_scope:vas.BgVibeParameter)
 private:
  inline void set_has_num_samples();
  inline void clear_has_num_samples();
  inline void set_has_min_match();
  inline void clear_has_min_match();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_subsample_factor();
  inline void clear_has_subsample_factor();
  inline void set_has_bg2_delay();
  inline void clear_has_bg2_delay();
  inline void set_has_max_mismatch_count();
  inline void clear_has_max_mismatch_count();
  inline void set_has_double_bg();
  inline void clear_has_double_bg();
  inline void set_has_learn_rate();
  inline void clear_has_learn_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_samples_;
  ::google::protobuf::uint32 min_match_;
  ::google::protobuf::uint32 radius_;
  ::google::protobuf::uint32 subsample_factor_;
  ::google::protobuf::uint32 bg2_delay_;
  ::google::protobuf::uint32 max_mismatch_count_;
  bool double_bg_;
  float learn_rate_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static BgVibeParameter* default_instance_;
};
// -------------------------------------------------------------------

class BgOperation : public ::google::protobuf::Message {
 public:
  BgOperation();
  virtual ~BgOperation();

  BgOperation(const BgOperation& from);

  inline BgOperation& operator=(const BgOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BgOperation& default_instance();

  void Swap(BgOperation* other);

  // implements Message ----------------------------------------------

  BgOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BgOperation& from);
  void MergeFrom(const BgOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 morphology_open_times = 1 [default = 1];
  inline bool has_morphology_open_times() const;
  inline void clear_morphology_open_times();
  static const int kMorphologyOpenTimesFieldNumber = 1;
  inline ::google::protobuf::uint32 morphology_open_times() const;
  inline void set_morphology_open_times(::google::protobuf::uint32 value);

  // optional uint32 dilate_times = 2 [default = 1];
  inline bool has_dilate_times() const;
  inline void clear_dilate_times();
  static const int kDilateTimesFieldNumber = 2;
  inline ::google::protobuf::uint32 dilate_times() const;
  inline void set_dilate_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vas.BgOperation)
 private:
  inline void set_has_morphology_open_times();
  inline void clear_has_morphology_open_times();
  inline void set_has_dilate_times();
  inline void clear_has_dilate_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 morphology_open_times_;
  ::google::protobuf::uint32 dilate_times_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static BgOperation* default_instance_;
};
// -------------------------------------------------------------------

class BgParameter : public ::google::protobuf::Message {
 public:
  BgParameter();
  virtual ~BgParameter();

  BgParameter(const BgParameter& from);

  inline BgParameter& operator=(const BgParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BgParameter& default_instance();

  void Swap(BgParameter* other);

  // implements Message ----------------------------------------------

  BgParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BgParameter& from);
  void MergeFrom(const BgParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vas.BgMethod bg_method = 1 [default = GUASSIAN_CPU];
  inline bool has_bg_method() const;
  inline void clear_bg_method();
  static const int kBgMethodFieldNumber = 1;
  inline ::vas::BgMethod bg_method() const;
  inline void set_bg_method(::vas::BgMethod value);

  // optional float stable_threshold = 2 [default = 0.5];
  inline bool has_stable_threshold() const;
  inline void clear_stable_threshold();
  static const int kStableThresholdFieldNumber = 2;
  inline float stable_threshold() const;
  inline void set_stable_threshold(float value);

  // optional .vas.BgGuassianParameter guassian_parameter = 3;
  inline bool has_guassian_parameter() const;
  inline void clear_guassian_parameter();
  static const int kGuassianParameterFieldNumber = 3;
  inline const ::vas::BgGuassianParameter& guassian_parameter() const;
  inline ::vas::BgGuassianParameter* mutable_guassian_parameter();
  inline ::vas::BgGuassianParameter* release_guassian_parameter();
  inline void set_allocated_guassian_parameter(::vas::BgGuassianParameter* guassian_parameter);

  // optional .vas.BgVibeParameter vibe_parameter = 4;
  inline bool has_vibe_parameter() const;
  inline void clear_vibe_parameter();
  static const int kVibeParameterFieldNumber = 4;
  inline const ::vas::BgVibeParameter& vibe_parameter() const;
  inline ::vas::BgVibeParameter* mutable_vibe_parameter();
  inline ::vas::BgVibeParameter* release_vibe_parameter();
  inline void set_allocated_vibe_parameter(::vas::BgVibeParameter* vibe_parameter);

  // optional .vas.BgOperation bg_operation = 5;
  inline bool has_bg_operation() const;
  inline void clear_bg_operation();
  static const int kBgOperationFieldNumber = 5;
  inline const ::vas::BgOperation& bg_operation() const;
  inline ::vas::BgOperation* mutable_bg_operation();
  inline ::vas::BgOperation* release_bg_operation();
  inline void set_allocated_bg_operation(::vas::BgOperation* bg_operation);

  // optional .vas.BgStatus bg_status = 6 [default = BG_UNINIALIZED];
  inline bool has_bg_status() const;
  inline void clear_bg_status();
  static const int kBgStatusFieldNumber = 6;
  inline ::vas::BgStatus bg_status() const;
  inline void set_bg_status(::vas::BgStatus value);

  // optional uint32 bg_width = 7 [default = 420];
  inline bool has_bg_width() const;
  inline void clear_bg_width();
  static const int kBgWidthFieldNumber = 7;
  inline ::google::protobuf::uint32 bg_width() const;
  inline void set_bg_width(::google::protobuf::uint32 value);

  // optional uint32 bg_height = 8 [default = 320];
  inline bool has_bg_height() const;
  inline void clear_bg_height();
  static const int kBgHeightFieldNumber = 8;
  inline ::google::protobuf::uint32 bg_height() const;
  inline void set_bg_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vas.BgParameter)
 private:
  inline void set_has_bg_method();
  inline void clear_has_bg_method();
  inline void set_has_stable_threshold();
  inline void clear_has_stable_threshold();
  inline void set_has_guassian_parameter();
  inline void clear_has_guassian_parameter();
  inline void set_has_vibe_parameter();
  inline void clear_has_vibe_parameter();
  inline void set_has_bg_operation();
  inline void clear_has_bg_operation();
  inline void set_has_bg_status();
  inline void clear_has_bg_status();
  inline void set_has_bg_width();
  inline void clear_has_bg_width();
  inline void set_has_bg_height();
  inline void clear_has_bg_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int bg_method_;
  float stable_threshold_;
  ::vas::BgGuassianParameter* guassian_parameter_;
  ::vas::BgVibeParameter* vibe_parameter_;
  ::vas::BgOperation* bg_operation_;
  int bg_status_;
  ::google::protobuf::uint32 bg_width_;
  ::google::protobuf::uint32 bg_height_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static BgParameter* default_instance_;
};
// -------------------------------------------------------------------

class ColorThreshold : public ::google::protobuf::Message {
 public:
  ColorThreshold();
  virtual ~ColorThreshold();

  ColorThreshold(const ColorThreshold& from);

  inline ColorThreshold& operator=(const ColorThreshold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColorThreshold& default_instance();

  void Swap(ColorThreshold* other);

  // implements Message ----------------------------------------------

  ColorThreshold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColorThreshold& from);
  void MergeFrom(const ColorThreshold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lower = 1 [default = 0];
  inline bool has_lower() const;
  inline void clear_lower();
  static const int kLowerFieldNumber = 1;
  inline float lower() const;
  inline void set_lower(float value);

  // optional float upper = 2 [default = 255];
  inline bool has_upper() const;
  inline void clear_upper();
  static const int kUpperFieldNumber = 2;
  inline float upper() const;
  inline void set_upper(float value);

  // @@protoc_insertion_point(class_scope:vas.ColorThreshold)
 private:
  inline void set_has_lower();
  inline void clear_has_lower();
  inline void set_has_upper();
  inline void clear_has_upper();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float lower_;
  float upper_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static ColorThreshold* default_instance_;
};
// -------------------------------------------------------------------

class FilterParameter : public ::google::protobuf::Message {
 public:
  FilterParameter();
  virtual ~FilterParameter();

  FilterParameter(const FilterParameter& from);

  inline FilterParameter& operator=(const FilterParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterParameter& default_instance();

  void Swap(FilterParameter* other);

  // implements Message ----------------------------------------------

  FilterParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterParameter& from);
  void MergeFrom(const FilterParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 contour_area_threshold = 1 [default = 500];
  inline bool has_contour_area_threshold() const;
  inline void clear_contour_area_threshold();
  static const int kContourAreaThresholdFieldNumber = 1;
  inline ::google::protobuf::uint32 contour_area_threshold() const;
  inline void set_contour_area_threshold(::google::protobuf::uint32 value);

  // optional uint32 contour_perimeter_threshold = 2 [default = 10];
  inline bool has_contour_perimeter_threshold() const;
  inline void clear_contour_perimeter_threshold();
  static const int kContourPerimeterThresholdFieldNumber = 2;
  inline ::google::protobuf::uint32 contour_perimeter_threshold() const;
  inline void set_contour_perimeter_threshold(::google::protobuf::uint32 value);

  // optional float area_perimeter_ratio_threshold = 3 [default = 0.01];
  inline bool has_area_perimeter_ratio_threshold() const;
  inline void clear_area_perimeter_ratio_threshold();
  static const int kAreaPerimeterRatioThresholdFieldNumber = 3;
  inline float area_perimeter_ratio_threshold() const;
  inline void set_area_perimeter_ratio_threshold(float value);

  // optional .vas.FilterType filter_type = 12 [default = SMOKE_FILTER];
  inline bool has_filter_type() const;
  inline void clear_filter_type();
  static const int kFilterTypeFieldNumber = 12;
  inline ::vas::FilterType filter_type() const;
  inline void set_filter_type(::vas::FilterType value);

  // optional .vas.ColorThreshold rgb_th_1 = 4;
  inline bool has_rgb_th_1() const;
  inline void clear_rgb_th_1();
  static const int kRgbTh1FieldNumber = 4;
  inline const ::vas::ColorThreshold& rgb_th_1() const;
  inline ::vas::ColorThreshold* mutable_rgb_th_1();
  inline ::vas::ColorThreshold* release_rgb_th_1();
  inline void set_allocated_rgb_th_1(::vas::ColorThreshold* rgb_th_1);

  // optional .vas.ColorThreshold rgb_th_2 = 5;
  inline bool has_rgb_th_2() const;
  inline void clear_rgb_th_2();
  static const int kRgbTh2FieldNumber = 5;
  inline const ::vas::ColorThreshold& rgb_th_2() const;
  inline ::vas::ColorThreshold* mutable_rgb_th_2();
  inline ::vas::ColorThreshold* release_rgb_th_2();
  inline void set_allocated_rgb_th_2(::vas::ColorThreshold* rgb_th_2);

  // optional .vas.ColorThreshold ycbcr_th_1 = 6;
  inline bool has_ycbcr_th_1() const;
  inline void clear_ycbcr_th_1();
  static const int kYcbcrTh1FieldNumber = 6;
  inline const ::vas::ColorThreshold& ycbcr_th_1() const;
  inline ::vas::ColorThreshold* mutable_ycbcr_th_1();
  inline ::vas::ColorThreshold* release_ycbcr_th_1();
  inline void set_allocated_ycbcr_th_1(::vas::ColorThreshold* ycbcr_th_1);

  // optional .vas.ColorThreshold ycbcr_th_2 = 7;
  inline bool has_ycbcr_th_2() const;
  inline void clear_ycbcr_th_2();
  static const int kYcbcrTh2FieldNumber = 7;
  inline const ::vas::ColorThreshold& ycbcr_th_2() const;
  inline ::vas::ColorThreshold* mutable_ycbcr_th_2();
  inline ::vas::ColorThreshold* release_ycbcr_th_2();
  inline void set_allocated_ycbcr_th_2(::vas::ColorThreshold* ycbcr_th_2);

  // optional float color_fit_ratio = 8 [default = 0.5];
  inline bool has_color_fit_ratio() const;
  inline void clear_color_fit_ratio();
  static const int kColorFitRatioFieldNumber = 8;
  inline float color_fit_ratio() const;
  inline void set_color_fit_ratio(float value);

  // optional uint32 filter_width = 9 [default = 420];
  inline bool has_filter_width() const;
  inline void clear_filter_width();
  static const int kFilterWidthFieldNumber = 9;
  inline ::google::protobuf::uint32 filter_width() const;
  inline void set_filter_width(::google::protobuf::uint32 value);

  // optional uint32 filter_height = 10 [default = 320];
  inline bool has_filter_height() const;
  inline void clear_filter_height();
  static const int kFilterHeightFieldNumber = 10;
  inline ::google::protobuf::uint32 filter_height() const;
  inline void set_filter_height(::google::protobuf::uint32 value);

  // optional .vas.FilterMethod filter_method = 11 [default = PURE_CONTOUR_AREA];
  inline bool has_filter_method() const;
  inline void clear_filter_method();
  static const int kFilterMethodFieldNumber = 11;
  inline ::vas::FilterMethod filter_method() const;
  inline void set_filter_method(::vas::FilterMethod value);

  // @@protoc_insertion_point(class_scope:vas.FilterParameter)
 private:
  inline void set_has_contour_area_threshold();
  inline void clear_has_contour_area_threshold();
  inline void set_has_contour_perimeter_threshold();
  inline void clear_has_contour_perimeter_threshold();
  inline void set_has_area_perimeter_ratio_threshold();
  inline void clear_has_area_perimeter_ratio_threshold();
  inline void set_has_filter_type();
  inline void clear_has_filter_type();
  inline void set_has_rgb_th_1();
  inline void clear_has_rgb_th_1();
  inline void set_has_rgb_th_2();
  inline void clear_has_rgb_th_2();
  inline void set_has_ycbcr_th_1();
  inline void clear_has_ycbcr_th_1();
  inline void set_has_ycbcr_th_2();
  inline void clear_has_ycbcr_th_2();
  inline void set_has_color_fit_ratio();
  inline void clear_has_color_fit_ratio();
  inline void set_has_filter_width();
  inline void clear_has_filter_width();
  inline void set_has_filter_height();
  inline void clear_has_filter_height();
  inline void set_has_filter_method();
  inline void clear_has_filter_method();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 contour_area_threshold_;
  ::google::protobuf::uint32 contour_perimeter_threshold_;
  float area_perimeter_ratio_threshold_;
  int filter_type_;
  ::vas::ColorThreshold* rgb_th_1_;
  ::vas::ColorThreshold* rgb_th_2_;
  ::vas::ColorThreshold* ycbcr_th_1_;
  ::vas::ColorThreshold* ycbcr_th_2_;
  float color_fit_ratio_;
  ::google::protobuf::uint32 filter_width_;
  ::google::protobuf::uint32 filter_height_;
  int filter_method_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static FilterParameter* default_instance_;
};
// -------------------------------------------------------------------

class CaffeClassifierParameter : public ::google::protobuf::Message {
 public:
  CaffeClassifierParameter();
  virtual ~CaffeClassifierParameter();

  CaffeClassifierParameter(const CaffeClassifierParameter& from);

  inline CaffeClassifierParameter& operator=(const CaffeClassifierParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeClassifierParameter& default_instance();

  void Swap(CaffeClassifierParameter* other);

  // implements Message ----------------------------------------------

  CaffeClassifierParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeClassifierParameter& from);
  void MergeFrom(const CaffeClassifierParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float confience_score = 1 [default = 0.5];
  inline bool has_confience_score() const;
  inline void clear_confience_score();
  static const int kConfienceScoreFieldNumber = 1;
  inline float confience_score() const;
  inline void set_confience_score(float value);

  // optional uint32 input_size = 2 [default = 224];
  inline bool has_input_size() const;
  inline void clear_input_size();
  static const int kInputSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 input_size() const;
  inline void set_input_size(::google::protobuf::uint32 value);

  // optional string model_version = 3;
  inline bool has_model_version() const;
  inline void clear_model_version();
  static const int kModelVersionFieldNumber = 3;
  inline const ::std::string& model_version() const;
  inline void set_model_version(const ::std::string& value);
  inline void set_model_version(const char* value);
  inline void set_model_version(const char* value, size_t size);
  inline ::std::string* mutable_model_version();
  inline ::std::string* release_model_version();
  inline void set_allocated_model_version(::std::string* model_version);

  // @@protoc_insertion_point(class_scope:vas.CaffeClassifierParameter)
 private:
  inline void set_has_confience_score();
  inline void clear_has_confience_score();
  inline void set_has_input_size();
  inline void clear_has_input_size();
  inline void set_has_model_version();
  inline void clear_has_model_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float confience_score_;
  ::google::protobuf::uint32 input_size_;
  ::std::string* model_version_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static CaffeClassifierParameter* default_instance_;
};
// -------------------------------------------------------------------

class DetectParameter : public ::google::protobuf::Message {
 public:
  DetectParameter();
  virtual ~DetectParameter();

  DetectParameter(const DetectParameter& from);

  inline DetectParameter& operator=(const DetectParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectParameter& default_instance();

  void Swap(DetectParameter* other);

  // implements Message ----------------------------------------------

  DetectParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectParameter& from);
  void MergeFrom(const DetectParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // repeated string reg_type = 2;
  inline int reg_type_size() const;
  inline void clear_reg_type();
  static const int kRegTypeFieldNumber = 2;
  inline const ::std::string& reg_type(int index) const;
  inline ::std::string* mutable_reg_type(int index);
  inline void set_reg_type(int index, const ::std::string& value);
  inline void set_reg_type(int index, const char* value);
  inline void set_reg_type(int index, const char* value, size_t size);
  inline ::std::string* add_reg_type();
  inline void add_reg_type(const ::std::string& value);
  inline void add_reg_type(const char* value);
  inline void add_reg_type(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& reg_type() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reg_type();

  // optional float smoke_detect_sensitity = 11 [default = 0.2];
  inline bool has_smoke_detect_sensitity() const;
  inline void clear_smoke_detect_sensitity();
  static const int kSmokeDetectSensitityFieldNumber = 11;
  inline float smoke_detect_sensitity() const;
  inline void set_smoke_detect_sensitity(float value);

  // optional float fire_detect_sensitity = 24 [default = 0.2];
  inline bool has_fire_detect_sensitity() const;
  inline void clear_fire_detect_sensitity();
  static const int kFireDetectSensitityFieldNumber = 24;
  inline float fire_detect_sensitity() const;
  inline void set_fire_detect_sensitity(float value);

  // optional uint32 num_history = 12 [default = 50];
  inline bool has_num_history() const;
  inline void clear_num_history();
  static const int kNumHistoryFieldNumber = 12;
  inline ::google::protobuf::uint32 num_history() const;
  inline void set_num_history(::google::protobuf::uint32 value);

  // optional uint32 reg_width = 4 [default = 800];
  inline bool has_reg_width() const;
  inline void clear_reg_width();
  static const int kRegWidthFieldNumber = 4;
  inline ::google::protobuf::uint32 reg_width() const;
  inline void set_reg_width(::google::protobuf::uint32 value);

  // optional uint32 reg_height = 5 [default = 576];
  inline bool has_reg_height() const;
  inline void clear_reg_height();
  static const int kRegHeightFieldNumber = 5;
  inline ::google::protobuf::uint32 reg_height() const;
  inline void set_reg_height(::google::protobuf::uint32 value);

  // optional uint32 reg_interval = 6 [default = 20];
  inline bool has_reg_interval() const;
  inline void clear_reg_interval();
  static const int kRegIntervalFieldNumber = 6;
  inline ::google::protobuf::uint32 reg_interval() const;
  inline void set_reg_interval(::google::protobuf::uint32 value);

  // optional .vas.BgParameter bg_parameter = 7;
  inline bool has_bg_parameter() const;
  inline void clear_bg_parameter();
  static const int kBgParameterFieldNumber = 7;
  inline const ::vas::BgParameter& bg_parameter() const;
  inline ::vas::BgParameter* mutable_bg_parameter();
  inline ::vas::BgParameter* release_bg_parameter();
  inline void set_allocated_bg_parameter(::vas::BgParameter* bg_parameter);

  // optional .vas.FilterParameter filter_parameter = 8;
  inline bool has_filter_parameter() const;
  inline void clear_filter_parameter();
  static const int kFilterParameterFieldNumber = 8;
  inline const ::vas::FilterParameter& filter_parameter() const;
  inline ::vas::FilterParameter* mutable_filter_parameter();
  inline ::vas::FilterParameter* release_filter_parameter();
  inline void set_allocated_filter_parameter(::vas::FilterParameter* filter_parameter);

  // optional .vas.CaffeClassifierParameter caffe_parameter = 9;
  inline bool has_caffe_parameter() const;
  inline void clear_caffe_parameter();
  static const int kCaffeParameterFieldNumber = 9;
  inline const ::vas::CaffeClassifierParameter& caffe_parameter() const;
  inline ::vas::CaffeClassifierParameter* mutable_caffe_parameter();
  inline ::vas::CaffeClassifierParameter* release_caffe_parameter();
  inline void set_allocated_caffe_parameter(::vas::CaffeClassifierParameter* caffe_parameter);

  // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
  inline bool has_detect_status() const;
  inline void clear_detect_status();
  static const int kDetectStatusFieldNumber = 10;
  inline ::vas::DetectStatus detect_status() const;
  inline void set_detect_status(::vas::DetectStatus value);

  // optional bool merge_fore_rects = 20 [default = false];
  inline bool has_merge_fore_rects() const;
  inline void clear_merge_fore_rects();
  static const int kMergeForeRectsFieldNumber = 20;
  inline bool merge_fore_rects() const;
  inline void set_merge_fore_rects(bool value);

  // optional bool show_result_frame = 13 [default = false];
  inline bool has_show_result_frame() const;
  inline void clear_show_result_frame();
  static const int kShowResultFrameFieldNumber = 13;
  inline bool show_result_frame() const;
  inline void set_show_result_frame(bool value);

  // optional bool show_bg = 15 [default = false];
  inline bool has_show_bg() const;
  inline void clear_show_bg();
  static const int kShowBgFieldNumber = 15;
  inline bool show_bg() const;
  inline void set_show_bg(bool value);

  // optional bool show_reg_frame = 16 [default = false];
  inline bool has_show_reg_frame() const;
  inline void clear_show_reg_frame();
  static const int kShowRegFrameFieldNumber = 16;
  inline bool show_reg_frame() const;
  inline void set_show_reg_frame(bool value);

  // optional bool print_reg_count = 14 [default = false];
  inline bool has_print_reg_count() const;
  inline void clear_print_reg_count();
  static const int kPrintRegCountFieldNumber = 14;
  inline bool print_reg_count() const;
  inline void set_print_reg_count(bool value);

  // optional bool show_smoke_hot_frame = 17 [default = false];
  inline bool has_show_smoke_hot_frame() const;
  inline void clear_show_smoke_hot_frame();
  static const int kShowSmokeHotFrameFieldNumber = 17;
  inline bool show_smoke_hot_frame() const;
  inline void set_show_smoke_hot_frame(bool value);

  // optional bool show_fire_hot_frame = 23 [default = false];
  inline bool has_show_fire_hot_frame() const;
  inline void clear_show_fire_hot_frame();
  static const int kShowFireHotFrameFieldNumber = 23;
  inline bool show_fire_hot_frame() const;
  inline void set_show_fire_hot_frame(bool value);

  // optional bool save_reg_frame = 18 [default = false];
  inline bool has_save_reg_frame() const;
  inline void clear_save_reg_frame();
  static const int kSaveRegFrameFieldNumber = 18;
  inline bool save_reg_frame() const;
  inline void set_save_reg_frame(bool value);

  // optional bool save_video = 19 [default = false];
  inline bool has_save_video() const;
  inline void clear_save_video();
  static const int kSaveVideoFieldNumber = 19;
  inline bool save_video() const;
  inline void set_save_video(bool value);

  // optional bool move_area_for_reg_only = 21 [default = false];
  inline bool has_move_area_for_reg_only() const;
  inline void clear_move_area_for_reg_only();
  static const int kMoveAreaForRegOnlyFieldNumber = 21;
  inline bool move_area_for_reg_only() const;
  inline void set_move_area_for_reg_only(bool value);

  // optional bool show_move_area_for_reg_only = 22 [default = false];
  inline bool has_show_move_area_for_reg_only() const;
  inline void clear_show_move_area_for_reg_only();
  static const int kShowMoveAreaForRegOnlyFieldNumber = 22;
  inline bool show_move_area_for_reg_only() const;
  inline void set_show_move_area_for_reg_only(bool value);

  // @@protoc_insertion_point(class_scope:vas.DetectParameter)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_smoke_detect_sensitity();
  inline void clear_has_smoke_detect_sensitity();
  inline void set_has_fire_detect_sensitity();
  inline void clear_has_fire_detect_sensitity();
  inline void set_has_num_history();
  inline void clear_has_num_history();
  inline void set_has_reg_width();
  inline void clear_has_reg_width();
  inline void set_has_reg_height();
  inline void clear_has_reg_height();
  inline void set_has_reg_interval();
  inline void clear_has_reg_interval();
  inline void set_has_bg_parameter();
  inline void clear_has_bg_parameter();
  inline void set_has_filter_parameter();
  inline void clear_has_filter_parameter();
  inline void set_has_caffe_parameter();
  inline void clear_has_caffe_parameter();
  inline void set_has_detect_status();
  inline void clear_has_detect_status();
  inline void set_has_merge_fore_rects();
  inline void clear_has_merge_fore_rects();
  inline void set_has_show_result_frame();
  inline void clear_has_show_result_frame();
  inline void set_has_show_bg();
  inline void clear_has_show_bg();
  inline void set_has_show_reg_frame();
  inline void clear_has_show_reg_frame();
  inline void set_has_print_reg_count();
  inline void clear_has_print_reg_count();
  inline void set_has_show_smoke_hot_frame();
  inline void clear_has_show_smoke_hot_frame();
  inline void set_has_show_fire_hot_frame();
  inline void clear_has_show_fire_hot_frame();
  inline void set_has_save_reg_frame();
  inline void clear_has_save_reg_frame();
  inline void set_has_save_video();
  inline void clear_has_save_video();
  inline void set_has_move_area_for_reg_only();
  inline void clear_has_move_area_for_reg_only();
  inline void set_has_show_move_area_for_reg_only();
  inline void clear_has_show_move_area_for_reg_only();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reg_type_;
  float smoke_detect_sensitity_;
  float fire_detect_sensitity_;
  ::google::protobuf::uint32 num_history_;
  ::google::protobuf::uint32 reg_width_;
  ::google::protobuf::uint32 reg_height_;
  ::google::protobuf::uint32 reg_interval_;
  ::vas::BgParameter* bg_parameter_;
  ::vas::FilterParameter* filter_parameter_;
  ::vas::CaffeClassifierParameter* caffe_parameter_;
  int detect_status_;
  bool merge_fore_rects_;
  bool show_result_frame_;
  bool show_bg_;
  bool show_reg_frame_;
  bool print_reg_count_;
  bool show_smoke_hot_frame_;
  bool show_fire_hot_frame_;
  bool save_reg_frame_;
  bool save_video_;
  bool move_area_for_reg_only_;
  bool show_move_area_for_reg_only_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static DetectParameter* default_instance_;
};
// -------------------------------------------------------------------

class SsdDetecterParameter : public ::google::protobuf::Message {
 public:
  SsdDetecterParameter();
  virtual ~SsdDetecterParameter();

  SsdDetecterParameter(const SsdDetecterParameter& from);

  inline SsdDetecterParameter& operator=(const SsdDetecterParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SsdDetecterParameter& default_instance();

  void Swap(SsdDetecterParameter* other);

  // implements Message ----------------------------------------------

  SsdDetecterParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SsdDetecterParameter& from);
  void MergeFrom(const SsdDetecterParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // repeated string reg_type = 2;
  inline int reg_type_size() const;
  inline void clear_reg_type();
  static const int kRegTypeFieldNumber = 2;
  inline const ::std::string& reg_type(int index) const;
  inline ::std::string* mutable_reg_type(int index);
  inline void set_reg_type(int index, const ::std::string& value);
  inline void set_reg_type(int index, const char* value);
  inline void set_reg_type(int index, const char* value, size_t size);
  inline ::std::string* add_reg_type();
  inline void add_reg_type(const ::std::string& value);
  inline void add_reg_type(const char* value);
  inline void add_reg_type(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& reg_type() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reg_type();

  // optional uint32 reg_width = 4 [default = 800];
  inline bool has_reg_width() const;
  inline void clear_reg_width();
  static const int kRegWidthFieldNumber = 4;
  inline ::google::protobuf::uint32 reg_width() const;
  inline void set_reg_width(::google::protobuf::uint32 value);

  // optional uint32 reg_height = 5 [default = 576];
  inline bool has_reg_height() const;
  inline void clear_reg_height();
  static const int kRegHeightFieldNumber = 5;
  inline ::google::protobuf::uint32 reg_height() const;
  inline void set_reg_height(::google::protobuf::uint32 value);

  // optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
  inline bool has_detect_status() const;
  inline void clear_detect_status();
  static const int kDetectStatusFieldNumber = 10;
  inline ::vas::DetectStatus detect_status() const;
  inline void set_detect_status(::vas::DetectStatus value);

  // optional bool show_result_frame = 13 [default = false];
  inline bool has_show_result_frame() const;
  inline void clear_show_result_frame();
  static const int kShowResultFrameFieldNumber = 13;
  inline bool show_result_frame() const;
  inline void set_show_result_frame(bool value);

  // optional bool show_reg_frame = 16 [default = false];
  inline bool has_show_reg_frame() const;
  inline void clear_show_reg_frame();
  static const int kShowRegFrameFieldNumber = 16;
  inline bool show_reg_frame() const;
  inline void set_show_reg_frame(bool value);

  // optional bool save_video = 19 [default = false];
  inline bool has_save_video() const;
  inline void clear_save_video();
  static const int kSaveVideoFieldNumber = 19;
  inline bool save_video() const;
  inline void set_save_video(bool value);

  // optional bool save_reg_frame = 18 [default = false];
  inline bool has_save_reg_frame() const;
  inline void clear_save_reg_frame();
  static const int kSaveRegFrameFieldNumber = 18;
  inline bool save_reg_frame() const;
  inline void set_save_reg_frame(bool value);

  // optional uint32 reg_interval = 6 [default = 20];
  inline bool has_reg_interval() const;
  inline void clear_reg_interval();
  static const int kRegIntervalFieldNumber = 6;
  inline ::google::protobuf::uint32 reg_interval() const;
  inline void set_reg_interval(::google::protobuf::uint32 value);

  // optional float confidence_threshold = 21 [default = 0.5];
  inline bool has_confidence_threshold() const;
  inline void clear_confidence_threshold();
  static const int kConfidenceThresholdFieldNumber = 21;
  inline float confidence_threshold() const;
  inline void set_confidence_threshold(float value);

  // @@protoc_insertion_point(class_scope:vas.SsdDetecterParameter)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_reg_width();
  inline void clear_has_reg_width();
  inline void set_has_reg_height();
  inline void clear_has_reg_height();
  inline void set_has_detect_status();
  inline void clear_has_detect_status();
  inline void set_has_show_result_frame();
  inline void clear_has_show_result_frame();
  inline void set_has_show_reg_frame();
  inline void clear_has_show_reg_frame();
  inline void set_has_save_video();
  inline void clear_has_save_video();
  inline void set_has_save_reg_frame();
  inline void clear_has_save_reg_frame();
  inline void set_has_reg_interval();
  inline void clear_has_reg_interval();
  inline void set_has_confidence_threshold();
  inline void clear_has_confidence_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reg_type_;
  ::google::protobuf::uint32 reg_width_;
  ::google::protobuf::uint32 reg_height_;
  int detect_status_;
  bool show_result_frame_;
  bool show_reg_frame_;
  bool save_video_;
  bool save_reg_frame_;
  ::google::protobuf::uint32 reg_interval_;
  float confidence_threshold_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static SsdDetecterParameter* default_instance_;
};
// -------------------------------------------------------------------

class CaffeModelPath : public ::google::protobuf::Message {
 public:
  CaffeModelPath();
  virtual ~CaffeModelPath();

  CaffeModelPath(const CaffeModelPath& from);

  inline CaffeModelPath& operator=(const CaffeModelPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CaffeModelPath& default_instance();

  void Swap(CaffeModelPath* other);

  // implements Message ----------------------------------------------

  CaffeModelPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CaffeModelPath& from);
  void MergeFrom(const CaffeModelPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string deploy_file_path = 1;
  inline bool has_deploy_file_path() const;
  inline void clear_deploy_file_path();
  static const int kDeployFilePathFieldNumber = 1;
  inline const ::std::string& deploy_file_path() const;
  inline void set_deploy_file_path(const ::std::string& value);
  inline void set_deploy_file_path(const char* value);
  inline void set_deploy_file_path(const char* value, size_t size);
  inline ::std::string* mutable_deploy_file_path();
  inline ::std::string* release_deploy_file_path();
  inline void set_allocated_deploy_file_path(::std::string* deploy_file_path);

  // optional string trained_model_path = 2;
  inline bool has_trained_model_path() const;
  inline void clear_trained_model_path();
  static const int kTrainedModelPathFieldNumber = 2;
  inline const ::std::string& trained_model_path() const;
  inline void set_trained_model_path(const ::std::string& value);
  inline void set_trained_model_path(const char* value);
  inline void set_trained_model_path(const char* value, size_t size);
  inline ::std::string* mutable_trained_model_path();
  inline ::std::string* release_trained_model_path();
  inline void set_allocated_trained_model_path(::std::string* trained_model_path);

  // optional string label_file_path = 3;
  inline bool has_label_file_path() const;
  inline void clear_label_file_path();
  static const int kLabelFilePathFieldNumber = 3;
  inline const ::std::string& label_file_path() const;
  inline void set_label_file_path(const ::std::string& value);
  inline void set_label_file_path(const char* value);
  inline void set_label_file_path(const char* value, size_t size);
  inline ::std::string* mutable_label_file_path();
  inline ::std::string* release_label_file_path();
  inline void set_allocated_label_file_path(::std::string* label_file_path);

  // optional string mean_file_path = 4;
  inline bool has_mean_file_path() const;
  inline void clear_mean_file_path();
  static const int kMeanFilePathFieldNumber = 4;
  inline const ::std::string& mean_file_path() const;
  inline void set_mean_file_path(const ::std::string& value);
  inline void set_mean_file_path(const char* value);
  inline void set_mean_file_path(const char* value, size_t size);
  inline ::std::string* mutable_mean_file_path();
  inline ::std::string* release_mean_file_path();
  inline void set_allocated_mean_file_path(::std::string* mean_file_path);

  // optional uint32 input_size = 5 [default = 224];
  inline bool has_input_size() const;
  inline void clear_input_size();
  static const int kInputSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 input_size() const;
  inline void set_input_size(::google::protobuf::uint32 value);

  // optional string model_version = 6;
  inline bool has_model_version() const;
  inline void clear_model_version();
  static const int kModelVersionFieldNumber = 6;
  inline const ::std::string& model_version() const;
  inline void set_model_version(const ::std::string& value);
  inline void set_model_version(const char* value);
  inline void set_model_version(const char* value, size_t size);
  inline ::std::string* mutable_model_version();
  inline ::std::string* release_model_version();
  inline void set_allocated_model_version(::std::string* model_version);

  // optional bool use_gpu = 7 [default = true];
  inline bool has_use_gpu() const;
  inline void clear_use_gpu();
  static const int kUseGpuFieldNumber = 7;
  inline bool use_gpu() const;
  inline void set_use_gpu(bool value);

  // @@protoc_insertion_point(class_scope:vas.CaffeModelPath)
 private:
  inline void set_has_deploy_file_path();
  inline void clear_has_deploy_file_path();
  inline void set_has_trained_model_path();
  inline void clear_has_trained_model_path();
  inline void set_has_label_file_path();
  inline void clear_has_label_file_path();
  inline void set_has_mean_file_path();
  inline void clear_has_mean_file_path();
  inline void set_has_input_size();
  inline void clear_has_input_size();
  inline void set_has_model_version();
  inline void clear_has_model_version();
  inline void set_has_use_gpu();
  inline void clear_has_use_gpu();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* deploy_file_path_;
  ::std::string* trained_model_path_;
  ::std::string* label_file_path_;
  ::std::string* mean_file_path_;
  ::std::string* model_version_;
  ::google::protobuf::uint32 input_size_;
  bool use_gpu_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static CaffeModelPath* default_instance_;
};
// -------------------------------------------------------------------

class SsdModelPath : public ::google::protobuf::Message {
 public:
  SsdModelPath();
  virtual ~SsdModelPath();

  SsdModelPath(const SsdModelPath& from);

  inline SsdModelPath& operator=(const SsdModelPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SsdModelPath& default_instance();

  void Swap(SsdModelPath* other);

  // implements Message ----------------------------------------------

  SsdModelPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SsdModelPath& from);
  void MergeFrom(const SsdModelPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string deploy_file_path = 1;
  inline bool has_deploy_file_path() const;
  inline void clear_deploy_file_path();
  static const int kDeployFilePathFieldNumber = 1;
  inline const ::std::string& deploy_file_path() const;
  inline void set_deploy_file_path(const ::std::string& value);
  inline void set_deploy_file_path(const char* value);
  inline void set_deploy_file_path(const char* value, size_t size);
  inline ::std::string* mutable_deploy_file_path();
  inline ::std::string* release_deploy_file_path();
  inline void set_allocated_deploy_file_path(::std::string* deploy_file_path);

  // optional string trained_model_path = 2;
  inline bool has_trained_model_path() const;
  inline void clear_trained_model_path();
  static const int kTrainedModelPathFieldNumber = 2;
  inline const ::std::string& trained_model_path() const;
  inline void set_trained_model_path(const ::std::string& value);
  inline void set_trained_model_path(const char* value);
  inline void set_trained_model_path(const char* value, size_t size);
  inline ::std::string* mutable_trained_model_path();
  inline ::std::string* release_trained_model_path();
  inline void set_allocated_trained_model_path(::std::string* trained_model_path);

  // optional string label_file_path = 3;
  inline bool has_label_file_path() const;
  inline void clear_label_file_path();
  static const int kLabelFilePathFieldNumber = 3;
  inline const ::std::string& label_file_path() const;
  inline void set_label_file_path(const ::std::string& value);
  inline void set_label_file_path(const char* value);
  inline void set_label_file_path(const char* value, size_t size);
  inline ::std::string* mutable_label_file_path();
  inline ::std::string* release_label_file_path();
  inline void set_allocated_label_file_path(::std::string* label_file_path);

  // optional string mean_file_path = 4;
  inline bool has_mean_file_path() const;
  inline void clear_mean_file_path();
  static const int kMeanFilePathFieldNumber = 4;
  inline const ::std::string& mean_file_path() const;
  inline void set_mean_file_path(const ::std::string& value);
  inline void set_mean_file_path(const char* value);
  inline void set_mean_file_path(const char* value, size_t size);
  inline ::std::string* mutable_mean_file_path();
  inline ::std::string* release_mean_file_path();
  inline void set_allocated_mean_file_path(::std::string* mean_file_path);

  // optional string mean_value = 5;
  inline bool has_mean_value() const;
  inline void clear_mean_value();
  static const int kMeanValueFieldNumber = 5;
  inline const ::std::string& mean_value() const;
  inline void set_mean_value(const ::std::string& value);
  inline void set_mean_value(const char* value);
  inline void set_mean_value(const char* value, size_t size);
  inline ::std::string* mutable_mean_value();
  inline ::std::string* release_mean_value();
  inline void set_allocated_mean_value(::std::string* mean_value);

  // optional string model_version = 6;
  inline bool has_model_version() const;
  inline void clear_model_version();
  static const int kModelVersionFieldNumber = 6;
  inline const ::std::string& model_version() const;
  inline void set_model_version(const ::std::string& value);
  inline void set_model_version(const char* value);
  inline void set_model_version(const char* value, size_t size);
  inline ::std::string* mutable_model_version();
  inline ::std::string* release_model_version();
  inline void set_allocated_model_version(::std::string* model_version);

  // optional bool use_gpu = 7 [default = true];
  inline bool has_use_gpu() const;
  inline void clear_use_gpu();
  static const int kUseGpuFieldNumber = 7;
  inline bool use_gpu() const;
  inline void set_use_gpu(bool value);

  // @@protoc_insertion_point(class_scope:vas.SsdModelPath)
 private:
  inline void set_has_deploy_file_path();
  inline void clear_has_deploy_file_path();
  inline void set_has_trained_model_path();
  inline void clear_has_trained_model_path();
  inline void set_has_label_file_path();
  inline void clear_has_label_file_path();
  inline void set_has_mean_file_path();
  inline void clear_has_mean_file_path();
  inline void set_has_mean_value();
  inline void clear_has_mean_value();
  inline void set_has_model_version();
  inline void clear_has_model_version();
  inline void set_has_use_gpu();
  inline void clear_has_use_gpu();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* deploy_file_path_;
  ::std::string* trained_model_path_;
  ::std::string* label_file_path_;
  ::std::string* mean_file_path_;
  ::std::string* mean_value_;
  ::std::string* model_version_;
  bool use_gpu_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static SsdModelPath* default_instance_;
};
// -------------------------------------------------------------------

class ServiceParameter : public ::google::protobuf::Message {
 public:
  ServiceParameter();
  virtual ~ServiceParameter();

  ServiceParameter(const ServiceParameter& from);

  inline ServiceParameter& operator=(const ServiceParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceParameter& default_instance();

  void Swap(ServiceParameter* other);

  // implements Message ----------------------------------------------

  ServiceParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceParameter& from);
  void MergeFrom(const ServiceParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional .vas.DecodeParameter decode_parameter = 2;
  inline bool has_decode_parameter() const;
  inline void clear_decode_parameter();
  static const int kDecodeParameterFieldNumber = 2;
  inline const ::vas::DecodeParameter& decode_parameter() const;
  inline ::vas::DecodeParameter* mutable_decode_parameter();
  inline ::vas::DecodeParameter* release_decode_parameter();
  inline void set_allocated_decode_parameter(::vas::DecodeParameter* decode_parameter);

  // optional .vas.DetectParameter detect_parameter = 3;
  inline bool has_detect_parameter() const;
  inline void clear_detect_parameter();
  static const int kDetectParameterFieldNumber = 3;
  inline const ::vas::DetectParameter& detect_parameter() const;
  inline ::vas::DetectParameter* mutable_detect_parameter();
  inline ::vas::DetectParameter* release_detect_parameter();
  inline void set_allocated_detect_parameter(::vas::DetectParameter* detect_parameter);

  // optional .vas.ServiceStatus service_status = 4;
  inline bool has_service_status() const;
  inline void clear_service_status();
  static const int kServiceStatusFieldNumber = 4;
  inline ::vas::ServiceStatus service_status() const;
  inline void set_service_status(::vas::ServiceStatus value);

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  inline bool has_reg_msg_subscribe() const;
  inline void clear_reg_msg_subscribe();
  static const int kRegMsgSubscribeFieldNumber = 5;
  inline ::vas::RegMsgSubscribe reg_msg_subscribe() const;
  inline void set_reg_msg_subscribe(::vas::RegMsgSubscribe value);

  // @@protoc_insertion_point(class_scope:vas.ServiceParameter)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_decode_parameter();
  inline void clear_has_decode_parameter();
  inline void set_has_detect_parameter();
  inline void clear_has_detect_parameter();
  inline void set_has_service_status();
  inline void clear_has_service_status();
  inline void set_has_reg_msg_subscribe();
  inline void clear_has_reg_msg_subscribe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::vas::DecodeParameter* decode_parameter_;
  ::vas::DetectParameter* detect_parameter_;
  int service_status_;
  int reg_msg_subscribe_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static ServiceParameter* default_instance_;
};
// -------------------------------------------------------------------

class SsdServiceParameter : public ::google::protobuf::Message {
 public:
  SsdServiceParameter();
  virtual ~SsdServiceParameter();

  SsdServiceParameter(const SsdServiceParameter& from);

  inline SsdServiceParameter& operator=(const SsdServiceParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SsdServiceParameter& default_instance();

  void Swap(SsdServiceParameter* other);

  // implements Message ----------------------------------------------

  SsdServiceParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SsdServiceParameter& from);
  void MergeFrom(const SsdServiceParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional .vas.DecodeParameter decode_parameter = 2;
  inline bool has_decode_parameter() const;
  inline void clear_decode_parameter();
  static const int kDecodeParameterFieldNumber = 2;
  inline const ::vas::DecodeParameter& decode_parameter() const;
  inline ::vas::DecodeParameter* mutable_decode_parameter();
  inline ::vas::DecodeParameter* release_decode_parameter();
  inline void set_allocated_decode_parameter(::vas::DecodeParameter* decode_parameter);

  // optional .vas.SsdDetecterParameter detect_parameter = 3;
  inline bool has_detect_parameter() const;
  inline void clear_detect_parameter();
  static const int kDetectParameterFieldNumber = 3;
  inline const ::vas::SsdDetecterParameter& detect_parameter() const;
  inline ::vas::SsdDetecterParameter* mutable_detect_parameter();
  inline ::vas::SsdDetecterParameter* release_detect_parameter();
  inline void set_allocated_detect_parameter(::vas::SsdDetecterParameter* detect_parameter);

  // optional .vas.ServiceStatus service_status = 4;
  inline bool has_service_status() const;
  inline void clear_service_status();
  static const int kServiceStatusFieldNumber = 4;
  inline ::vas::ServiceStatus service_status() const;
  inline void set_service_status(::vas::ServiceStatus value);

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  inline bool has_reg_msg_subscribe() const;
  inline void clear_reg_msg_subscribe();
  static const int kRegMsgSubscribeFieldNumber = 5;
  inline ::vas::RegMsgSubscribe reg_msg_subscribe() const;
  inline void set_reg_msg_subscribe(::vas::RegMsgSubscribe value);

  // @@protoc_insertion_point(class_scope:vas.SsdServiceParameter)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_decode_parameter();
  inline void clear_has_decode_parameter();
  inline void set_has_detect_parameter();
  inline void clear_has_detect_parameter();
  inline void set_has_service_status();
  inline void clear_has_service_status();
  inline void set_has_reg_msg_subscribe();
  inline void clear_has_reg_msg_subscribe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::vas::DecodeParameter* decode_parameter_;
  ::vas::SsdDetecterParameter* detect_parameter_;
  int service_status_;
  int reg_msg_subscribe_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static SsdServiceParameter* default_instance_;
};
// -------------------------------------------------------------------

class NvrServiceParameter : public ::google::protobuf::Message {
 public:
  NvrServiceParameter();
  virtual ~NvrServiceParameter();

  NvrServiceParameter(const NvrServiceParameter& from);

  inline NvrServiceParameter& operator=(const NvrServiceParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NvrServiceParameter& default_instance();

  void Swap(NvrServiceParameter* other);

  // implements Message ----------------------------------------------

  NvrServiceParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NvrServiceParameter& from);
  void MergeFrom(const NvrServiceParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional .vas.NvrChannel nvr_channel = 2;
  inline bool has_nvr_channel() const;
  inline void clear_nvr_channel();
  static const int kNvrChannelFieldNumber = 2;
  inline const ::vas::NvrChannel& nvr_channel() const;
  inline ::vas::NvrChannel* mutable_nvr_channel();
  inline ::vas::NvrChannel* release_nvr_channel();
  inline void set_allocated_nvr_channel(::vas::NvrChannel* nvr_channel);

  // optional .vas.DetectParameter detect_parameter = 3;
  inline bool has_detect_parameter() const;
  inline void clear_detect_parameter();
  static const int kDetectParameterFieldNumber = 3;
  inline const ::vas::DetectParameter& detect_parameter() const;
  inline ::vas::DetectParameter* mutable_detect_parameter();
  inline ::vas::DetectParameter* release_detect_parameter();
  inline void set_allocated_detect_parameter(::vas::DetectParameter* detect_parameter);

  // optional .vas.ServiceStatus service_status = 4;
  inline bool has_service_status() const;
  inline void clear_service_status();
  static const int kServiceStatusFieldNumber = 4;
  inline ::vas::ServiceStatus service_status() const;
  inline void set_service_status(::vas::ServiceStatus value);

  // optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
  inline bool has_reg_msg_subscribe() const;
  inline void clear_reg_msg_subscribe();
  static const int kRegMsgSubscribeFieldNumber = 5;
  inline ::vas::RegMsgSubscribe reg_msg_subscribe() const;
  inline void set_reg_msg_subscribe(::vas::RegMsgSubscribe value);

  // @@protoc_insertion_point(class_scope:vas.NvrServiceParameter)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_nvr_channel();
  inline void clear_has_nvr_channel();
  inline void set_has_detect_parameter();
  inline void clear_has_detect_parameter();
  inline void set_has_service_status();
  inline void clear_has_service_status();
  inline void set_has_reg_msg_subscribe();
  inline void clear_has_reg_msg_subscribe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::vas::NvrChannel* nvr_channel_;
  ::vas::DetectParameter* detect_parameter_;
  int service_status_;
  int reg_msg_subscribe_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static NvrServiceParameter* default_instance_;
};
// -------------------------------------------------------------------

class ServiceList : public ::google::protobuf::Message {
 public:
  ServiceList();
  virtual ~ServiceList();

  ServiceList(const ServiceList& from);

  inline ServiceList& operator=(const ServiceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceList& default_instance();

  void Swap(ServiceList* other);

  // implements Message ----------------------------------------------

  ServiceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceList& from);
  void MergeFrom(const ServiceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string last_update_time = 1;
  inline bool has_last_update_time() const;
  inline void clear_last_update_time();
  static const int kLastUpdateTimeFieldNumber = 1;
  inline const ::std::string& last_update_time() const;
  inline void set_last_update_time(const ::std::string& value);
  inline void set_last_update_time(const char* value);
  inline void set_last_update_time(const char* value, size_t size);
  inline ::std::string* mutable_last_update_time();
  inline ::std::string* release_last_update_time();
  inline void set_allocated_last_update_time(::std::string* last_update_time);

  // repeated .vas.ServiceParameter service_paramter = 2;
  inline int service_paramter_size() const;
  inline void clear_service_paramter();
  static const int kServiceParamterFieldNumber = 2;
  inline const ::vas::ServiceParameter& service_paramter(int index) const;
  inline ::vas::ServiceParameter* mutable_service_paramter(int index);
  inline ::vas::ServiceParameter* add_service_paramter();
  inline const ::google::protobuf::RepeatedPtrField< ::vas::ServiceParameter >&
      service_paramter() const;
  inline ::google::protobuf::RepeatedPtrField< ::vas::ServiceParameter >*
      mutable_service_paramter();

  // @@protoc_insertion_point(class_scope:vas.ServiceList)
 private:
  inline void set_has_last_update_time();
  inline void clear_has_last_update_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* last_update_time_;
  ::google::protobuf::RepeatedPtrField< ::vas::ServiceParameter > service_paramter_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static ServiceList* default_instance_;
};
// -------------------------------------------------------------------

class SsdServiceList : public ::google::protobuf::Message {
 public:
  SsdServiceList();
  virtual ~SsdServiceList();

  SsdServiceList(const SsdServiceList& from);

  inline SsdServiceList& operator=(const SsdServiceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SsdServiceList& default_instance();

  void Swap(SsdServiceList* other);

  // implements Message ----------------------------------------------

  SsdServiceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SsdServiceList& from);
  void MergeFrom(const SsdServiceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string last_update_time = 1;
  inline bool has_last_update_time() const;
  inline void clear_last_update_time();
  static const int kLastUpdateTimeFieldNumber = 1;
  inline const ::std::string& last_update_time() const;
  inline void set_last_update_time(const ::std::string& value);
  inline void set_last_update_time(const char* value);
  inline void set_last_update_time(const char* value, size_t size);
  inline ::std::string* mutable_last_update_time();
  inline ::std::string* release_last_update_time();
  inline void set_allocated_last_update_time(::std::string* last_update_time);

  // repeated .vas.SsdServiceParameter service_paramter = 2;
  inline int service_paramter_size() const;
  inline void clear_service_paramter();
  static const int kServiceParamterFieldNumber = 2;
  inline const ::vas::SsdServiceParameter& service_paramter(int index) const;
  inline ::vas::SsdServiceParameter* mutable_service_paramter(int index);
  inline ::vas::SsdServiceParameter* add_service_paramter();
  inline const ::google::protobuf::RepeatedPtrField< ::vas::SsdServiceParameter >&
      service_paramter() const;
  inline ::google::protobuf::RepeatedPtrField< ::vas::SsdServiceParameter >*
      mutable_service_paramter();

  // @@protoc_insertion_point(class_scope:vas.SsdServiceList)
 private:
  inline void set_has_last_update_time();
  inline void clear_has_last_update_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* last_update_time_;
  ::google::protobuf::RepeatedPtrField< ::vas::SsdServiceParameter > service_paramter_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static SsdServiceList* default_instance_;
};
// -------------------------------------------------------------------

class NvrServiceList : public ::google::protobuf::Message {
 public:
  NvrServiceList();
  virtual ~NvrServiceList();

  NvrServiceList(const NvrServiceList& from);

  inline NvrServiceList& operator=(const NvrServiceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NvrServiceList& default_instance();

  void Swap(NvrServiceList* other);

  // implements Message ----------------------------------------------

  NvrServiceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NvrServiceList& from);
  void MergeFrom(const NvrServiceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vas.NvrParameter nvr_paramter = 1;
  inline bool has_nvr_paramter() const;
  inline void clear_nvr_paramter();
  static const int kNvrParamterFieldNumber = 1;
  inline const ::vas::NvrParameter& nvr_paramter() const;
  inline ::vas::NvrParameter* mutable_nvr_paramter();
  inline ::vas::NvrParameter* release_nvr_paramter();
  inline void set_allocated_nvr_paramter(::vas::NvrParameter* nvr_paramter);

  // repeated .vas.NvrServiceParameter service_parameter = 2;
  inline int service_parameter_size() const;
  inline void clear_service_parameter();
  static const int kServiceParameterFieldNumber = 2;
  inline const ::vas::NvrServiceParameter& service_parameter(int index) const;
  inline ::vas::NvrServiceParameter* mutable_service_parameter(int index);
  inline ::vas::NvrServiceParameter* add_service_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::vas::NvrServiceParameter >&
      service_parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::vas::NvrServiceParameter >*
      mutable_service_parameter();

  // @@protoc_insertion_point(class_scope:vas.NvrServiceList)
 private:
  inline void set_has_nvr_paramter();
  inline void clear_has_nvr_paramter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::vas::NvrParameter* nvr_paramter_;
  ::google::protobuf::RepeatedPtrField< ::vas::NvrServiceParameter > service_parameter_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static NvrServiceList* default_instance_;
};
// -------------------------------------------------------------------

class VasComParameter : public ::google::protobuf::Message {
 public:
  VasComParameter();
  virtual ~VasComParameter();

  VasComParameter(const VasComParameter& from);

  inline VasComParameter& operator=(const VasComParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasComParameter& default_instance();

  void Swap(VasComParameter* other);

  // implements Message ----------------------------------------------

  VasComParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasComParameter& from);
  void MergeFrom(const VasComParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int64 port = 2 [default = 8001];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int64 port() const;
  inline void set_port(::google::protobuf::int64 value);

  // optional .vas.EnAppState app_state = 3 [default = ST_STOPPED];
  inline bool has_app_state() const;
  inline void clear_app_state();
  static const int kAppStateFieldNumber = 3;
  inline ::vas::EnAppState app_state() const;
  inline void set_app_state(::vas::EnAppState value);

  // optional int32 heartbeat_interval = 4 [default = 10];
  inline bool has_heartbeat_interval() const;
  inline void clear_heartbeat_interval();
  static const int kHeartbeatIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 heartbeat_interval() const;
  inline void set_heartbeat_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vas.VasComParameter)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_app_state();
  inline void clear_has_app_state();
  inline void set_has_heartbeat_interval();
  inline void clear_has_heartbeat_interval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::int64 port_;
  int app_state_;
  ::google::protobuf::int32 heartbeat_interval_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasComParameter* default_instance_;
};
// -------------------------------------------------------------------

class VasComputeNode : public ::google::protobuf::Message {
 public:
  VasComputeNode();
  virtual ~VasComputeNode();

  VasComputeNode(const VasComputeNode& from);

  inline VasComputeNode& operator=(const VasComputeNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasComputeNode& default_instance();

  void Swap(VasComputeNode* other);

  // implements Message ----------------------------------------------

  VasComputeNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasComputeNode& from);
  void MergeFrom(const VasComputeNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // optional string node_name = 2;
  inline bool has_node_name() const;
  inline void clear_node_name();
  static const int kNodeNameFieldNumber = 2;
  inline const ::std::string& node_name() const;
  inline void set_node_name(const ::std::string& value);
  inline void set_node_name(const char* value);
  inline void set_node_name(const char* value, size_t size);
  inline ::std::string* mutable_node_name();
  inline ::std::string* release_node_name();
  inline void set_allocated_node_name(::std::string* node_name);

  // optional int32 center_id = 3;
  inline bool has_center_id() const;
  inline void clear_center_id();
  static const int kCenterIdFieldNumber = 3;
  inline ::google::protobuf::int32 center_id() const;
  inline void set_center_id(::google::protobuf::int32 value);

  // optional int32 com_version = 4;
  inline bool has_com_version() const;
  inline void clear_com_version();
  static const int kComVersionFieldNumber = 4;
  inline ::google::protobuf::int32 com_version() const;
  inline void set_com_version(::google::protobuf::int32 value);

  // optional int32 retry_count = 5;
  inline bool has_retry_count() const;
  inline void clear_retry_count();
  static const int kRetryCountFieldNumber = 5;
  inline ::google::protobuf::int32 retry_count() const;
  inline void set_retry_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vas.VasComputeNode)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_node_name();
  inline void clear_has_node_name();
  inline void set_has_center_id();
  inline void clear_has_center_id();
  inline void set_has_com_version();
  inline void clear_has_com_version();
  inline void set_has_retry_count();
  inline void clear_has_retry_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* node_name_;
  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int32 center_id_;
  ::google::protobuf::int32 com_version_;
  ::google::protobuf::int32 retry_count_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasComputeNode* default_instance_;
};
// -------------------------------------------------------------------

class VasClientParameter : public ::google::protobuf::Message {
 public:
  VasClientParameter();
  virtual ~VasClientParameter();

  VasClientParameter(const VasClientParameter& from);

  inline VasClientParameter& operator=(const VasClientParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasClientParameter& default_instance();

  void Swap(VasClientParameter* other);

  // implements Message ----------------------------------------------

  VasClientParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasClientParameter& from);
  void MergeFrom(const VasClientParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vas.VasComParameter com_param = 1;
  inline bool has_com_param() const;
  inline void clear_com_param();
  static const int kComParamFieldNumber = 1;
  inline const ::vas::VasComParameter& com_param() const;
  inline ::vas::VasComParameter* mutable_com_param();
  inline ::vas::VasComParameter* release_com_param();
  inline void set_allocated_com_param(::vas::VasComParameter* com_param);

  // optional .vas.VasComputeNode node_param = 2;
  inline bool has_node_param() const;
  inline void clear_node_param();
  static const int kNodeParamFieldNumber = 2;
  inline const ::vas::VasComputeNode& node_param() const;
  inline ::vas::VasComputeNode* mutable_node_param();
  inline ::vas::VasComputeNode* release_node_param();
  inline void set_allocated_node_param(::vas::VasComputeNode* node_param);

  // @@protoc_insertion_point(class_scope:vas.VasClientParameter)
 private:
  inline void set_has_com_param();
  inline void clear_has_com_param();
  inline void set_has_node_param();
  inline void clear_has_node_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::vas::VasComParameter* com_param_;
  ::vas::VasComputeNode* node_param_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasClientParameter* default_instance_;
};
// -------------------------------------------------------------------

class VasMsgFilterParam : public ::google::protobuf::Message {
 public:
  VasMsgFilterParam();
  virtual ~VasMsgFilterParam();

  VasMsgFilterParam(const VasMsgFilterParam& from);

  inline VasMsgFilterParam& operator=(const VasMsgFilterParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasMsgFilterParam& default_instance();

  void Swap(VasMsgFilterParam* other);

  // implements Message ----------------------------------------------

  VasMsgFilterParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasMsgFilterParam& from);
  void MergeFrom(const VasMsgFilterParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional int32 interval_sec = 2 [default = 5];
  inline bool has_interval_sec() const;
  inline void clear_interval_sec();
  static const int kIntervalSecFieldNumber = 2;
  inline ::google::protobuf::int32 interval_sec() const;
  inline void set_interval_sec(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vas.VasMsgFilterParam)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_interval_sec();
  inline void clear_has_interval_sec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::google::protobuf::int32 interval_sec_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasMsgFilterParam* default_instance_;
};
// -------------------------------------------------------------------

class VasHeartbeatParameter : public ::google::protobuf::Message {
 public:
  VasHeartbeatParameter();
  virtual ~VasHeartbeatParameter();

  VasHeartbeatParameter(const VasHeartbeatParameter& from);

  inline VasHeartbeatParameter& operator=(const VasHeartbeatParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasHeartbeatParameter& default_instance();

  void Swap(VasHeartbeatParameter* other);

  // implements Message ----------------------------------------------

  VasHeartbeatParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasHeartbeatParameter& from);
  void MergeFrom(const VasHeartbeatParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string app_key = 1;
  inline bool has_app_key() const;
  inline void clear_app_key();
  static const int kAppKeyFieldNumber = 1;
  inline const ::std::string& app_key() const;
  inline void set_app_key(const ::std::string& value);
  inline void set_app_key(const char* value);
  inline void set_app_key(const char* value, size_t size);
  inline ::std::string* mutable_app_key();
  inline ::std::string* release_app_key();
  inline void set_allocated_app_key(::std::string* app_key);

  // optional int32 node_id = 2;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // optional string service_list = 3;
  inline bool has_service_list() const;
  inline void clear_service_list();
  static const int kServiceListFieldNumber = 3;
  inline const ::std::string& service_list() const;
  inline void set_service_list(const ::std::string& value);
  inline void set_service_list(const char* value);
  inline void set_service_list(const char* value, size_t size);
  inline ::std::string* mutable_service_list();
  inline ::std::string* release_service_list();
  inline void set_allocated_service_list(::std::string* service_list);

  // optional int64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vas.VasHeartbeatParameter)
 private:
  inline void set_has_app_key();
  inline void clear_has_app_key();
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_service_list();
  inline void clear_has_service_list();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* app_key_;
  ::std::string* service_list_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 node_id_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasHeartbeatParameter* default_instance_;
};
// -------------------------------------------------------------------

class VasHeartbeat : public ::google::protobuf::Message {
 public:
  VasHeartbeat();
  virtual ~VasHeartbeat();

  VasHeartbeat(const VasHeartbeat& from);

  inline VasHeartbeat& operator=(const VasHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasHeartbeat& default_instance();

  void Swap(VasHeartbeat* other);

  // implements Message ----------------------------------------------

  VasHeartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasHeartbeat& from);
  void MergeFrom(const VasHeartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string psi_name = 1;
  inline bool has_psi_name() const;
  inline void clear_psi_name();
  static const int kPsiNameFieldNumber = 1;
  inline const ::std::string& psi_name() const;
  inline void set_psi_name(const ::std::string& value);
  inline void set_psi_name(const char* value);
  inline void set_psi_name(const char* value, size_t size);
  inline ::std::string* mutable_psi_name();
  inline ::std::string* release_psi_name();
  inline void set_allocated_psi_name(::std::string* psi_name);

  // optional .vas.VasHeartbeatParameter params = 2;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::vas::VasHeartbeatParameter& params() const;
  inline ::vas::VasHeartbeatParameter* mutable_params();
  inline ::vas::VasHeartbeatParameter* release_params();
  inline void set_allocated_params(::vas::VasHeartbeatParameter* params);

  // @@protoc_insertion_point(class_scope:vas.VasHeartbeat)
 private:
  inline void set_has_psi_name();
  inline void clear_has_psi_name();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* psi_name_;
  ::vas::VasHeartbeatParameter* params_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasHeartbeat* default_instance_;
};
// -------------------------------------------------------------------

class VasRetrunParamter : public ::google::protobuf::Message {
 public:
  VasRetrunParamter();
  virtual ~VasRetrunParamter();

  VasRetrunParamter(const VasRetrunParamter& from);

  inline VasRetrunParamter& operator=(const VasRetrunParamter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasRetrunParamter& default_instance();

  void Swap(VasRetrunParamter* other);

  // implements Message ----------------------------------------------

  VasRetrunParamter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasRetrunParamter& from);
  void MergeFrom(const VasRetrunParamter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string psi_name = 1;
  inline bool has_psi_name() const;
  inline void clear_psi_name();
  static const int kPsiNameFieldNumber = 1;
  inline const ::std::string& psi_name() const;
  inline void set_psi_name(const ::std::string& value);
  inline void set_psi_name(const char* value);
  inline void set_psi_name(const char* value, size_t size);
  inline ::std::string* mutable_psi_name();
  inline ::std::string* release_psi_name();
  inline void set_allocated_psi_name(::std::string* psi_name);

  // optional int32 node_id = 2;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vas.VasRetrunParamter)
 private:
  inline void set_has_psi_name();
  inline void clear_has_psi_name();
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* psi_name_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 node_id_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasRetrunParamter* default_instance_;
};
// -------------------------------------------------------------------

class VasReturn : public ::google::protobuf::Message {
 public:
  VasReturn();
  virtual ~VasReturn();

  VasReturn(const VasReturn& from);

  inline VasReturn& operator=(const VasReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasReturn& default_instance();

  void Swap(VasReturn* other);

  // implements Message ----------------------------------------------

  VasReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasReturn& from);
  void MergeFrom(const VasReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ret_code = 1;
  inline bool has_ret_code() const;
  inline void clear_ret_code();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::int32 ret_code() const;
  inline void set_ret_code(::google::protobuf::int32 value);

  // optional string ret_msg = 2;
  inline bool has_ret_msg() const;
  inline void clear_ret_msg();
  static const int kRetMsgFieldNumber = 2;
  inline const ::std::string& ret_msg() const;
  inline void set_ret_msg(const ::std::string& value);
  inline void set_ret_msg(const char* value);
  inline void set_ret_msg(const char* value, size_t size);
  inline ::std::string* mutable_ret_msg();
  inline ::std::string* release_ret_msg();
  inline void set_allocated_ret_msg(::std::string* ret_msg);

  // optional .vas.VasRetrunParamter params = 3;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 3;
  inline const ::vas::VasRetrunParamter& params() const;
  inline ::vas::VasRetrunParamter* mutable_params();
  inline ::vas::VasRetrunParamter* release_params();
  inline void set_allocated_params(::vas::VasRetrunParamter* params);

  // @@protoc_insertion_point(class_scope:vas.VasReturn)
 private:
  inline void set_has_ret_code();
  inline void clear_has_ret_code();
  inline void set_has_ret_msg();
  inline void clear_has_ret_msg();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ret_msg_;
  ::vas::VasRetrunParamter* params_;
  ::google::protobuf::int32 ret_code_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasReturn* default_instance_;
};
// -------------------------------------------------------------------

class RegRes : public ::google::protobuf::Message {
 public:
  RegRes();
  virtual ~RegRes();

  RegRes(const RegRes& from);

  inline RegRes& operator=(const RegRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegRes& default_instance();

  void Swap(RegRes* other);

  // implements Message ----------------------------------------------

  RegRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegRes& from);
  void MergeFrom(const RegRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reg_type = 1;
  inline bool has_reg_type() const;
  inline void clear_reg_type();
  static const int kRegTypeFieldNumber = 1;
  inline const ::std::string& reg_type() const;
  inline void set_reg_type(const ::std::string& value);
  inline void set_reg_type(const char* value);
  inline void set_reg_type(const char* value, size_t size);
  inline ::std::string* mutable_reg_type();
  inline ::std::string* release_reg_type();
  inline void set_allocated_reg_type(::std::string* reg_type);

  // optional float score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline float score() const;
  inline void set_score(float value);

  // optional int32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 6;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 6;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vas.RegRes)
 private:
  inline void set_has_reg_type();
  inline void clear_has_reg_type();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reg_type_;
  float score_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static RegRes* default_instance_;
};
// -------------------------------------------------------------------

class VasResultParameter : public ::google::protobuf::Message {
 public:
  VasResultParameter();
  virtual ~VasResultParameter();

  VasResultParameter(const VasResultParameter& from);

  inline VasResultParameter& operator=(const VasResultParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasResultParameter& default_instance();

  void Swap(VasResultParameter* other);

  // implements Message ----------------------------------------------

  VasResultParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasResultParameter& from);
  void MergeFrom(const VasResultParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // optional string service_id = 2;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 2;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // repeated .vas.RegRes result_rects = 3;
  inline int result_rects_size() const;
  inline void clear_result_rects();
  static const int kResultRectsFieldNumber = 3;
  inline const ::vas::RegRes& result_rects(int index) const;
  inline ::vas::RegRes* mutable_result_rects(int index);
  inline ::vas::RegRes* add_result_rects();
  inline const ::google::protobuf::RepeatedPtrField< ::vas::RegRes >&
      result_rects() const;
  inline ::google::protobuf::RepeatedPtrField< ::vas::RegRes >*
      mutable_result_rects();

  // optional int64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vas.VasResultParameter)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::google::protobuf::RepeatedPtrField< ::vas::RegRes > result_rects_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 node_id_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasResultParameter* default_instance_;
};
// -------------------------------------------------------------------

class VasResult : public ::google::protobuf::Message {
 public:
  VasResult();
  virtual ~VasResult();

  VasResult(const VasResult& from);

  inline VasResult& operator=(const VasResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasResult& default_instance();

  void Swap(VasResult* other);

  // implements Message ----------------------------------------------

  VasResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasResult& from);
  void MergeFrom(const VasResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string psi_name = 1;
  inline bool has_psi_name() const;
  inline void clear_psi_name();
  static const int kPsiNameFieldNumber = 1;
  inline const ::std::string& psi_name() const;
  inline void set_psi_name(const ::std::string& value);
  inline void set_psi_name(const char* value);
  inline void set_psi_name(const char* value, size_t size);
  inline ::std::string* mutable_psi_name();
  inline ::std::string* release_psi_name();
  inline void set_allocated_psi_name(::std::string* psi_name);

  // optional .vas.VasResultParameter params = 2;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::vas::VasResultParameter& params() const;
  inline ::vas::VasResultParameter* mutable_params();
  inline ::vas::VasResultParameter* release_params();
  inline void set_allocated_params(::vas::VasResultParameter* params);

  // @@protoc_insertion_point(class_scope:vas.VasResult)
 private:
  inline void set_has_psi_name();
  inline void clear_has_psi_name();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* psi_name_;
  ::vas::VasResultParameter* params_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasResult* default_instance_;
};
// -------------------------------------------------------------------

class VasFeedbackParameter : public ::google::protobuf::Message {
 public:
  VasFeedbackParameter();
  virtual ~VasFeedbackParameter();

  VasFeedbackParameter(const VasFeedbackParameter& from);

  inline VasFeedbackParameter& operator=(const VasFeedbackParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasFeedbackParameter& default_instance();

  void Swap(VasFeedbackParameter* other);

  // implements Message ----------------------------------------------

  VasFeedbackParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasFeedbackParameter& from);
  void MergeFrom(const VasFeedbackParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // optional string service_id = 2;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 2;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional string address_type = 3;
  inline bool has_address_type() const;
  inline void clear_address_type();
  static const int kAddressTypeFieldNumber = 3;
  inline const ::std::string& address_type() const;
  inline void set_address_type(const ::std::string& value);
  inline void set_address_type(const char* value);
  inline void set_address_type(const char* value, size_t size);
  inline ::std::string* mutable_address_type();
  inline ::std::string* release_address_type();
  inline void set_allocated_address_type(::std::string* address_type);

  // optional string device_id = 4;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 4;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional string device_channel = 5;
  inline bool has_device_channel() const;
  inline void clear_device_channel();
  static const int kDeviceChannelFieldNumber = 5;
  inline const ::std::string& device_channel() const;
  inline void set_device_channel(const ::std::string& value);
  inline void set_device_channel(const char* value);
  inline void set_device_channel(const char* value, size_t size);
  inline ::std::string* mutable_device_channel();
  inline ::std::string* release_device_channel();
  inline void set_allocated_device_channel(::std::string* device_channel);

  // optional string address = 6;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 6;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional int32 feedback_code = 7;
  inline bool has_feedback_code() const;
  inline void clear_feedback_code();
  static const int kFeedbackCodeFieldNumber = 7;
  inline ::google::protobuf::int32 feedback_code() const;
  inline void set_feedback_code(::google::protobuf::int32 value);

  // optional string feedback_info = 8;
  inline bool has_feedback_info() const;
  inline void clear_feedback_info();
  static const int kFeedbackInfoFieldNumber = 8;
  inline const ::std::string& feedback_info() const;
  inline void set_feedback_info(const ::std::string& value);
  inline void set_feedback_info(const char* value);
  inline void set_feedback_info(const char* value, size_t size);
  inline ::std::string* mutable_feedback_info();
  inline ::std::string* release_feedback_info();
  inline void set_allocated_feedback_info(::std::string* feedback_info);

  // optional int64 timestamp = 9;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vas.VasFeedbackParameter)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_address_type();
  inline void clear_has_address_type();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_device_channel();
  inline void clear_has_device_channel();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_feedback_code();
  inline void clear_has_feedback_code();
  inline void set_has_feedback_info();
  inline void clear_has_feedback_info();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_id_;
  ::std::string* address_type_;
  ::std::string* device_id_;
  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int32 feedback_code_;
  ::std::string* device_channel_;
  ::std::string* address_;
  ::std::string* feedback_info_;
  ::google::protobuf::int64 timestamp_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasFeedbackParameter* default_instance_;
};
// -------------------------------------------------------------------

class VasFeedback : public ::google::protobuf::Message {
 public:
  VasFeedback();
  virtual ~VasFeedback();

  VasFeedback(const VasFeedback& from);

  inline VasFeedback& operator=(const VasFeedback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VasFeedback& default_instance();

  void Swap(VasFeedback* other);

  // implements Message ----------------------------------------------

  VasFeedback* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VasFeedback& from);
  void MergeFrom(const VasFeedback& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string psi_name = 1;
  inline bool has_psi_name() const;
  inline void clear_psi_name();
  static const int kPsiNameFieldNumber = 1;
  inline const ::std::string& psi_name() const;
  inline void set_psi_name(const ::std::string& value);
  inline void set_psi_name(const char* value);
  inline void set_psi_name(const char* value, size_t size);
  inline ::std::string* mutable_psi_name();
  inline ::std::string* release_psi_name();
  inline void set_allocated_psi_name(::std::string* psi_name);

  // optional .vas.VasFeedbackParameter params = 2;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::vas::VasFeedbackParameter& params() const;
  inline ::vas::VasFeedbackParameter* mutable_params();
  inline ::vas::VasFeedbackParameter* release_params();
  inline void set_allocated_params(::vas::VasFeedbackParameter* params);

  // @@protoc_insertion_point(class_scope:vas.VasFeedback)
 private:
  inline void set_has_psi_name();
  inline void clear_has_psi_name();
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* psi_name_;
  ::vas::VasFeedbackParameter* params_;
  friend void  protobuf_AddDesc_VasProto_2eprototxt();
  friend void protobuf_AssignDesc_VasProto_2eprototxt();
  friend void protobuf_ShutdownFile_VasProto_2eprototxt();

  void InitAsDefaultInstance();
  static VasFeedback* default_instance_;
};
// ===================================================================


// ===================================================================

// NvrParameter

// optional string ip = 7;
inline bool NvrParameter::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NvrParameter::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NvrParameter::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NvrParameter::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NvrParameter::ip() const {
  // @@protoc_insertion_point(field_get:vas.NvrParameter.ip)
  return *ip_;
}
inline void NvrParameter::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:vas.NvrParameter.ip)
}
inline void NvrParameter::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.NvrParameter.ip)
}
inline void NvrParameter::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.NvrParameter.ip)
}
inline ::std::string* NvrParameter::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.NvrParameter.ip)
  return ip_;
}
inline ::std::string* NvrParameter::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NvrParameter::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrParameter.ip)
}

// optional string user_name = 1;
inline bool NvrParameter::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NvrParameter::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NvrParameter::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NvrParameter::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& NvrParameter::user_name() const {
  // @@protoc_insertion_point(field_get:vas.NvrParameter.user_name)
  return *user_name_;
}
inline void NvrParameter::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:vas.NvrParameter.user_name)
}
inline void NvrParameter::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.NvrParameter.user_name)
}
inline void NvrParameter::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.NvrParameter.user_name)
}
inline ::std::string* NvrParameter::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.NvrParameter.user_name)
  return user_name_;
}
inline ::std::string* NvrParameter::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NvrParameter::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrParameter.user_name)
}

// optional string password = 2;
inline bool NvrParameter::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NvrParameter::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NvrParameter::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NvrParameter::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& NvrParameter::password() const {
  // @@protoc_insertion_point(field_get:vas.NvrParameter.password)
  return *password_;
}
inline void NvrParameter::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:vas.NvrParameter.password)
}
inline void NvrParameter::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.NvrParameter.password)
}
inline void NvrParameter::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.NvrParameter.password)
}
inline ::std::string* NvrParameter::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.NvrParameter.password)
  return password_;
}
inline ::std::string* NvrParameter::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NvrParameter::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrParameter.password)
}

// optional uint64 port = 3 [default = 8000];
inline bool NvrParameter::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NvrParameter::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NvrParameter::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NvrParameter::clear_port() {
  port_ = GOOGLE_ULONGLONG(8000);
  clear_has_port();
}
inline ::google::protobuf::uint64 NvrParameter::port() const {
  // @@protoc_insertion_point(field_get:vas.NvrParameter.port)
  return port_;
}
inline void NvrParameter::set_port(::google::protobuf::uint64 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrParameter.port)
}

// optional uint64 connect_timeout = 4 [default = 500000];
inline bool NvrParameter::has_connect_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NvrParameter::set_has_connect_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NvrParameter::clear_has_connect_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NvrParameter::clear_connect_timeout() {
  connect_timeout_ = GOOGLE_ULONGLONG(500000);
  clear_has_connect_timeout();
}
inline ::google::protobuf::uint64 NvrParameter::connect_timeout() const {
  // @@protoc_insertion_point(field_get:vas.NvrParameter.connect_timeout)
  return connect_timeout_;
}
inline void NvrParameter::set_connect_timeout(::google::protobuf::uint64 value) {
  set_has_connect_timeout();
  connect_timeout_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrParameter.connect_timeout)
}

// optional uint64 reconnect_time = 5 [default = 1000000];
inline bool NvrParameter::has_reconnect_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NvrParameter::set_has_reconnect_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NvrParameter::clear_has_reconnect_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NvrParameter::clear_reconnect_time() {
  reconnect_time_ = GOOGLE_ULONGLONG(1000000);
  clear_has_reconnect_time();
}
inline ::google::protobuf::uint64 NvrParameter::reconnect_time() const {
  // @@protoc_insertion_point(field_get:vas.NvrParameter.reconnect_time)
  return reconnect_time_;
}
inline void NvrParameter::set_reconnect_time(::google::protobuf::uint64 value) {
  set_has_reconnect_time();
  reconnect_time_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrParameter.reconnect_time)
}

// optional uint64 check_interval = 6 [default = 5000];
inline bool NvrParameter::has_check_interval() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NvrParameter::set_has_check_interval() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NvrParameter::clear_has_check_interval() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NvrParameter::clear_check_interval() {
  check_interval_ = GOOGLE_ULONGLONG(5000);
  clear_has_check_interval();
}
inline ::google::protobuf::uint64 NvrParameter::check_interval() const {
  // @@protoc_insertion_point(field_get:vas.NvrParameter.check_interval)
  return check_interval_;
}
inline void NvrParameter::set_check_interval(::google::protobuf::uint64 value) {
  set_has_check_interval();
  check_interval_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrParameter.check_interval)
}

// -------------------------------------------------------------------

// NvrChannel

// optional string service_id = 1;
inline bool NvrChannel::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NvrChannel::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NvrChannel::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NvrChannel::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& NvrChannel::service_id() const {
  // @@protoc_insertion_point(field_get:vas.NvrChannel.service_id)
  return *service_id_;
}
inline void NvrChannel::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.NvrChannel.service_id)
}
inline void NvrChannel::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.NvrChannel.service_id)
}
inline void NvrChannel::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.NvrChannel.service_id)
}
inline ::std::string* NvrChannel::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.NvrChannel.service_id)
  return service_id_;
}
inline ::std::string* NvrChannel::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NvrChannel::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrChannel.service_id)
}

// optional int32 channel_no = 2 [default = 0];
inline bool NvrChannel::has_channel_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NvrChannel::set_has_channel_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NvrChannel::clear_has_channel_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NvrChannel::clear_channel_no() {
  channel_no_ = 0;
  clear_has_channel_no();
}
inline ::google::protobuf::int32 NvrChannel::channel_no() const {
  // @@protoc_insertion_point(field_get:vas.NvrChannel.channel_no)
  return channel_no_;
}
inline void NvrChannel::set_channel_no(::google::protobuf::int32 value) {
  set_has_channel_no();
  channel_no_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrChannel.channel_no)
}

// optional .vas.CamStatus cam_status = 3 [default = CAM_OFFLINE];
inline bool NvrChannel::has_cam_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NvrChannel::set_has_cam_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NvrChannel::clear_has_cam_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NvrChannel::clear_cam_status() {
  cam_status_ = 2;
  clear_has_cam_status();
}
inline ::vas::CamStatus NvrChannel::cam_status() const {
  // @@protoc_insertion_point(field_get:vas.NvrChannel.cam_status)
  return static_cast< ::vas::CamStatus >(cam_status_);
}
inline void NvrChannel::set_cam_status(::vas::CamStatus value) {
  assert(::vas::CamStatus_IsValid(value));
  set_has_cam_status();
  cam_status_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrChannel.cam_status)
}

// optional int32 interval_time = 4 [default = 20];
inline bool NvrChannel::has_interval_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NvrChannel::set_has_interval_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NvrChannel::clear_has_interval_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NvrChannel::clear_interval_time() {
  interval_time_ = 20;
  clear_has_interval_time();
}
inline ::google::protobuf::int32 NvrChannel::interval_time() const {
  // @@protoc_insertion_point(field_get:vas.NvrChannel.interval_time)
  return interval_time_;
}
inline void NvrChannel::set_interval_time(::google::protobuf::int32 value) {
  set_has_interval_time();
  interval_time_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrChannel.interval_time)
}

// optional int32 dst_width = 5 [default = 720];
inline bool NvrChannel::has_dst_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NvrChannel::set_has_dst_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NvrChannel::clear_has_dst_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NvrChannel::clear_dst_width() {
  dst_width_ = 720;
  clear_has_dst_width();
}
inline ::google::protobuf::int32 NvrChannel::dst_width() const {
  // @@protoc_insertion_point(field_get:vas.NvrChannel.dst_width)
  return dst_width_;
}
inline void NvrChannel::set_dst_width(::google::protobuf::int32 value) {
  set_has_dst_width();
  dst_width_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrChannel.dst_width)
}

// optional int32 dst_height = 6 [default = 576];
inline bool NvrChannel::has_dst_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NvrChannel::set_has_dst_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NvrChannel::clear_has_dst_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NvrChannel::clear_dst_height() {
  dst_height_ = 576;
  clear_has_dst_height();
}
inline ::google::protobuf::int32 NvrChannel::dst_height() const {
  // @@protoc_insertion_point(field_get:vas.NvrChannel.dst_height)
  return dst_height_;
}
inline void NvrChannel::set_dst_height(::google::protobuf::int32 value) {
  set_has_dst_height();
  dst_height_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrChannel.dst_height)
}

// -------------------------------------------------------------------

// DecodeParameter

// optional string service_id = 1;
inline bool DecodeParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecodeParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecodeParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecodeParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& DecodeParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.service_id)
  return *service_id_;
}
inline void DecodeParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.service_id)
}
inline void DecodeParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.DecodeParameter.service_id)
}
inline void DecodeParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.DecodeParameter.service_id)
}
inline ::std::string* DecodeParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.DecodeParameter.service_id)
  return service_id_;
}
inline ::std::string* DecodeParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DecodeParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.DecodeParameter.service_id)
}

// optional .vas.DecodeMethod decode_method = 2 [default = DECODE_CPU];
inline bool DecodeParameter::has_decode_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecodeParameter::set_has_decode_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecodeParameter::clear_has_decode_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecodeParameter::clear_decode_method() {
  decode_method_ = 0;
  clear_has_decode_method();
}
inline ::vas::DecodeMethod DecodeParameter::decode_method() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.decode_method)
  return static_cast< ::vas::DecodeMethod >(decode_method_);
}
inline void DecodeParameter::set_decode_method(::vas::DecodeMethod value) {
  assert(::vas::DecodeMethod_IsValid(value));
  set_has_decode_method();
  decode_method_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.decode_method)
}

// optional uint32 dst_width = 3 [default = 800];
inline bool DecodeParameter::has_dst_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecodeParameter::set_has_dst_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecodeParameter::clear_has_dst_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecodeParameter::clear_dst_width() {
  dst_width_ = 800u;
  clear_has_dst_width();
}
inline ::google::protobuf::uint32 DecodeParameter::dst_width() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.dst_width)
  return dst_width_;
}
inline void DecodeParameter::set_dst_width(::google::protobuf::uint32 value) {
  set_has_dst_width();
  dst_width_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.dst_width)
}

// optional uint32 dst_height = 4 [default = 576];
inline bool DecodeParameter::has_dst_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DecodeParameter::set_has_dst_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DecodeParameter::clear_has_dst_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DecodeParameter::clear_dst_height() {
  dst_height_ = 576u;
  clear_has_dst_height();
}
inline ::google::protobuf::uint32 DecodeParameter::dst_height() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.dst_height)
  return dst_height_;
}
inline void DecodeParameter::set_dst_height(::google::protobuf::uint32 value) {
  set_has_dst_height();
  dst_height_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.dst_height)
}

// optional uint32 interval_time = 5 [default = 20];
inline bool DecodeParameter::has_interval_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DecodeParameter::set_has_interval_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DecodeParameter::clear_has_interval_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DecodeParameter::clear_interval_time() {
  interval_time_ = 20u;
  clear_has_interval_time();
}
inline ::google::protobuf::uint32 DecodeParameter::interval_time() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.interval_time)
  return interval_time_;
}
inline void DecodeParameter::set_interval_time(::google::protobuf::uint32 value) {
  set_has_interval_time();
  interval_time_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.interval_time)
}

// optional uint32 max_reconnect_times = 6 [default = 3];
inline bool DecodeParameter::has_max_reconnect_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DecodeParameter::set_has_max_reconnect_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DecodeParameter::clear_has_max_reconnect_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DecodeParameter::clear_max_reconnect_times() {
  max_reconnect_times_ = 3u;
  clear_has_max_reconnect_times();
}
inline ::google::protobuf::uint32 DecodeParameter::max_reconnect_times() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.max_reconnect_times)
  return max_reconnect_times_;
}
inline void DecodeParameter::set_max_reconnect_times(::google::protobuf::uint32 value) {
  set_has_max_reconnect_times();
  max_reconnect_times_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.max_reconnect_times)
}

// optional uint32 reconnect_sleep_times = 14 [default = 10000];
inline bool DecodeParameter::has_reconnect_sleep_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DecodeParameter::set_has_reconnect_sleep_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DecodeParameter::clear_has_reconnect_sleep_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DecodeParameter::clear_reconnect_sleep_times() {
  reconnect_sleep_times_ = 10000u;
  clear_has_reconnect_sleep_times();
}
inline ::google::protobuf::uint32 DecodeParameter::reconnect_sleep_times() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.reconnect_sleep_times)
  return reconnect_sleep_times_;
}
inline void DecodeParameter::set_reconnect_sleep_times(::google::protobuf::uint32 value) {
  set_has_reconnect_sleep_times();
  reconnect_sleep_times_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.reconnect_sleep_times)
}

// optional uint32 max_decode_error_frames = 15 [default = 500];
inline bool DecodeParameter::has_max_decode_error_frames() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DecodeParameter::set_has_max_decode_error_frames() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DecodeParameter::clear_has_max_decode_error_frames() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DecodeParameter::clear_max_decode_error_frames() {
  max_decode_error_frames_ = 500u;
  clear_has_max_decode_error_frames();
}
inline ::google::protobuf::uint32 DecodeParameter::max_decode_error_frames() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.max_decode_error_frames)
  return max_decode_error_frames_;
}
inline void DecodeParameter::set_max_decode_error_frames(::google::protobuf::uint32 value) {
  set_has_max_decode_error_frames();
  max_decode_error_frames_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.max_decode_error_frames)
}

// optional string url = 7;
inline bool DecodeParameter::has_url() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DecodeParameter::set_has_url() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DecodeParameter::clear_has_url() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DecodeParameter::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& DecodeParameter::url() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.url)
  return *url_;
}
inline void DecodeParameter::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.url)
}
inline void DecodeParameter::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.DecodeParameter.url)
}
inline void DecodeParameter::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.DecodeParameter.url)
}
inline ::std::string* DecodeParameter::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.DecodeParameter.url)
  return url_;
}
inline ::std::string* DecodeParameter::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DecodeParameter::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.DecodeParameter.url)
}

// optional .vas.StreamStatus stream_status = 9 [default = STREAM_UNKNOWN];
inline bool DecodeParameter::has_stream_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DecodeParameter::set_has_stream_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DecodeParameter::clear_has_stream_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DecodeParameter::clear_stream_status() {
  stream_status_ = 0;
  clear_has_stream_status();
}
inline ::vas::StreamStatus DecodeParameter::stream_status() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.stream_status)
  return static_cast< ::vas::StreamStatus >(stream_status_);
}
inline void DecodeParameter::set_stream_status(::vas::StreamStatus value) {
  assert(::vas::StreamStatus_IsValid(value));
  set_has_stream_status();
  stream_status_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.stream_status)
}

// optional uint64 total_ms = 10 [default = 1000000000];
inline bool DecodeParameter::has_total_ms() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DecodeParameter::set_has_total_ms() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DecodeParameter::clear_has_total_ms() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DecodeParameter::clear_total_ms() {
  total_ms_ = GOOGLE_ULONGLONG(1000000000);
  clear_has_total_ms();
}
inline ::google::protobuf::uint64 DecodeParameter::total_ms() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.total_ms)
  return total_ms_;
}
inline void DecodeParameter::set_total_ms(::google::protobuf::uint64 value) {
  set_has_total_ms();
  total_ms_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.total_ms)
}

// optional uint64 connect_timeout = 11 [default = 500000];
inline bool DecodeParameter::has_connect_timeout() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DecodeParameter::set_has_connect_timeout() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DecodeParameter::clear_has_connect_timeout() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DecodeParameter::clear_connect_timeout() {
  connect_timeout_ = GOOGLE_ULONGLONG(500000);
  clear_has_connect_timeout();
}
inline ::google::protobuf::uint64 DecodeParameter::connect_timeout() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.connect_timeout)
  return connect_timeout_;
}
inline void DecodeParameter::set_connect_timeout(::google::protobuf::uint64 value) {
  set_has_connect_timeout();
  connect_timeout_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.connect_timeout)
}

// optional .vas.VideoSource video_source = 12;
inline bool DecodeParameter::has_video_source() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DecodeParameter::set_has_video_source() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DecodeParameter::clear_has_video_source() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DecodeParameter::clear_video_source() {
  video_source_ = 1;
  clear_has_video_source();
}
inline ::vas::VideoSource DecodeParameter::video_source() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.video_source)
  return static_cast< ::vas::VideoSource >(video_source_);
}
inline void DecodeParameter::set_video_source(::vas::VideoSource value) {
  assert(::vas::VideoSource_IsValid(value));
  set_has_video_source();
  video_source_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.video_source)
}

// optional bool print_decode_count = 13 [default = false];
inline bool DecodeParameter::has_print_decode_count() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DecodeParameter::set_has_print_decode_count() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DecodeParameter::clear_has_print_decode_count() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DecodeParameter::clear_print_decode_count() {
  print_decode_count_ = false;
  clear_has_print_decode_count();
}
inline bool DecodeParameter::print_decode_count() const {
  // @@protoc_insertion_point(field_get:vas.DecodeParameter.print_decode_count)
  return print_decode_count_;
}
inline void DecodeParameter::set_print_decode_count(bool value) {
  set_has_print_decode_count();
  print_decode_count_ = value;
  // @@protoc_insertion_point(field_set:vas.DecodeParameter.print_decode_count)
}

// -------------------------------------------------------------------

// BgGuassianParameter

// optional uint32 num_history = 1 [default = 20];
inline bool BgGuassianParameter::has_num_history() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BgGuassianParameter::set_has_num_history() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BgGuassianParameter::clear_has_num_history() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BgGuassianParameter::clear_num_history() {
  num_history_ = 20u;
  clear_has_num_history();
}
inline ::google::protobuf::uint32 BgGuassianParameter::num_history() const {
  // @@protoc_insertion_point(field_get:vas.BgGuassianParameter.num_history)
  return num_history_;
}
inline void BgGuassianParameter::set_num_history(::google::protobuf::uint32 value) {
  set_has_num_history();
  num_history_ = value;
  // @@protoc_insertion_point(field_set:vas.BgGuassianParameter.num_history)
}

// optional uint32 var_threshold = 2 [default = 4];
inline bool BgGuassianParameter::has_var_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BgGuassianParameter::set_has_var_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BgGuassianParameter::clear_has_var_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BgGuassianParameter::clear_var_threshold() {
  var_threshold_ = 4u;
  clear_has_var_threshold();
}
inline ::google::protobuf::uint32 BgGuassianParameter::var_threshold() const {
  // @@protoc_insertion_point(field_get:vas.BgGuassianParameter.var_threshold)
  return var_threshold_;
}
inline void BgGuassianParameter::set_var_threshold(::google::protobuf::uint32 value) {
  set_has_var_threshold();
  var_threshold_ = value;
  // @@protoc_insertion_point(field_set:vas.BgGuassianParameter.var_threshold)
}

// optional bool shadow_detection = 3 [default = true];
inline bool BgGuassianParameter::has_shadow_detection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BgGuassianParameter::set_has_shadow_detection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BgGuassianParameter::clear_has_shadow_detection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BgGuassianParameter::clear_shadow_detection() {
  shadow_detection_ = true;
  clear_has_shadow_detection();
}
inline bool BgGuassianParameter::shadow_detection() const {
  // @@protoc_insertion_point(field_get:vas.BgGuassianParameter.shadow_detection)
  return shadow_detection_;
}
inline void BgGuassianParameter::set_shadow_detection(bool value) {
  set_has_shadow_detection();
  shadow_detection_ = value;
  // @@protoc_insertion_point(field_set:vas.BgGuassianParameter.shadow_detection)
}

// optional float learn_rate = 4 [default = 0.01];
inline bool BgGuassianParameter::has_learn_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BgGuassianParameter::set_has_learn_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BgGuassianParameter::clear_has_learn_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BgGuassianParameter::clear_learn_rate() {
  learn_rate_ = 0.01f;
  clear_has_learn_rate();
}
inline float BgGuassianParameter::learn_rate() const {
  // @@protoc_insertion_point(field_get:vas.BgGuassianParameter.learn_rate)
  return learn_rate_;
}
inline void BgGuassianParameter::set_learn_rate(float value) {
  set_has_learn_rate();
  learn_rate_ = value;
  // @@protoc_insertion_point(field_set:vas.BgGuassianParameter.learn_rate)
}

// -------------------------------------------------------------------

// BgVibeParameter

// optional uint32 num_samples = 1 [default = 20];
inline bool BgVibeParameter::has_num_samples() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BgVibeParameter::set_has_num_samples() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BgVibeParameter::clear_has_num_samples() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BgVibeParameter::clear_num_samples() {
  num_samples_ = 20u;
  clear_has_num_samples();
}
inline ::google::protobuf::uint32 BgVibeParameter::num_samples() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.num_samples)
  return num_samples_;
}
inline void BgVibeParameter::set_num_samples(::google::protobuf::uint32 value) {
  set_has_num_samples();
  num_samples_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.num_samples)
}

// optional uint32 min_match = 2 [default = 4];
inline bool BgVibeParameter::has_min_match() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BgVibeParameter::set_has_min_match() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BgVibeParameter::clear_has_min_match() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BgVibeParameter::clear_min_match() {
  min_match_ = 4u;
  clear_has_min_match();
}
inline ::google::protobuf::uint32 BgVibeParameter::min_match() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.min_match)
  return min_match_;
}
inline void BgVibeParameter::set_min_match(::google::protobuf::uint32 value) {
  set_has_min_match();
  min_match_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.min_match)
}

// optional uint32 radius = 3 [default = 10];
inline bool BgVibeParameter::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BgVibeParameter::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BgVibeParameter::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BgVibeParameter::clear_radius() {
  radius_ = 10u;
  clear_has_radius();
}
inline ::google::protobuf::uint32 BgVibeParameter::radius() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.radius)
  return radius_;
}
inline void BgVibeParameter::set_radius(::google::protobuf::uint32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.radius)
}

// optional uint32 subsample_factor = 4 [default = 16];
inline bool BgVibeParameter::has_subsample_factor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BgVibeParameter::set_has_subsample_factor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BgVibeParameter::clear_has_subsample_factor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BgVibeParameter::clear_subsample_factor() {
  subsample_factor_ = 16u;
  clear_has_subsample_factor();
}
inline ::google::protobuf::uint32 BgVibeParameter::subsample_factor() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.subsample_factor)
  return subsample_factor_;
}
inline void BgVibeParameter::set_subsample_factor(::google::protobuf::uint32 value) {
  set_has_subsample_factor();
  subsample_factor_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.subsample_factor)
}

// optional uint32 bg2_delay = 5 [default = 50];
inline bool BgVibeParameter::has_bg2_delay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BgVibeParameter::set_has_bg2_delay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BgVibeParameter::clear_has_bg2_delay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BgVibeParameter::clear_bg2_delay() {
  bg2_delay_ = 50u;
  clear_has_bg2_delay();
}
inline ::google::protobuf::uint32 BgVibeParameter::bg2_delay() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.bg2_delay)
  return bg2_delay_;
}
inline void BgVibeParameter::set_bg2_delay(::google::protobuf::uint32 value) {
  set_has_bg2_delay();
  bg2_delay_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.bg2_delay)
}

// optional uint32 max_mismatch_count = 6 [default = 50];
inline bool BgVibeParameter::has_max_mismatch_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BgVibeParameter::set_has_max_mismatch_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BgVibeParameter::clear_has_max_mismatch_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BgVibeParameter::clear_max_mismatch_count() {
  max_mismatch_count_ = 50u;
  clear_has_max_mismatch_count();
}
inline ::google::protobuf::uint32 BgVibeParameter::max_mismatch_count() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.max_mismatch_count)
  return max_mismatch_count_;
}
inline void BgVibeParameter::set_max_mismatch_count(::google::protobuf::uint32 value) {
  set_has_max_mismatch_count();
  max_mismatch_count_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.max_mismatch_count)
}

// optional bool double_bg = 7 [default = false];
inline bool BgVibeParameter::has_double_bg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BgVibeParameter::set_has_double_bg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BgVibeParameter::clear_has_double_bg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BgVibeParameter::clear_double_bg() {
  double_bg_ = false;
  clear_has_double_bg();
}
inline bool BgVibeParameter::double_bg() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.double_bg)
  return double_bg_;
}
inline void BgVibeParameter::set_double_bg(bool value) {
  set_has_double_bg();
  double_bg_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.double_bg)
}

// optional float learn_rate = 8 [default = 0.5];
inline bool BgVibeParameter::has_learn_rate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BgVibeParameter::set_has_learn_rate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BgVibeParameter::clear_has_learn_rate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BgVibeParameter::clear_learn_rate() {
  learn_rate_ = 0.5f;
  clear_has_learn_rate();
}
inline float BgVibeParameter::learn_rate() const {
  // @@protoc_insertion_point(field_get:vas.BgVibeParameter.learn_rate)
  return learn_rate_;
}
inline void BgVibeParameter::set_learn_rate(float value) {
  set_has_learn_rate();
  learn_rate_ = value;
  // @@protoc_insertion_point(field_set:vas.BgVibeParameter.learn_rate)
}

// -------------------------------------------------------------------

// BgOperation

// optional uint32 morphology_open_times = 1 [default = 1];
inline bool BgOperation::has_morphology_open_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BgOperation::set_has_morphology_open_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BgOperation::clear_has_morphology_open_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BgOperation::clear_morphology_open_times() {
  morphology_open_times_ = 1u;
  clear_has_morphology_open_times();
}
inline ::google::protobuf::uint32 BgOperation::morphology_open_times() const {
  // @@protoc_insertion_point(field_get:vas.BgOperation.morphology_open_times)
  return morphology_open_times_;
}
inline void BgOperation::set_morphology_open_times(::google::protobuf::uint32 value) {
  set_has_morphology_open_times();
  morphology_open_times_ = value;
  // @@protoc_insertion_point(field_set:vas.BgOperation.morphology_open_times)
}

// optional uint32 dilate_times = 2 [default = 1];
inline bool BgOperation::has_dilate_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BgOperation::set_has_dilate_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BgOperation::clear_has_dilate_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BgOperation::clear_dilate_times() {
  dilate_times_ = 1u;
  clear_has_dilate_times();
}
inline ::google::protobuf::uint32 BgOperation::dilate_times() const {
  // @@protoc_insertion_point(field_get:vas.BgOperation.dilate_times)
  return dilate_times_;
}
inline void BgOperation::set_dilate_times(::google::protobuf::uint32 value) {
  set_has_dilate_times();
  dilate_times_ = value;
  // @@protoc_insertion_point(field_set:vas.BgOperation.dilate_times)
}

// -------------------------------------------------------------------

// BgParameter

// optional .vas.BgMethod bg_method = 1 [default = GUASSIAN_CPU];
inline bool BgParameter::has_bg_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BgParameter::set_has_bg_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BgParameter::clear_has_bg_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BgParameter::clear_bg_method() {
  bg_method_ = 2;
  clear_has_bg_method();
}
inline ::vas::BgMethod BgParameter::bg_method() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.bg_method)
  return static_cast< ::vas::BgMethod >(bg_method_);
}
inline void BgParameter::set_bg_method(::vas::BgMethod value) {
  assert(::vas::BgMethod_IsValid(value));
  set_has_bg_method();
  bg_method_ = value;
  // @@protoc_insertion_point(field_set:vas.BgParameter.bg_method)
}

// optional float stable_threshold = 2 [default = 0.5];
inline bool BgParameter::has_stable_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BgParameter::set_has_stable_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BgParameter::clear_has_stable_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BgParameter::clear_stable_threshold() {
  stable_threshold_ = 0.5f;
  clear_has_stable_threshold();
}
inline float BgParameter::stable_threshold() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.stable_threshold)
  return stable_threshold_;
}
inline void BgParameter::set_stable_threshold(float value) {
  set_has_stable_threshold();
  stable_threshold_ = value;
  // @@protoc_insertion_point(field_set:vas.BgParameter.stable_threshold)
}

// optional .vas.BgGuassianParameter guassian_parameter = 3;
inline bool BgParameter::has_guassian_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BgParameter::set_has_guassian_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BgParameter::clear_has_guassian_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BgParameter::clear_guassian_parameter() {
  if (guassian_parameter_ != NULL) guassian_parameter_->::vas::BgGuassianParameter::Clear();
  clear_has_guassian_parameter();
}
inline const ::vas::BgGuassianParameter& BgParameter::guassian_parameter() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.guassian_parameter)
  return guassian_parameter_ != NULL ? *guassian_parameter_ : *default_instance_->guassian_parameter_;
}
inline ::vas::BgGuassianParameter* BgParameter::mutable_guassian_parameter() {
  set_has_guassian_parameter();
  if (guassian_parameter_ == NULL) guassian_parameter_ = new ::vas::BgGuassianParameter;
  // @@protoc_insertion_point(field_mutable:vas.BgParameter.guassian_parameter)
  return guassian_parameter_;
}
inline ::vas::BgGuassianParameter* BgParameter::release_guassian_parameter() {
  clear_has_guassian_parameter();
  ::vas::BgGuassianParameter* temp = guassian_parameter_;
  guassian_parameter_ = NULL;
  return temp;
}
inline void BgParameter::set_allocated_guassian_parameter(::vas::BgGuassianParameter* guassian_parameter) {
  delete guassian_parameter_;
  guassian_parameter_ = guassian_parameter;
  if (guassian_parameter) {
    set_has_guassian_parameter();
  } else {
    clear_has_guassian_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.BgParameter.guassian_parameter)
}

// optional .vas.BgVibeParameter vibe_parameter = 4;
inline bool BgParameter::has_vibe_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BgParameter::set_has_vibe_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BgParameter::clear_has_vibe_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BgParameter::clear_vibe_parameter() {
  if (vibe_parameter_ != NULL) vibe_parameter_->::vas::BgVibeParameter::Clear();
  clear_has_vibe_parameter();
}
inline const ::vas::BgVibeParameter& BgParameter::vibe_parameter() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.vibe_parameter)
  return vibe_parameter_ != NULL ? *vibe_parameter_ : *default_instance_->vibe_parameter_;
}
inline ::vas::BgVibeParameter* BgParameter::mutable_vibe_parameter() {
  set_has_vibe_parameter();
  if (vibe_parameter_ == NULL) vibe_parameter_ = new ::vas::BgVibeParameter;
  // @@protoc_insertion_point(field_mutable:vas.BgParameter.vibe_parameter)
  return vibe_parameter_;
}
inline ::vas::BgVibeParameter* BgParameter::release_vibe_parameter() {
  clear_has_vibe_parameter();
  ::vas::BgVibeParameter* temp = vibe_parameter_;
  vibe_parameter_ = NULL;
  return temp;
}
inline void BgParameter::set_allocated_vibe_parameter(::vas::BgVibeParameter* vibe_parameter) {
  delete vibe_parameter_;
  vibe_parameter_ = vibe_parameter;
  if (vibe_parameter) {
    set_has_vibe_parameter();
  } else {
    clear_has_vibe_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.BgParameter.vibe_parameter)
}

// optional .vas.BgOperation bg_operation = 5;
inline bool BgParameter::has_bg_operation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BgParameter::set_has_bg_operation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BgParameter::clear_has_bg_operation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BgParameter::clear_bg_operation() {
  if (bg_operation_ != NULL) bg_operation_->::vas::BgOperation::Clear();
  clear_has_bg_operation();
}
inline const ::vas::BgOperation& BgParameter::bg_operation() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.bg_operation)
  return bg_operation_ != NULL ? *bg_operation_ : *default_instance_->bg_operation_;
}
inline ::vas::BgOperation* BgParameter::mutable_bg_operation() {
  set_has_bg_operation();
  if (bg_operation_ == NULL) bg_operation_ = new ::vas::BgOperation;
  // @@protoc_insertion_point(field_mutable:vas.BgParameter.bg_operation)
  return bg_operation_;
}
inline ::vas::BgOperation* BgParameter::release_bg_operation() {
  clear_has_bg_operation();
  ::vas::BgOperation* temp = bg_operation_;
  bg_operation_ = NULL;
  return temp;
}
inline void BgParameter::set_allocated_bg_operation(::vas::BgOperation* bg_operation) {
  delete bg_operation_;
  bg_operation_ = bg_operation;
  if (bg_operation) {
    set_has_bg_operation();
  } else {
    clear_has_bg_operation();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.BgParameter.bg_operation)
}

// optional .vas.BgStatus bg_status = 6 [default = BG_UNINIALIZED];
inline bool BgParameter::has_bg_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BgParameter::set_has_bg_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BgParameter::clear_has_bg_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BgParameter::clear_bg_status() {
  bg_status_ = 0;
  clear_has_bg_status();
}
inline ::vas::BgStatus BgParameter::bg_status() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.bg_status)
  return static_cast< ::vas::BgStatus >(bg_status_);
}
inline void BgParameter::set_bg_status(::vas::BgStatus value) {
  assert(::vas::BgStatus_IsValid(value));
  set_has_bg_status();
  bg_status_ = value;
  // @@protoc_insertion_point(field_set:vas.BgParameter.bg_status)
}

// optional uint32 bg_width = 7 [default = 420];
inline bool BgParameter::has_bg_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BgParameter::set_has_bg_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BgParameter::clear_has_bg_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BgParameter::clear_bg_width() {
  bg_width_ = 420u;
  clear_has_bg_width();
}
inline ::google::protobuf::uint32 BgParameter::bg_width() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.bg_width)
  return bg_width_;
}
inline void BgParameter::set_bg_width(::google::protobuf::uint32 value) {
  set_has_bg_width();
  bg_width_ = value;
  // @@protoc_insertion_point(field_set:vas.BgParameter.bg_width)
}

// optional uint32 bg_height = 8 [default = 320];
inline bool BgParameter::has_bg_height() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BgParameter::set_has_bg_height() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BgParameter::clear_has_bg_height() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BgParameter::clear_bg_height() {
  bg_height_ = 320u;
  clear_has_bg_height();
}
inline ::google::protobuf::uint32 BgParameter::bg_height() const {
  // @@protoc_insertion_point(field_get:vas.BgParameter.bg_height)
  return bg_height_;
}
inline void BgParameter::set_bg_height(::google::protobuf::uint32 value) {
  set_has_bg_height();
  bg_height_ = value;
  // @@protoc_insertion_point(field_set:vas.BgParameter.bg_height)
}

// -------------------------------------------------------------------

// ColorThreshold

// optional float lower = 1 [default = 0];
inline bool ColorThreshold::has_lower() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColorThreshold::set_has_lower() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColorThreshold::clear_has_lower() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColorThreshold::clear_lower() {
  lower_ = 0;
  clear_has_lower();
}
inline float ColorThreshold::lower() const {
  // @@protoc_insertion_point(field_get:vas.ColorThreshold.lower)
  return lower_;
}
inline void ColorThreshold::set_lower(float value) {
  set_has_lower();
  lower_ = value;
  // @@protoc_insertion_point(field_set:vas.ColorThreshold.lower)
}

// optional float upper = 2 [default = 255];
inline bool ColorThreshold::has_upper() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColorThreshold::set_has_upper() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColorThreshold::clear_has_upper() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColorThreshold::clear_upper() {
  upper_ = 255;
  clear_has_upper();
}
inline float ColorThreshold::upper() const {
  // @@protoc_insertion_point(field_get:vas.ColorThreshold.upper)
  return upper_;
}
inline void ColorThreshold::set_upper(float value) {
  set_has_upper();
  upper_ = value;
  // @@protoc_insertion_point(field_set:vas.ColorThreshold.upper)
}

// -------------------------------------------------------------------

// FilterParameter

// optional uint32 contour_area_threshold = 1 [default = 500];
inline bool FilterParameter::has_contour_area_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterParameter::set_has_contour_area_threshold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterParameter::clear_has_contour_area_threshold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterParameter::clear_contour_area_threshold() {
  contour_area_threshold_ = 500u;
  clear_has_contour_area_threshold();
}
inline ::google::protobuf::uint32 FilterParameter::contour_area_threshold() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.contour_area_threshold)
  return contour_area_threshold_;
}
inline void FilterParameter::set_contour_area_threshold(::google::protobuf::uint32 value) {
  set_has_contour_area_threshold();
  contour_area_threshold_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.contour_area_threshold)
}

// optional uint32 contour_perimeter_threshold = 2 [default = 10];
inline bool FilterParameter::has_contour_perimeter_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterParameter::set_has_contour_perimeter_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterParameter::clear_has_contour_perimeter_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterParameter::clear_contour_perimeter_threshold() {
  contour_perimeter_threshold_ = 10u;
  clear_has_contour_perimeter_threshold();
}
inline ::google::protobuf::uint32 FilterParameter::contour_perimeter_threshold() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.contour_perimeter_threshold)
  return contour_perimeter_threshold_;
}
inline void FilterParameter::set_contour_perimeter_threshold(::google::protobuf::uint32 value) {
  set_has_contour_perimeter_threshold();
  contour_perimeter_threshold_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.contour_perimeter_threshold)
}

// optional float area_perimeter_ratio_threshold = 3 [default = 0.01];
inline bool FilterParameter::has_area_perimeter_ratio_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterParameter::set_has_area_perimeter_ratio_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterParameter::clear_has_area_perimeter_ratio_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterParameter::clear_area_perimeter_ratio_threshold() {
  area_perimeter_ratio_threshold_ = 0.01f;
  clear_has_area_perimeter_ratio_threshold();
}
inline float FilterParameter::area_perimeter_ratio_threshold() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.area_perimeter_ratio_threshold)
  return area_perimeter_ratio_threshold_;
}
inline void FilterParameter::set_area_perimeter_ratio_threshold(float value) {
  set_has_area_perimeter_ratio_threshold();
  area_perimeter_ratio_threshold_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.area_perimeter_ratio_threshold)
}

// optional .vas.FilterType filter_type = 12 [default = SMOKE_FILTER];
inline bool FilterParameter::has_filter_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterParameter::set_has_filter_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterParameter::clear_has_filter_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterParameter::clear_filter_type() {
  filter_type_ = 1;
  clear_has_filter_type();
}
inline ::vas::FilterType FilterParameter::filter_type() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.filter_type)
  return static_cast< ::vas::FilterType >(filter_type_);
}
inline void FilterParameter::set_filter_type(::vas::FilterType value) {
  assert(::vas::FilterType_IsValid(value));
  set_has_filter_type();
  filter_type_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.filter_type)
}

// optional .vas.ColorThreshold rgb_th_1 = 4;
inline bool FilterParameter::has_rgb_th_1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FilterParameter::set_has_rgb_th_1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FilterParameter::clear_has_rgb_th_1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FilterParameter::clear_rgb_th_1() {
  if (rgb_th_1_ != NULL) rgb_th_1_->::vas::ColorThreshold::Clear();
  clear_has_rgb_th_1();
}
inline const ::vas::ColorThreshold& FilterParameter::rgb_th_1() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.rgb_th_1)
  return rgb_th_1_ != NULL ? *rgb_th_1_ : *default_instance_->rgb_th_1_;
}
inline ::vas::ColorThreshold* FilterParameter::mutable_rgb_th_1() {
  set_has_rgb_th_1();
  if (rgb_th_1_ == NULL) rgb_th_1_ = new ::vas::ColorThreshold;
  // @@protoc_insertion_point(field_mutable:vas.FilterParameter.rgb_th_1)
  return rgb_th_1_;
}
inline ::vas::ColorThreshold* FilterParameter::release_rgb_th_1() {
  clear_has_rgb_th_1();
  ::vas::ColorThreshold* temp = rgb_th_1_;
  rgb_th_1_ = NULL;
  return temp;
}
inline void FilterParameter::set_allocated_rgb_th_1(::vas::ColorThreshold* rgb_th_1) {
  delete rgb_th_1_;
  rgb_th_1_ = rgb_th_1;
  if (rgb_th_1) {
    set_has_rgb_th_1();
  } else {
    clear_has_rgb_th_1();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.FilterParameter.rgb_th_1)
}

// optional .vas.ColorThreshold rgb_th_2 = 5;
inline bool FilterParameter::has_rgb_th_2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FilterParameter::set_has_rgb_th_2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FilterParameter::clear_has_rgb_th_2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FilterParameter::clear_rgb_th_2() {
  if (rgb_th_2_ != NULL) rgb_th_2_->::vas::ColorThreshold::Clear();
  clear_has_rgb_th_2();
}
inline const ::vas::ColorThreshold& FilterParameter::rgb_th_2() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.rgb_th_2)
  return rgb_th_2_ != NULL ? *rgb_th_2_ : *default_instance_->rgb_th_2_;
}
inline ::vas::ColorThreshold* FilterParameter::mutable_rgb_th_2() {
  set_has_rgb_th_2();
  if (rgb_th_2_ == NULL) rgb_th_2_ = new ::vas::ColorThreshold;
  // @@protoc_insertion_point(field_mutable:vas.FilterParameter.rgb_th_2)
  return rgb_th_2_;
}
inline ::vas::ColorThreshold* FilterParameter::release_rgb_th_2() {
  clear_has_rgb_th_2();
  ::vas::ColorThreshold* temp = rgb_th_2_;
  rgb_th_2_ = NULL;
  return temp;
}
inline void FilterParameter::set_allocated_rgb_th_2(::vas::ColorThreshold* rgb_th_2) {
  delete rgb_th_2_;
  rgb_th_2_ = rgb_th_2;
  if (rgb_th_2) {
    set_has_rgb_th_2();
  } else {
    clear_has_rgb_th_2();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.FilterParameter.rgb_th_2)
}

// optional .vas.ColorThreshold ycbcr_th_1 = 6;
inline bool FilterParameter::has_ycbcr_th_1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FilterParameter::set_has_ycbcr_th_1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FilterParameter::clear_has_ycbcr_th_1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FilterParameter::clear_ycbcr_th_1() {
  if (ycbcr_th_1_ != NULL) ycbcr_th_1_->::vas::ColorThreshold::Clear();
  clear_has_ycbcr_th_1();
}
inline const ::vas::ColorThreshold& FilterParameter::ycbcr_th_1() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.ycbcr_th_1)
  return ycbcr_th_1_ != NULL ? *ycbcr_th_1_ : *default_instance_->ycbcr_th_1_;
}
inline ::vas::ColorThreshold* FilterParameter::mutable_ycbcr_th_1() {
  set_has_ycbcr_th_1();
  if (ycbcr_th_1_ == NULL) ycbcr_th_1_ = new ::vas::ColorThreshold;
  // @@protoc_insertion_point(field_mutable:vas.FilterParameter.ycbcr_th_1)
  return ycbcr_th_1_;
}
inline ::vas::ColorThreshold* FilterParameter::release_ycbcr_th_1() {
  clear_has_ycbcr_th_1();
  ::vas::ColorThreshold* temp = ycbcr_th_1_;
  ycbcr_th_1_ = NULL;
  return temp;
}
inline void FilterParameter::set_allocated_ycbcr_th_1(::vas::ColorThreshold* ycbcr_th_1) {
  delete ycbcr_th_1_;
  ycbcr_th_1_ = ycbcr_th_1;
  if (ycbcr_th_1) {
    set_has_ycbcr_th_1();
  } else {
    clear_has_ycbcr_th_1();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.FilterParameter.ycbcr_th_1)
}

// optional .vas.ColorThreshold ycbcr_th_2 = 7;
inline bool FilterParameter::has_ycbcr_th_2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FilterParameter::set_has_ycbcr_th_2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FilterParameter::clear_has_ycbcr_th_2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FilterParameter::clear_ycbcr_th_2() {
  if (ycbcr_th_2_ != NULL) ycbcr_th_2_->::vas::ColorThreshold::Clear();
  clear_has_ycbcr_th_2();
}
inline const ::vas::ColorThreshold& FilterParameter::ycbcr_th_2() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.ycbcr_th_2)
  return ycbcr_th_2_ != NULL ? *ycbcr_th_2_ : *default_instance_->ycbcr_th_2_;
}
inline ::vas::ColorThreshold* FilterParameter::mutable_ycbcr_th_2() {
  set_has_ycbcr_th_2();
  if (ycbcr_th_2_ == NULL) ycbcr_th_2_ = new ::vas::ColorThreshold;
  // @@protoc_insertion_point(field_mutable:vas.FilterParameter.ycbcr_th_2)
  return ycbcr_th_2_;
}
inline ::vas::ColorThreshold* FilterParameter::release_ycbcr_th_2() {
  clear_has_ycbcr_th_2();
  ::vas::ColorThreshold* temp = ycbcr_th_2_;
  ycbcr_th_2_ = NULL;
  return temp;
}
inline void FilterParameter::set_allocated_ycbcr_th_2(::vas::ColorThreshold* ycbcr_th_2) {
  delete ycbcr_th_2_;
  ycbcr_th_2_ = ycbcr_th_2;
  if (ycbcr_th_2) {
    set_has_ycbcr_th_2();
  } else {
    clear_has_ycbcr_th_2();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.FilterParameter.ycbcr_th_2)
}

// optional float color_fit_ratio = 8 [default = 0.5];
inline bool FilterParameter::has_color_fit_ratio() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FilterParameter::set_has_color_fit_ratio() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FilterParameter::clear_has_color_fit_ratio() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FilterParameter::clear_color_fit_ratio() {
  color_fit_ratio_ = 0.5f;
  clear_has_color_fit_ratio();
}
inline float FilterParameter::color_fit_ratio() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.color_fit_ratio)
  return color_fit_ratio_;
}
inline void FilterParameter::set_color_fit_ratio(float value) {
  set_has_color_fit_ratio();
  color_fit_ratio_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.color_fit_ratio)
}

// optional uint32 filter_width = 9 [default = 420];
inline bool FilterParameter::has_filter_width() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FilterParameter::set_has_filter_width() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FilterParameter::clear_has_filter_width() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FilterParameter::clear_filter_width() {
  filter_width_ = 420u;
  clear_has_filter_width();
}
inline ::google::protobuf::uint32 FilterParameter::filter_width() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.filter_width)
  return filter_width_;
}
inline void FilterParameter::set_filter_width(::google::protobuf::uint32 value) {
  set_has_filter_width();
  filter_width_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.filter_width)
}

// optional uint32 filter_height = 10 [default = 320];
inline bool FilterParameter::has_filter_height() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FilterParameter::set_has_filter_height() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FilterParameter::clear_has_filter_height() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FilterParameter::clear_filter_height() {
  filter_height_ = 320u;
  clear_has_filter_height();
}
inline ::google::protobuf::uint32 FilterParameter::filter_height() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.filter_height)
  return filter_height_;
}
inline void FilterParameter::set_filter_height(::google::protobuf::uint32 value) {
  set_has_filter_height();
  filter_height_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.filter_height)
}

// optional .vas.FilterMethod filter_method = 11 [default = PURE_CONTOUR_AREA];
inline bool FilterParameter::has_filter_method() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FilterParameter::set_has_filter_method() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FilterParameter::clear_has_filter_method() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FilterParameter::clear_filter_method() {
  filter_method_ = 4;
  clear_has_filter_method();
}
inline ::vas::FilterMethod FilterParameter::filter_method() const {
  // @@protoc_insertion_point(field_get:vas.FilterParameter.filter_method)
  return static_cast< ::vas::FilterMethod >(filter_method_);
}
inline void FilterParameter::set_filter_method(::vas::FilterMethod value) {
  assert(::vas::FilterMethod_IsValid(value));
  set_has_filter_method();
  filter_method_ = value;
  // @@protoc_insertion_point(field_set:vas.FilterParameter.filter_method)
}

// -------------------------------------------------------------------

// CaffeClassifierParameter

// optional float confience_score = 1 [default = 0.5];
inline bool CaffeClassifierParameter::has_confience_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeClassifierParameter::set_has_confience_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeClassifierParameter::clear_has_confience_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeClassifierParameter::clear_confience_score() {
  confience_score_ = 0.5f;
  clear_has_confience_score();
}
inline float CaffeClassifierParameter::confience_score() const {
  // @@protoc_insertion_point(field_get:vas.CaffeClassifierParameter.confience_score)
  return confience_score_;
}
inline void CaffeClassifierParameter::set_confience_score(float value) {
  set_has_confience_score();
  confience_score_ = value;
  // @@protoc_insertion_point(field_set:vas.CaffeClassifierParameter.confience_score)
}

// optional uint32 input_size = 2 [default = 224];
inline bool CaffeClassifierParameter::has_input_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeClassifierParameter::set_has_input_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeClassifierParameter::clear_has_input_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeClassifierParameter::clear_input_size() {
  input_size_ = 224u;
  clear_has_input_size();
}
inline ::google::protobuf::uint32 CaffeClassifierParameter::input_size() const {
  // @@protoc_insertion_point(field_get:vas.CaffeClassifierParameter.input_size)
  return input_size_;
}
inline void CaffeClassifierParameter::set_input_size(::google::protobuf::uint32 value) {
  set_has_input_size();
  input_size_ = value;
  // @@protoc_insertion_point(field_set:vas.CaffeClassifierParameter.input_size)
}

// optional string model_version = 3;
inline bool CaffeClassifierParameter::has_model_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaffeClassifierParameter::set_has_model_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaffeClassifierParameter::clear_has_model_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaffeClassifierParameter::clear_model_version() {
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_->clear();
  }
  clear_has_model_version();
}
inline const ::std::string& CaffeClassifierParameter::model_version() const {
  // @@protoc_insertion_point(field_get:vas.CaffeClassifierParameter.model_version)
  return *model_version_;
}
inline void CaffeClassifierParameter::set_model_version(const ::std::string& value) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(value);
  // @@protoc_insertion_point(field_set:vas.CaffeClassifierParameter.model_version)
}
inline void CaffeClassifierParameter::set_model_version(const char* value) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.CaffeClassifierParameter.model_version)
}
inline void CaffeClassifierParameter::set_model_version(const char* value, size_t size) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.CaffeClassifierParameter.model_version)
}
inline ::std::string* CaffeClassifierParameter::mutable_model_version() {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.CaffeClassifierParameter.model_version)
  return model_version_;
}
inline ::std::string* CaffeClassifierParameter::release_model_version() {
  clear_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_version_;
    model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CaffeClassifierParameter::set_allocated_model_version(::std::string* model_version) {
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_version_;
  }
  if (model_version) {
    set_has_model_version();
    model_version_ = model_version;
  } else {
    clear_has_model_version();
    model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.CaffeClassifierParameter.model_version)
}

// -------------------------------------------------------------------

// DetectParameter

// optional string service_id = 1;
inline bool DetectParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& DetectParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.service_id)
  return *service_id_;
}
inline void DetectParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.DetectParameter.service_id)
}
inline void DetectParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.DetectParameter.service_id)
}
inline void DetectParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.DetectParameter.service_id)
}
inline ::std::string* DetectParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.DetectParameter.service_id)
  return service_id_;
}
inline ::std::string* DetectParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.DetectParameter.service_id)
}

// repeated string reg_type = 2;
inline int DetectParameter::reg_type_size() const {
  return reg_type_.size();
}
inline void DetectParameter::clear_reg_type() {
  reg_type_.Clear();
}
inline const ::std::string& DetectParameter::reg_type(int index) const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.reg_type)
  return reg_type_.Get(index);
}
inline ::std::string* DetectParameter::mutable_reg_type(int index) {
  // @@protoc_insertion_point(field_mutable:vas.DetectParameter.reg_type)
  return reg_type_.Mutable(index);
}
inline void DetectParameter::set_reg_type(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vas.DetectParameter.reg_type)
  reg_type_.Mutable(index)->assign(value);
}
inline void DetectParameter::set_reg_type(int index, const char* value) {
  reg_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.DetectParameter.reg_type)
}
inline void DetectParameter::set_reg_type(int index, const char* value, size_t size) {
  reg_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.DetectParameter.reg_type)
}
inline ::std::string* DetectParameter::add_reg_type() {
  return reg_type_.Add();
}
inline void DetectParameter::add_reg_type(const ::std::string& value) {
  reg_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vas.DetectParameter.reg_type)
}
inline void DetectParameter::add_reg_type(const char* value) {
  reg_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vas.DetectParameter.reg_type)
}
inline void DetectParameter::add_reg_type(const char* value, size_t size) {
  reg_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vas.DetectParameter.reg_type)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DetectParameter::reg_type() const {
  // @@protoc_insertion_point(field_list:vas.DetectParameter.reg_type)
  return reg_type_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DetectParameter::mutable_reg_type() {
  // @@protoc_insertion_point(field_mutable_list:vas.DetectParameter.reg_type)
  return &reg_type_;
}

// optional float smoke_detect_sensitity = 11 [default = 0.2];
inline bool DetectParameter::has_smoke_detect_sensitity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectParameter::set_has_smoke_detect_sensitity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectParameter::clear_has_smoke_detect_sensitity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectParameter::clear_smoke_detect_sensitity() {
  smoke_detect_sensitity_ = 0.2f;
  clear_has_smoke_detect_sensitity();
}
inline float DetectParameter::smoke_detect_sensitity() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.smoke_detect_sensitity)
  return smoke_detect_sensitity_;
}
inline void DetectParameter::set_smoke_detect_sensitity(float value) {
  set_has_smoke_detect_sensitity();
  smoke_detect_sensitity_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.smoke_detect_sensitity)
}

// optional float fire_detect_sensitity = 24 [default = 0.2];
inline bool DetectParameter::has_fire_detect_sensitity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DetectParameter::set_has_fire_detect_sensitity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DetectParameter::clear_has_fire_detect_sensitity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DetectParameter::clear_fire_detect_sensitity() {
  fire_detect_sensitity_ = 0.2f;
  clear_has_fire_detect_sensitity();
}
inline float DetectParameter::fire_detect_sensitity() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.fire_detect_sensitity)
  return fire_detect_sensitity_;
}
inline void DetectParameter::set_fire_detect_sensitity(float value) {
  set_has_fire_detect_sensitity();
  fire_detect_sensitity_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.fire_detect_sensitity)
}

// optional uint32 num_history = 12 [default = 50];
inline bool DetectParameter::has_num_history() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetectParameter::set_has_num_history() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetectParameter::clear_has_num_history() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetectParameter::clear_num_history() {
  num_history_ = 50u;
  clear_has_num_history();
}
inline ::google::protobuf::uint32 DetectParameter::num_history() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.num_history)
  return num_history_;
}
inline void DetectParameter::set_num_history(::google::protobuf::uint32 value) {
  set_has_num_history();
  num_history_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.num_history)
}

// optional uint32 reg_width = 4 [default = 800];
inline bool DetectParameter::has_reg_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DetectParameter::set_has_reg_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DetectParameter::clear_has_reg_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DetectParameter::clear_reg_width() {
  reg_width_ = 800u;
  clear_has_reg_width();
}
inline ::google::protobuf::uint32 DetectParameter::reg_width() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.reg_width)
  return reg_width_;
}
inline void DetectParameter::set_reg_width(::google::protobuf::uint32 value) {
  set_has_reg_width();
  reg_width_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.reg_width)
}

// optional uint32 reg_height = 5 [default = 576];
inline bool DetectParameter::has_reg_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DetectParameter::set_has_reg_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DetectParameter::clear_has_reg_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DetectParameter::clear_reg_height() {
  reg_height_ = 576u;
  clear_has_reg_height();
}
inline ::google::protobuf::uint32 DetectParameter::reg_height() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.reg_height)
  return reg_height_;
}
inline void DetectParameter::set_reg_height(::google::protobuf::uint32 value) {
  set_has_reg_height();
  reg_height_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.reg_height)
}

// optional uint32 reg_interval = 6 [default = 20];
inline bool DetectParameter::has_reg_interval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DetectParameter::set_has_reg_interval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DetectParameter::clear_has_reg_interval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DetectParameter::clear_reg_interval() {
  reg_interval_ = 20u;
  clear_has_reg_interval();
}
inline ::google::protobuf::uint32 DetectParameter::reg_interval() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.reg_interval)
  return reg_interval_;
}
inline void DetectParameter::set_reg_interval(::google::protobuf::uint32 value) {
  set_has_reg_interval();
  reg_interval_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.reg_interval)
}

// optional .vas.BgParameter bg_parameter = 7;
inline bool DetectParameter::has_bg_parameter() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DetectParameter::set_has_bg_parameter() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DetectParameter::clear_has_bg_parameter() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DetectParameter::clear_bg_parameter() {
  if (bg_parameter_ != NULL) bg_parameter_->::vas::BgParameter::Clear();
  clear_has_bg_parameter();
}
inline const ::vas::BgParameter& DetectParameter::bg_parameter() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.bg_parameter)
  return bg_parameter_ != NULL ? *bg_parameter_ : *default_instance_->bg_parameter_;
}
inline ::vas::BgParameter* DetectParameter::mutable_bg_parameter() {
  set_has_bg_parameter();
  if (bg_parameter_ == NULL) bg_parameter_ = new ::vas::BgParameter;
  // @@protoc_insertion_point(field_mutable:vas.DetectParameter.bg_parameter)
  return bg_parameter_;
}
inline ::vas::BgParameter* DetectParameter::release_bg_parameter() {
  clear_has_bg_parameter();
  ::vas::BgParameter* temp = bg_parameter_;
  bg_parameter_ = NULL;
  return temp;
}
inline void DetectParameter::set_allocated_bg_parameter(::vas::BgParameter* bg_parameter) {
  delete bg_parameter_;
  bg_parameter_ = bg_parameter;
  if (bg_parameter) {
    set_has_bg_parameter();
  } else {
    clear_has_bg_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.DetectParameter.bg_parameter)
}

// optional .vas.FilterParameter filter_parameter = 8;
inline bool DetectParameter::has_filter_parameter() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DetectParameter::set_has_filter_parameter() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DetectParameter::clear_has_filter_parameter() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DetectParameter::clear_filter_parameter() {
  if (filter_parameter_ != NULL) filter_parameter_->::vas::FilterParameter::Clear();
  clear_has_filter_parameter();
}
inline const ::vas::FilterParameter& DetectParameter::filter_parameter() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.filter_parameter)
  return filter_parameter_ != NULL ? *filter_parameter_ : *default_instance_->filter_parameter_;
}
inline ::vas::FilterParameter* DetectParameter::mutable_filter_parameter() {
  set_has_filter_parameter();
  if (filter_parameter_ == NULL) filter_parameter_ = new ::vas::FilterParameter;
  // @@protoc_insertion_point(field_mutable:vas.DetectParameter.filter_parameter)
  return filter_parameter_;
}
inline ::vas::FilterParameter* DetectParameter::release_filter_parameter() {
  clear_has_filter_parameter();
  ::vas::FilterParameter* temp = filter_parameter_;
  filter_parameter_ = NULL;
  return temp;
}
inline void DetectParameter::set_allocated_filter_parameter(::vas::FilterParameter* filter_parameter) {
  delete filter_parameter_;
  filter_parameter_ = filter_parameter;
  if (filter_parameter) {
    set_has_filter_parameter();
  } else {
    clear_has_filter_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.DetectParameter.filter_parameter)
}

// optional .vas.CaffeClassifierParameter caffe_parameter = 9;
inline bool DetectParameter::has_caffe_parameter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DetectParameter::set_has_caffe_parameter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DetectParameter::clear_has_caffe_parameter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DetectParameter::clear_caffe_parameter() {
  if (caffe_parameter_ != NULL) caffe_parameter_->::vas::CaffeClassifierParameter::Clear();
  clear_has_caffe_parameter();
}
inline const ::vas::CaffeClassifierParameter& DetectParameter::caffe_parameter() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.caffe_parameter)
  return caffe_parameter_ != NULL ? *caffe_parameter_ : *default_instance_->caffe_parameter_;
}
inline ::vas::CaffeClassifierParameter* DetectParameter::mutable_caffe_parameter() {
  set_has_caffe_parameter();
  if (caffe_parameter_ == NULL) caffe_parameter_ = new ::vas::CaffeClassifierParameter;
  // @@protoc_insertion_point(field_mutable:vas.DetectParameter.caffe_parameter)
  return caffe_parameter_;
}
inline ::vas::CaffeClassifierParameter* DetectParameter::release_caffe_parameter() {
  clear_has_caffe_parameter();
  ::vas::CaffeClassifierParameter* temp = caffe_parameter_;
  caffe_parameter_ = NULL;
  return temp;
}
inline void DetectParameter::set_allocated_caffe_parameter(::vas::CaffeClassifierParameter* caffe_parameter) {
  delete caffe_parameter_;
  caffe_parameter_ = caffe_parameter;
  if (caffe_parameter) {
    set_has_caffe_parameter();
  } else {
    clear_has_caffe_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.DetectParameter.caffe_parameter)
}

// optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
inline bool DetectParameter::has_detect_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DetectParameter::set_has_detect_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DetectParameter::clear_has_detect_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DetectParameter::clear_detect_status() {
  detect_status_ = 1;
  clear_has_detect_status();
}
inline ::vas::DetectStatus DetectParameter::detect_status() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.detect_status)
  return static_cast< ::vas::DetectStatus >(detect_status_);
}
inline void DetectParameter::set_detect_status(::vas::DetectStatus value) {
  assert(::vas::DetectStatus_IsValid(value));
  set_has_detect_status();
  detect_status_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.detect_status)
}

// optional bool merge_fore_rects = 20 [default = false];
inline bool DetectParameter::has_merge_fore_rects() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DetectParameter::set_has_merge_fore_rects() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DetectParameter::clear_has_merge_fore_rects() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DetectParameter::clear_merge_fore_rects() {
  merge_fore_rects_ = false;
  clear_has_merge_fore_rects();
}
inline bool DetectParameter::merge_fore_rects() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.merge_fore_rects)
  return merge_fore_rects_;
}
inline void DetectParameter::set_merge_fore_rects(bool value) {
  set_has_merge_fore_rects();
  merge_fore_rects_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.merge_fore_rects)
}

// optional bool show_result_frame = 13 [default = false];
inline bool DetectParameter::has_show_result_frame() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DetectParameter::set_has_show_result_frame() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DetectParameter::clear_has_show_result_frame() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DetectParameter::clear_show_result_frame() {
  show_result_frame_ = false;
  clear_has_show_result_frame();
}
inline bool DetectParameter::show_result_frame() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.show_result_frame)
  return show_result_frame_;
}
inline void DetectParameter::set_show_result_frame(bool value) {
  set_has_show_result_frame();
  show_result_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.show_result_frame)
}

// optional bool show_bg = 15 [default = false];
inline bool DetectParameter::has_show_bg() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DetectParameter::set_has_show_bg() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DetectParameter::clear_has_show_bg() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DetectParameter::clear_show_bg() {
  show_bg_ = false;
  clear_has_show_bg();
}
inline bool DetectParameter::show_bg() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.show_bg)
  return show_bg_;
}
inline void DetectParameter::set_show_bg(bool value) {
  set_has_show_bg();
  show_bg_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.show_bg)
}

// optional bool show_reg_frame = 16 [default = false];
inline bool DetectParameter::has_show_reg_frame() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DetectParameter::set_has_show_reg_frame() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DetectParameter::clear_has_show_reg_frame() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DetectParameter::clear_show_reg_frame() {
  show_reg_frame_ = false;
  clear_has_show_reg_frame();
}
inline bool DetectParameter::show_reg_frame() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.show_reg_frame)
  return show_reg_frame_;
}
inline void DetectParameter::set_show_reg_frame(bool value) {
  set_has_show_reg_frame();
  show_reg_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.show_reg_frame)
}

// optional bool print_reg_count = 14 [default = false];
inline bool DetectParameter::has_print_reg_count() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DetectParameter::set_has_print_reg_count() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DetectParameter::clear_has_print_reg_count() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DetectParameter::clear_print_reg_count() {
  print_reg_count_ = false;
  clear_has_print_reg_count();
}
inline bool DetectParameter::print_reg_count() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.print_reg_count)
  return print_reg_count_;
}
inline void DetectParameter::set_print_reg_count(bool value) {
  set_has_print_reg_count();
  print_reg_count_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.print_reg_count)
}

// optional bool show_smoke_hot_frame = 17 [default = false];
inline bool DetectParameter::has_show_smoke_hot_frame() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DetectParameter::set_has_show_smoke_hot_frame() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DetectParameter::clear_has_show_smoke_hot_frame() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DetectParameter::clear_show_smoke_hot_frame() {
  show_smoke_hot_frame_ = false;
  clear_has_show_smoke_hot_frame();
}
inline bool DetectParameter::show_smoke_hot_frame() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.show_smoke_hot_frame)
  return show_smoke_hot_frame_;
}
inline void DetectParameter::set_show_smoke_hot_frame(bool value) {
  set_has_show_smoke_hot_frame();
  show_smoke_hot_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.show_smoke_hot_frame)
}

// optional bool show_fire_hot_frame = 23 [default = false];
inline bool DetectParameter::has_show_fire_hot_frame() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DetectParameter::set_has_show_fire_hot_frame() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DetectParameter::clear_has_show_fire_hot_frame() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DetectParameter::clear_show_fire_hot_frame() {
  show_fire_hot_frame_ = false;
  clear_has_show_fire_hot_frame();
}
inline bool DetectParameter::show_fire_hot_frame() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.show_fire_hot_frame)
  return show_fire_hot_frame_;
}
inline void DetectParameter::set_show_fire_hot_frame(bool value) {
  set_has_show_fire_hot_frame();
  show_fire_hot_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.show_fire_hot_frame)
}

// optional bool save_reg_frame = 18 [default = false];
inline bool DetectParameter::has_save_reg_frame() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DetectParameter::set_has_save_reg_frame() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DetectParameter::clear_has_save_reg_frame() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DetectParameter::clear_save_reg_frame() {
  save_reg_frame_ = false;
  clear_has_save_reg_frame();
}
inline bool DetectParameter::save_reg_frame() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.save_reg_frame)
  return save_reg_frame_;
}
inline void DetectParameter::set_save_reg_frame(bool value) {
  set_has_save_reg_frame();
  save_reg_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.save_reg_frame)
}

// optional bool save_video = 19 [default = false];
inline bool DetectParameter::has_save_video() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DetectParameter::set_has_save_video() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DetectParameter::clear_has_save_video() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DetectParameter::clear_save_video() {
  save_video_ = false;
  clear_has_save_video();
}
inline bool DetectParameter::save_video() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.save_video)
  return save_video_;
}
inline void DetectParameter::set_save_video(bool value) {
  set_has_save_video();
  save_video_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.save_video)
}

// optional bool move_area_for_reg_only = 21 [default = false];
inline bool DetectParameter::has_move_area_for_reg_only() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DetectParameter::set_has_move_area_for_reg_only() {
  _has_bits_[0] |= 0x00200000u;
}
inline void DetectParameter::clear_has_move_area_for_reg_only() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void DetectParameter::clear_move_area_for_reg_only() {
  move_area_for_reg_only_ = false;
  clear_has_move_area_for_reg_only();
}
inline bool DetectParameter::move_area_for_reg_only() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.move_area_for_reg_only)
  return move_area_for_reg_only_;
}
inline void DetectParameter::set_move_area_for_reg_only(bool value) {
  set_has_move_area_for_reg_only();
  move_area_for_reg_only_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.move_area_for_reg_only)
}

// optional bool show_move_area_for_reg_only = 22 [default = false];
inline bool DetectParameter::has_show_move_area_for_reg_only() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DetectParameter::set_has_show_move_area_for_reg_only() {
  _has_bits_[0] |= 0x00400000u;
}
inline void DetectParameter::clear_has_show_move_area_for_reg_only() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void DetectParameter::clear_show_move_area_for_reg_only() {
  show_move_area_for_reg_only_ = false;
  clear_has_show_move_area_for_reg_only();
}
inline bool DetectParameter::show_move_area_for_reg_only() const {
  // @@protoc_insertion_point(field_get:vas.DetectParameter.show_move_area_for_reg_only)
  return show_move_area_for_reg_only_;
}
inline void DetectParameter::set_show_move_area_for_reg_only(bool value) {
  set_has_show_move_area_for_reg_only();
  show_move_area_for_reg_only_ = value;
  // @@protoc_insertion_point(field_set:vas.DetectParameter.show_move_area_for_reg_only)
}

// -------------------------------------------------------------------

// SsdDetecterParameter

// optional string service_id = 1;
inline bool SsdDetecterParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SsdDetecterParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SsdDetecterParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SsdDetecterParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& SsdDetecterParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.service_id)
  return *service_id_;
}
inline void SsdDetecterParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.service_id)
}
inline void SsdDetecterParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdDetecterParameter.service_id)
}
inline void SsdDetecterParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdDetecterParameter.service_id)
}
inline ::std::string* SsdDetecterParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdDetecterParameter.service_id)
  return service_id_;
}
inline ::std::string* SsdDetecterParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdDetecterParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdDetecterParameter.service_id)
}

// repeated string reg_type = 2;
inline int SsdDetecterParameter::reg_type_size() const {
  return reg_type_.size();
}
inline void SsdDetecterParameter::clear_reg_type() {
  reg_type_.Clear();
}
inline const ::std::string& SsdDetecterParameter::reg_type(int index) const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.reg_type)
  return reg_type_.Get(index);
}
inline ::std::string* SsdDetecterParameter::mutable_reg_type(int index) {
  // @@protoc_insertion_point(field_mutable:vas.SsdDetecterParameter.reg_type)
  return reg_type_.Mutable(index);
}
inline void SsdDetecterParameter::set_reg_type(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.reg_type)
  reg_type_.Mutable(index)->assign(value);
}
inline void SsdDetecterParameter::set_reg_type(int index, const char* value) {
  reg_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdDetecterParameter.reg_type)
}
inline void SsdDetecterParameter::set_reg_type(int index, const char* value, size_t size) {
  reg_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdDetecterParameter.reg_type)
}
inline ::std::string* SsdDetecterParameter::add_reg_type() {
  return reg_type_.Add();
}
inline void SsdDetecterParameter::add_reg_type(const ::std::string& value) {
  reg_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vas.SsdDetecterParameter.reg_type)
}
inline void SsdDetecterParameter::add_reg_type(const char* value) {
  reg_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vas.SsdDetecterParameter.reg_type)
}
inline void SsdDetecterParameter::add_reg_type(const char* value, size_t size) {
  reg_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vas.SsdDetecterParameter.reg_type)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SsdDetecterParameter::reg_type() const {
  // @@protoc_insertion_point(field_list:vas.SsdDetecterParameter.reg_type)
  return reg_type_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SsdDetecterParameter::mutable_reg_type() {
  // @@protoc_insertion_point(field_mutable_list:vas.SsdDetecterParameter.reg_type)
  return &reg_type_;
}

// optional uint32 reg_width = 4 [default = 800];
inline bool SsdDetecterParameter::has_reg_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SsdDetecterParameter::set_has_reg_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SsdDetecterParameter::clear_has_reg_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SsdDetecterParameter::clear_reg_width() {
  reg_width_ = 800u;
  clear_has_reg_width();
}
inline ::google::protobuf::uint32 SsdDetecterParameter::reg_width() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.reg_width)
  return reg_width_;
}
inline void SsdDetecterParameter::set_reg_width(::google::protobuf::uint32 value) {
  set_has_reg_width();
  reg_width_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.reg_width)
}

// optional uint32 reg_height = 5 [default = 576];
inline bool SsdDetecterParameter::has_reg_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SsdDetecterParameter::set_has_reg_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SsdDetecterParameter::clear_has_reg_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SsdDetecterParameter::clear_reg_height() {
  reg_height_ = 576u;
  clear_has_reg_height();
}
inline ::google::protobuf::uint32 SsdDetecterParameter::reg_height() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.reg_height)
  return reg_height_;
}
inline void SsdDetecterParameter::set_reg_height(::google::protobuf::uint32 value) {
  set_has_reg_height();
  reg_height_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.reg_height)
}

// optional .vas.DetectStatus detect_status = 10 [default = DETECT_ON];
inline bool SsdDetecterParameter::has_detect_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SsdDetecterParameter::set_has_detect_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SsdDetecterParameter::clear_has_detect_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SsdDetecterParameter::clear_detect_status() {
  detect_status_ = 1;
  clear_has_detect_status();
}
inline ::vas::DetectStatus SsdDetecterParameter::detect_status() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.detect_status)
  return static_cast< ::vas::DetectStatus >(detect_status_);
}
inline void SsdDetecterParameter::set_detect_status(::vas::DetectStatus value) {
  assert(::vas::DetectStatus_IsValid(value));
  set_has_detect_status();
  detect_status_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.detect_status)
}

// optional bool show_result_frame = 13 [default = false];
inline bool SsdDetecterParameter::has_show_result_frame() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SsdDetecterParameter::set_has_show_result_frame() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SsdDetecterParameter::clear_has_show_result_frame() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SsdDetecterParameter::clear_show_result_frame() {
  show_result_frame_ = false;
  clear_has_show_result_frame();
}
inline bool SsdDetecterParameter::show_result_frame() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.show_result_frame)
  return show_result_frame_;
}
inline void SsdDetecterParameter::set_show_result_frame(bool value) {
  set_has_show_result_frame();
  show_result_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.show_result_frame)
}

// optional bool show_reg_frame = 16 [default = false];
inline bool SsdDetecterParameter::has_show_reg_frame() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SsdDetecterParameter::set_has_show_reg_frame() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SsdDetecterParameter::clear_has_show_reg_frame() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SsdDetecterParameter::clear_show_reg_frame() {
  show_reg_frame_ = false;
  clear_has_show_reg_frame();
}
inline bool SsdDetecterParameter::show_reg_frame() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.show_reg_frame)
  return show_reg_frame_;
}
inline void SsdDetecterParameter::set_show_reg_frame(bool value) {
  set_has_show_reg_frame();
  show_reg_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.show_reg_frame)
}

// optional bool save_video = 19 [default = false];
inline bool SsdDetecterParameter::has_save_video() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SsdDetecterParameter::set_has_save_video() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SsdDetecterParameter::clear_has_save_video() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SsdDetecterParameter::clear_save_video() {
  save_video_ = false;
  clear_has_save_video();
}
inline bool SsdDetecterParameter::save_video() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.save_video)
  return save_video_;
}
inline void SsdDetecterParameter::set_save_video(bool value) {
  set_has_save_video();
  save_video_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.save_video)
}

// optional bool save_reg_frame = 18 [default = false];
inline bool SsdDetecterParameter::has_save_reg_frame() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SsdDetecterParameter::set_has_save_reg_frame() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SsdDetecterParameter::clear_has_save_reg_frame() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SsdDetecterParameter::clear_save_reg_frame() {
  save_reg_frame_ = false;
  clear_has_save_reg_frame();
}
inline bool SsdDetecterParameter::save_reg_frame() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.save_reg_frame)
  return save_reg_frame_;
}
inline void SsdDetecterParameter::set_save_reg_frame(bool value) {
  set_has_save_reg_frame();
  save_reg_frame_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.save_reg_frame)
}

// optional uint32 reg_interval = 6 [default = 20];
inline bool SsdDetecterParameter::has_reg_interval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SsdDetecterParameter::set_has_reg_interval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SsdDetecterParameter::clear_has_reg_interval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SsdDetecterParameter::clear_reg_interval() {
  reg_interval_ = 20u;
  clear_has_reg_interval();
}
inline ::google::protobuf::uint32 SsdDetecterParameter::reg_interval() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.reg_interval)
  return reg_interval_;
}
inline void SsdDetecterParameter::set_reg_interval(::google::protobuf::uint32 value) {
  set_has_reg_interval();
  reg_interval_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.reg_interval)
}

// optional float confidence_threshold = 21 [default = 0.5];
inline bool SsdDetecterParameter::has_confidence_threshold() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SsdDetecterParameter::set_has_confidence_threshold() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SsdDetecterParameter::clear_has_confidence_threshold() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SsdDetecterParameter::clear_confidence_threshold() {
  confidence_threshold_ = 0.5f;
  clear_has_confidence_threshold();
}
inline float SsdDetecterParameter::confidence_threshold() const {
  // @@protoc_insertion_point(field_get:vas.SsdDetecterParameter.confidence_threshold)
  return confidence_threshold_;
}
inline void SsdDetecterParameter::set_confidence_threshold(float value) {
  set_has_confidence_threshold();
  confidence_threshold_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdDetecterParameter.confidence_threshold)
}

// -------------------------------------------------------------------

// CaffeModelPath

// optional string deploy_file_path = 1;
inline bool CaffeModelPath::has_deploy_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CaffeModelPath::set_has_deploy_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CaffeModelPath::clear_has_deploy_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CaffeModelPath::clear_deploy_file_path() {
  if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_->clear();
  }
  clear_has_deploy_file_path();
}
inline const ::std::string& CaffeModelPath::deploy_file_path() const {
  // @@protoc_insertion_point(field_get:vas.CaffeModelPath.deploy_file_path)
  return *deploy_file_path_;
}
inline void CaffeModelPath::set_deploy_file_path(const ::std::string& value) {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  deploy_file_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.CaffeModelPath.deploy_file_path)
}
inline void CaffeModelPath::set_deploy_file_path(const char* value) {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  deploy_file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.CaffeModelPath.deploy_file_path)
}
inline void CaffeModelPath::set_deploy_file_path(const char* value, size_t size) {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  deploy_file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.CaffeModelPath.deploy_file_path)
}
inline ::std::string* CaffeModelPath::mutable_deploy_file_path() {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.CaffeModelPath.deploy_file_path)
  return deploy_file_path_;
}
inline ::std::string* CaffeModelPath::release_deploy_file_path() {
  clear_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deploy_file_path_;
    deploy_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CaffeModelPath::set_allocated_deploy_file_path(::std::string* deploy_file_path) {
  if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deploy_file_path_;
  }
  if (deploy_file_path) {
    set_has_deploy_file_path();
    deploy_file_path_ = deploy_file_path;
  } else {
    clear_has_deploy_file_path();
    deploy_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.CaffeModelPath.deploy_file_path)
}

// optional string trained_model_path = 2;
inline bool CaffeModelPath::has_trained_model_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CaffeModelPath::set_has_trained_model_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CaffeModelPath::clear_has_trained_model_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CaffeModelPath::clear_trained_model_path() {
  if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_->clear();
  }
  clear_has_trained_model_path();
}
inline const ::std::string& CaffeModelPath::trained_model_path() const {
  // @@protoc_insertion_point(field_get:vas.CaffeModelPath.trained_model_path)
  return *trained_model_path_;
}
inline void CaffeModelPath::set_trained_model_path(const ::std::string& value) {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  trained_model_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.CaffeModelPath.trained_model_path)
}
inline void CaffeModelPath::set_trained_model_path(const char* value) {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  trained_model_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.CaffeModelPath.trained_model_path)
}
inline void CaffeModelPath::set_trained_model_path(const char* value, size_t size) {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  trained_model_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.CaffeModelPath.trained_model_path)
}
inline ::std::string* CaffeModelPath::mutable_trained_model_path() {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.CaffeModelPath.trained_model_path)
  return trained_model_path_;
}
inline ::std::string* CaffeModelPath::release_trained_model_path() {
  clear_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = trained_model_path_;
    trained_model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CaffeModelPath::set_allocated_trained_model_path(::std::string* trained_model_path) {
  if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trained_model_path_;
  }
  if (trained_model_path) {
    set_has_trained_model_path();
    trained_model_path_ = trained_model_path;
  } else {
    clear_has_trained_model_path();
    trained_model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.CaffeModelPath.trained_model_path)
}

// optional string label_file_path = 3;
inline bool CaffeModelPath::has_label_file_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CaffeModelPath::set_has_label_file_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CaffeModelPath::clear_has_label_file_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CaffeModelPath::clear_label_file_path() {
  if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_->clear();
  }
  clear_has_label_file_path();
}
inline const ::std::string& CaffeModelPath::label_file_path() const {
  // @@protoc_insertion_point(field_get:vas.CaffeModelPath.label_file_path)
  return *label_file_path_;
}
inline void CaffeModelPath::set_label_file_path(const ::std::string& value) {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  label_file_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.CaffeModelPath.label_file_path)
}
inline void CaffeModelPath::set_label_file_path(const char* value) {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  label_file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.CaffeModelPath.label_file_path)
}
inline void CaffeModelPath::set_label_file_path(const char* value, size_t size) {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  label_file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.CaffeModelPath.label_file_path)
}
inline ::std::string* CaffeModelPath::mutable_label_file_path() {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.CaffeModelPath.label_file_path)
  return label_file_path_;
}
inline ::std::string* CaffeModelPath::release_label_file_path() {
  clear_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_file_path_;
    label_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CaffeModelPath::set_allocated_label_file_path(::std::string* label_file_path) {
  if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_file_path_;
  }
  if (label_file_path) {
    set_has_label_file_path();
    label_file_path_ = label_file_path;
  } else {
    clear_has_label_file_path();
    label_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.CaffeModelPath.label_file_path)
}

// optional string mean_file_path = 4;
inline bool CaffeModelPath::has_mean_file_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CaffeModelPath::set_has_mean_file_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CaffeModelPath::clear_has_mean_file_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CaffeModelPath::clear_mean_file_path() {
  if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_->clear();
  }
  clear_has_mean_file_path();
}
inline const ::std::string& CaffeModelPath::mean_file_path() const {
  // @@protoc_insertion_point(field_get:vas.CaffeModelPath.mean_file_path)
  return *mean_file_path_;
}
inline void CaffeModelPath::set_mean_file_path(const ::std::string& value) {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  mean_file_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.CaffeModelPath.mean_file_path)
}
inline void CaffeModelPath::set_mean_file_path(const char* value) {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  mean_file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.CaffeModelPath.mean_file_path)
}
inline void CaffeModelPath::set_mean_file_path(const char* value, size_t size) {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  mean_file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.CaffeModelPath.mean_file_path)
}
inline ::std::string* CaffeModelPath::mutable_mean_file_path() {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.CaffeModelPath.mean_file_path)
  return mean_file_path_;
}
inline ::std::string* CaffeModelPath::release_mean_file_path() {
  clear_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mean_file_path_;
    mean_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CaffeModelPath::set_allocated_mean_file_path(::std::string* mean_file_path) {
  if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mean_file_path_;
  }
  if (mean_file_path) {
    set_has_mean_file_path();
    mean_file_path_ = mean_file_path;
  } else {
    clear_has_mean_file_path();
    mean_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.CaffeModelPath.mean_file_path)
}

// optional uint32 input_size = 5 [default = 224];
inline bool CaffeModelPath::has_input_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CaffeModelPath::set_has_input_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CaffeModelPath::clear_has_input_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CaffeModelPath::clear_input_size() {
  input_size_ = 224u;
  clear_has_input_size();
}
inline ::google::protobuf::uint32 CaffeModelPath::input_size() const {
  // @@protoc_insertion_point(field_get:vas.CaffeModelPath.input_size)
  return input_size_;
}
inline void CaffeModelPath::set_input_size(::google::protobuf::uint32 value) {
  set_has_input_size();
  input_size_ = value;
  // @@protoc_insertion_point(field_set:vas.CaffeModelPath.input_size)
}

// optional string model_version = 6;
inline bool CaffeModelPath::has_model_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CaffeModelPath::set_has_model_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CaffeModelPath::clear_has_model_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CaffeModelPath::clear_model_version() {
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_->clear();
  }
  clear_has_model_version();
}
inline const ::std::string& CaffeModelPath::model_version() const {
  // @@protoc_insertion_point(field_get:vas.CaffeModelPath.model_version)
  return *model_version_;
}
inline void CaffeModelPath::set_model_version(const ::std::string& value) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(value);
  // @@protoc_insertion_point(field_set:vas.CaffeModelPath.model_version)
}
inline void CaffeModelPath::set_model_version(const char* value) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.CaffeModelPath.model_version)
}
inline void CaffeModelPath::set_model_version(const char* value, size_t size) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.CaffeModelPath.model_version)
}
inline ::std::string* CaffeModelPath::mutable_model_version() {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.CaffeModelPath.model_version)
  return model_version_;
}
inline ::std::string* CaffeModelPath::release_model_version() {
  clear_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_version_;
    model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CaffeModelPath::set_allocated_model_version(::std::string* model_version) {
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_version_;
  }
  if (model_version) {
    set_has_model_version();
    model_version_ = model_version;
  } else {
    clear_has_model_version();
    model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.CaffeModelPath.model_version)
}

// optional bool use_gpu = 7 [default = true];
inline bool CaffeModelPath::has_use_gpu() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CaffeModelPath::set_has_use_gpu() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CaffeModelPath::clear_has_use_gpu() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CaffeModelPath::clear_use_gpu() {
  use_gpu_ = true;
  clear_has_use_gpu();
}
inline bool CaffeModelPath::use_gpu() const {
  // @@protoc_insertion_point(field_get:vas.CaffeModelPath.use_gpu)
  return use_gpu_;
}
inline void CaffeModelPath::set_use_gpu(bool value) {
  set_has_use_gpu();
  use_gpu_ = value;
  // @@protoc_insertion_point(field_set:vas.CaffeModelPath.use_gpu)
}

// -------------------------------------------------------------------

// SsdModelPath

// optional string deploy_file_path = 1;
inline bool SsdModelPath::has_deploy_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SsdModelPath::set_has_deploy_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SsdModelPath::clear_has_deploy_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SsdModelPath::clear_deploy_file_path() {
  if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_->clear();
  }
  clear_has_deploy_file_path();
}
inline const ::std::string& SsdModelPath::deploy_file_path() const {
  // @@protoc_insertion_point(field_get:vas.SsdModelPath.deploy_file_path)
  return *deploy_file_path_;
}
inline void SsdModelPath::set_deploy_file_path(const ::std::string& value) {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  deploy_file_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdModelPath.deploy_file_path)
}
inline void SsdModelPath::set_deploy_file_path(const char* value) {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  deploy_file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdModelPath.deploy_file_path)
}
inline void SsdModelPath::set_deploy_file_path(const char* value, size_t size) {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  deploy_file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdModelPath.deploy_file_path)
}
inline ::std::string* SsdModelPath::mutable_deploy_file_path() {
  set_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deploy_file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdModelPath.deploy_file_path)
  return deploy_file_path_;
}
inline ::std::string* SsdModelPath::release_deploy_file_path() {
  clear_has_deploy_file_path();
  if (deploy_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deploy_file_path_;
    deploy_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdModelPath::set_allocated_deploy_file_path(::std::string* deploy_file_path) {
  if (deploy_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deploy_file_path_;
  }
  if (deploy_file_path) {
    set_has_deploy_file_path();
    deploy_file_path_ = deploy_file_path;
  } else {
    clear_has_deploy_file_path();
    deploy_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdModelPath.deploy_file_path)
}

// optional string trained_model_path = 2;
inline bool SsdModelPath::has_trained_model_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SsdModelPath::set_has_trained_model_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SsdModelPath::clear_has_trained_model_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SsdModelPath::clear_trained_model_path() {
  if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_->clear();
  }
  clear_has_trained_model_path();
}
inline const ::std::string& SsdModelPath::trained_model_path() const {
  // @@protoc_insertion_point(field_get:vas.SsdModelPath.trained_model_path)
  return *trained_model_path_;
}
inline void SsdModelPath::set_trained_model_path(const ::std::string& value) {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  trained_model_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdModelPath.trained_model_path)
}
inline void SsdModelPath::set_trained_model_path(const char* value) {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  trained_model_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdModelPath.trained_model_path)
}
inline void SsdModelPath::set_trained_model_path(const char* value, size_t size) {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  trained_model_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdModelPath.trained_model_path)
}
inline ::std::string* SsdModelPath::mutable_trained_model_path() {
  set_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trained_model_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdModelPath.trained_model_path)
  return trained_model_path_;
}
inline ::std::string* SsdModelPath::release_trained_model_path() {
  clear_has_trained_model_path();
  if (trained_model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = trained_model_path_;
    trained_model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdModelPath::set_allocated_trained_model_path(::std::string* trained_model_path) {
  if (trained_model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trained_model_path_;
  }
  if (trained_model_path) {
    set_has_trained_model_path();
    trained_model_path_ = trained_model_path;
  } else {
    clear_has_trained_model_path();
    trained_model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdModelPath.trained_model_path)
}

// optional string label_file_path = 3;
inline bool SsdModelPath::has_label_file_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SsdModelPath::set_has_label_file_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SsdModelPath::clear_has_label_file_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SsdModelPath::clear_label_file_path() {
  if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_->clear();
  }
  clear_has_label_file_path();
}
inline const ::std::string& SsdModelPath::label_file_path() const {
  // @@protoc_insertion_point(field_get:vas.SsdModelPath.label_file_path)
  return *label_file_path_;
}
inline void SsdModelPath::set_label_file_path(const ::std::string& value) {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  label_file_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdModelPath.label_file_path)
}
inline void SsdModelPath::set_label_file_path(const char* value) {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  label_file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdModelPath.label_file_path)
}
inline void SsdModelPath::set_label_file_path(const char* value, size_t size) {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  label_file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdModelPath.label_file_path)
}
inline ::std::string* SsdModelPath::mutable_label_file_path() {
  set_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdModelPath.label_file_path)
  return label_file_path_;
}
inline ::std::string* SsdModelPath::release_label_file_path() {
  clear_has_label_file_path();
  if (label_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_file_path_;
    label_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdModelPath::set_allocated_label_file_path(::std::string* label_file_path) {
  if (label_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_file_path_;
  }
  if (label_file_path) {
    set_has_label_file_path();
    label_file_path_ = label_file_path;
  } else {
    clear_has_label_file_path();
    label_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdModelPath.label_file_path)
}

// optional string mean_file_path = 4;
inline bool SsdModelPath::has_mean_file_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SsdModelPath::set_has_mean_file_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SsdModelPath::clear_has_mean_file_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SsdModelPath::clear_mean_file_path() {
  if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_->clear();
  }
  clear_has_mean_file_path();
}
inline const ::std::string& SsdModelPath::mean_file_path() const {
  // @@protoc_insertion_point(field_get:vas.SsdModelPath.mean_file_path)
  return *mean_file_path_;
}
inline void SsdModelPath::set_mean_file_path(const ::std::string& value) {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  mean_file_path_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdModelPath.mean_file_path)
}
inline void SsdModelPath::set_mean_file_path(const char* value) {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  mean_file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdModelPath.mean_file_path)
}
inline void SsdModelPath::set_mean_file_path(const char* value, size_t size) {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  mean_file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdModelPath.mean_file_path)
}
inline ::std::string* SsdModelPath::mutable_mean_file_path() {
  set_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdModelPath.mean_file_path)
  return mean_file_path_;
}
inline ::std::string* SsdModelPath::release_mean_file_path() {
  clear_has_mean_file_path();
  if (mean_file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mean_file_path_;
    mean_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdModelPath::set_allocated_mean_file_path(::std::string* mean_file_path) {
  if (mean_file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mean_file_path_;
  }
  if (mean_file_path) {
    set_has_mean_file_path();
    mean_file_path_ = mean_file_path;
  } else {
    clear_has_mean_file_path();
    mean_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdModelPath.mean_file_path)
}

// optional string mean_value = 5;
inline bool SsdModelPath::has_mean_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SsdModelPath::set_has_mean_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SsdModelPath::clear_has_mean_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SsdModelPath::clear_mean_value() {
  if (mean_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_value_->clear();
  }
  clear_has_mean_value();
}
inline const ::std::string& SsdModelPath::mean_value() const {
  // @@protoc_insertion_point(field_get:vas.SsdModelPath.mean_value)
  return *mean_value_;
}
inline void SsdModelPath::set_mean_value(const ::std::string& value) {
  set_has_mean_value();
  if (mean_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_value_ = new ::std::string;
  }
  mean_value_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdModelPath.mean_value)
}
inline void SsdModelPath::set_mean_value(const char* value) {
  set_has_mean_value();
  if (mean_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_value_ = new ::std::string;
  }
  mean_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdModelPath.mean_value)
}
inline void SsdModelPath::set_mean_value(const char* value, size_t size) {
  set_has_mean_value();
  if (mean_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_value_ = new ::std::string;
  }
  mean_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdModelPath.mean_value)
}
inline ::std::string* SsdModelPath::mutable_mean_value() {
  set_has_mean_value();
  if (mean_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mean_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdModelPath.mean_value)
  return mean_value_;
}
inline ::std::string* SsdModelPath::release_mean_value() {
  clear_has_mean_value();
  if (mean_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mean_value_;
    mean_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdModelPath::set_allocated_mean_value(::std::string* mean_value) {
  if (mean_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mean_value_;
  }
  if (mean_value) {
    set_has_mean_value();
    mean_value_ = mean_value;
  } else {
    clear_has_mean_value();
    mean_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdModelPath.mean_value)
}

// optional string model_version = 6;
inline bool SsdModelPath::has_model_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SsdModelPath::set_has_model_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SsdModelPath::clear_has_model_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SsdModelPath::clear_model_version() {
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_->clear();
  }
  clear_has_model_version();
}
inline const ::std::string& SsdModelPath::model_version() const {
  // @@protoc_insertion_point(field_get:vas.SsdModelPath.model_version)
  return *model_version_;
}
inline void SsdModelPath::set_model_version(const ::std::string& value) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdModelPath.model_version)
}
inline void SsdModelPath::set_model_version(const char* value) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdModelPath.model_version)
}
inline void SsdModelPath::set_model_version(const char* value, size_t size) {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  model_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdModelPath.model_version)
}
inline ::std::string* SsdModelPath::mutable_model_version() {
  set_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdModelPath.model_version)
  return model_version_;
}
inline ::std::string* SsdModelPath::release_model_version() {
  clear_has_model_version();
  if (model_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_version_;
    model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdModelPath::set_allocated_model_version(::std::string* model_version) {
  if (model_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_version_;
  }
  if (model_version) {
    set_has_model_version();
    model_version_ = model_version;
  } else {
    clear_has_model_version();
    model_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdModelPath.model_version)
}

// optional bool use_gpu = 7 [default = true];
inline bool SsdModelPath::has_use_gpu() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SsdModelPath::set_has_use_gpu() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SsdModelPath::clear_has_use_gpu() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SsdModelPath::clear_use_gpu() {
  use_gpu_ = true;
  clear_has_use_gpu();
}
inline bool SsdModelPath::use_gpu() const {
  // @@protoc_insertion_point(field_get:vas.SsdModelPath.use_gpu)
  return use_gpu_;
}
inline void SsdModelPath::set_use_gpu(bool value) {
  set_has_use_gpu();
  use_gpu_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdModelPath.use_gpu)
}

// -------------------------------------------------------------------

// ServiceParameter

// optional string service_id = 1;
inline bool ServiceParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& ServiceParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.ServiceParameter.service_id)
  return *service_id_;
}
inline void ServiceParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.ServiceParameter.service_id)
}
inline void ServiceParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.ServiceParameter.service_id)
}
inline void ServiceParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.ServiceParameter.service_id)
}
inline ::std::string* ServiceParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.ServiceParameter.service_id)
  return service_id_;
}
inline ::std::string* ServiceParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServiceParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.ServiceParameter.service_id)
}

// optional .vas.DecodeParameter decode_parameter = 2;
inline bool ServiceParameter::has_decode_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceParameter::set_has_decode_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceParameter::clear_has_decode_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceParameter::clear_decode_parameter() {
  if (decode_parameter_ != NULL) decode_parameter_->::vas::DecodeParameter::Clear();
  clear_has_decode_parameter();
}
inline const ::vas::DecodeParameter& ServiceParameter::decode_parameter() const {
  // @@protoc_insertion_point(field_get:vas.ServiceParameter.decode_parameter)
  return decode_parameter_ != NULL ? *decode_parameter_ : *default_instance_->decode_parameter_;
}
inline ::vas::DecodeParameter* ServiceParameter::mutable_decode_parameter() {
  set_has_decode_parameter();
  if (decode_parameter_ == NULL) decode_parameter_ = new ::vas::DecodeParameter;
  // @@protoc_insertion_point(field_mutable:vas.ServiceParameter.decode_parameter)
  return decode_parameter_;
}
inline ::vas::DecodeParameter* ServiceParameter::release_decode_parameter() {
  clear_has_decode_parameter();
  ::vas::DecodeParameter* temp = decode_parameter_;
  decode_parameter_ = NULL;
  return temp;
}
inline void ServiceParameter::set_allocated_decode_parameter(::vas::DecodeParameter* decode_parameter) {
  delete decode_parameter_;
  decode_parameter_ = decode_parameter;
  if (decode_parameter) {
    set_has_decode_parameter();
  } else {
    clear_has_decode_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.ServiceParameter.decode_parameter)
}

// optional .vas.DetectParameter detect_parameter = 3;
inline bool ServiceParameter::has_detect_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceParameter::set_has_detect_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceParameter::clear_has_detect_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceParameter::clear_detect_parameter() {
  if (detect_parameter_ != NULL) detect_parameter_->::vas::DetectParameter::Clear();
  clear_has_detect_parameter();
}
inline const ::vas::DetectParameter& ServiceParameter::detect_parameter() const {
  // @@protoc_insertion_point(field_get:vas.ServiceParameter.detect_parameter)
  return detect_parameter_ != NULL ? *detect_parameter_ : *default_instance_->detect_parameter_;
}
inline ::vas::DetectParameter* ServiceParameter::mutable_detect_parameter() {
  set_has_detect_parameter();
  if (detect_parameter_ == NULL) detect_parameter_ = new ::vas::DetectParameter;
  // @@protoc_insertion_point(field_mutable:vas.ServiceParameter.detect_parameter)
  return detect_parameter_;
}
inline ::vas::DetectParameter* ServiceParameter::release_detect_parameter() {
  clear_has_detect_parameter();
  ::vas::DetectParameter* temp = detect_parameter_;
  detect_parameter_ = NULL;
  return temp;
}
inline void ServiceParameter::set_allocated_detect_parameter(::vas::DetectParameter* detect_parameter) {
  delete detect_parameter_;
  detect_parameter_ = detect_parameter;
  if (detect_parameter) {
    set_has_detect_parameter();
  } else {
    clear_has_detect_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.ServiceParameter.detect_parameter)
}

// optional .vas.ServiceStatus service_status = 4;
inline bool ServiceParameter::has_service_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceParameter::set_has_service_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceParameter::clear_has_service_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceParameter::clear_service_status() {
  service_status_ = 0;
  clear_has_service_status();
}
inline ::vas::ServiceStatus ServiceParameter::service_status() const {
  // @@protoc_insertion_point(field_get:vas.ServiceParameter.service_status)
  return static_cast< ::vas::ServiceStatus >(service_status_);
}
inline void ServiceParameter::set_service_status(::vas::ServiceStatus value) {
  assert(::vas::ServiceStatus_IsValid(value));
  set_has_service_status();
  service_status_ = value;
  // @@protoc_insertion_point(field_set:vas.ServiceParameter.service_status)
}

// optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
inline bool ServiceParameter::has_reg_msg_subscribe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceParameter::set_has_reg_msg_subscribe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceParameter::clear_has_reg_msg_subscribe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceParameter::clear_reg_msg_subscribe() {
  reg_msg_subscribe_ = 1;
  clear_has_reg_msg_subscribe();
}
inline ::vas::RegMsgSubscribe ServiceParameter::reg_msg_subscribe() const {
  // @@protoc_insertion_point(field_get:vas.ServiceParameter.reg_msg_subscribe)
  return static_cast< ::vas::RegMsgSubscribe >(reg_msg_subscribe_);
}
inline void ServiceParameter::set_reg_msg_subscribe(::vas::RegMsgSubscribe value) {
  assert(::vas::RegMsgSubscribe_IsValid(value));
  set_has_reg_msg_subscribe();
  reg_msg_subscribe_ = value;
  // @@protoc_insertion_point(field_set:vas.ServiceParameter.reg_msg_subscribe)
}

// -------------------------------------------------------------------

// SsdServiceParameter

// optional string service_id = 1;
inline bool SsdServiceParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SsdServiceParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SsdServiceParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SsdServiceParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& SsdServiceParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.SsdServiceParameter.service_id)
  return *service_id_;
}
inline void SsdServiceParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdServiceParameter.service_id)
}
inline void SsdServiceParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdServiceParameter.service_id)
}
inline void SsdServiceParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdServiceParameter.service_id)
}
inline ::std::string* SsdServiceParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdServiceParameter.service_id)
  return service_id_;
}
inline ::std::string* SsdServiceParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdServiceParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdServiceParameter.service_id)
}

// optional .vas.DecodeParameter decode_parameter = 2;
inline bool SsdServiceParameter::has_decode_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SsdServiceParameter::set_has_decode_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SsdServiceParameter::clear_has_decode_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SsdServiceParameter::clear_decode_parameter() {
  if (decode_parameter_ != NULL) decode_parameter_->::vas::DecodeParameter::Clear();
  clear_has_decode_parameter();
}
inline const ::vas::DecodeParameter& SsdServiceParameter::decode_parameter() const {
  // @@protoc_insertion_point(field_get:vas.SsdServiceParameter.decode_parameter)
  return decode_parameter_ != NULL ? *decode_parameter_ : *default_instance_->decode_parameter_;
}
inline ::vas::DecodeParameter* SsdServiceParameter::mutable_decode_parameter() {
  set_has_decode_parameter();
  if (decode_parameter_ == NULL) decode_parameter_ = new ::vas::DecodeParameter;
  // @@protoc_insertion_point(field_mutable:vas.SsdServiceParameter.decode_parameter)
  return decode_parameter_;
}
inline ::vas::DecodeParameter* SsdServiceParameter::release_decode_parameter() {
  clear_has_decode_parameter();
  ::vas::DecodeParameter* temp = decode_parameter_;
  decode_parameter_ = NULL;
  return temp;
}
inline void SsdServiceParameter::set_allocated_decode_parameter(::vas::DecodeParameter* decode_parameter) {
  delete decode_parameter_;
  decode_parameter_ = decode_parameter;
  if (decode_parameter) {
    set_has_decode_parameter();
  } else {
    clear_has_decode_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdServiceParameter.decode_parameter)
}

// optional .vas.SsdDetecterParameter detect_parameter = 3;
inline bool SsdServiceParameter::has_detect_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SsdServiceParameter::set_has_detect_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SsdServiceParameter::clear_has_detect_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SsdServiceParameter::clear_detect_parameter() {
  if (detect_parameter_ != NULL) detect_parameter_->::vas::SsdDetecterParameter::Clear();
  clear_has_detect_parameter();
}
inline const ::vas::SsdDetecterParameter& SsdServiceParameter::detect_parameter() const {
  // @@protoc_insertion_point(field_get:vas.SsdServiceParameter.detect_parameter)
  return detect_parameter_ != NULL ? *detect_parameter_ : *default_instance_->detect_parameter_;
}
inline ::vas::SsdDetecterParameter* SsdServiceParameter::mutable_detect_parameter() {
  set_has_detect_parameter();
  if (detect_parameter_ == NULL) detect_parameter_ = new ::vas::SsdDetecterParameter;
  // @@protoc_insertion_point(field_mutable:vas.SsdServiceParameter.detect_parameter)
  return detect_parameter_;
}
inline ::vas::SsdDetecterParameter* SsdServiceParameter::release_detect_parameter() {
  clear_has_detect_parameter();
  ::vas::SsdDetecterParameter* temp = detect_parameter_;
  detect_parameter_ = NULL;
  return temp;
}
inline void SsdServiceParameter::set_allocated_detect_parameter(::vas::SsdDetecterParameter* detect_parameter) {
  delete detect_parameter_;
  detect_parameter_ = detect_parameter;
  if (detect_parameter) {
    set_has_detect_parameter();
  } else {
    clear_has_detect_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdServiceParameter.detect_parameter)
}

// optional .vas.ServiceStatus service_status = 4;
inline bool SsdServiceParameter::has_service_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SsdServiceParameter::set_has_service_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SsdServiceParameter::clear_has_service_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SsdServiceParameter::clear_service_status() {
  service_status_ = 0;
  clear_has_service_status();
}
inline ::vas::ServiceStatus SsdServiceParameter::service_status() const {
  // @@protoc_insertion_point(field_get:vas.SsdServiceParameter.service_status)
  return static_cast< ::vas::ServiceStatus >(service_status_);
}
inline void SsdServiceParameter::set_service_status(::vas::ServiceStatus value) {
  assert(::vas::ServiceStatus_IsValid(value));
  set_has_service_status();
  service_status_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdServiceParameter.service_status)
}

// optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
inline bool SsdServiceParameter::has_reg_msg_subscribe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SsdServiceParameter::set_has_reg_msg_subscribe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SsdServiceParameter::clear_has_reg_msg_subscribe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SsdServiceParameter::clear_reg_msg_subscribe() {
  reg_msg_subscribe_ = 1;
  clear_has_reg_msg_subscribe();
}
inline ::vas::RegMsgSubscribe SsdServiceParameter::reg_msg_subscribe() const {
  // @@protoc_insertion_point(field_get:vas.SsdServiceParameter.reg_msg_subscribe)
  return static_cast< ::vas::RegMsgSubscribe >(reg_msg_subscribe_);
}
inline void SsdServiceParameter::set_reg_msg_subscribe(::vas::RegMsgSubscribe value) {
  assert(::vas::RegMsgSubscribe_IsValid(value));
  set_has_reg_msg_subscribe();
  reg_msg_subscribe_ = value;
  // @@protoc_insertion_point(field_set:vas.SsdServiceParameter.reg_msg_subscribe)
}

// -------------------------------------------------------------------

// NvrServiceParameter

// optional string service_id = 1;
inline bool NvrServiceParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NvrServiceParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NvrServiceParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NvrServiceParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& NvrServiceParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.NvrServiceParameter.service_id)
  return *service_id_;
}
inline void NvrServiceParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.NvrServiceParameter.service_id)
}
inline void NvrServiceParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.NvrServiceParameter.service_id)
}
inline void NvrServiceParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.NvrServiceParameter.service_id)
}
inline ::std::string* NvrServiceParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.NvrServiceParameter.service_id)
  return service_id_;
}
inline ::std::string* NvrServiceParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NvrServiceParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrServiceParameter.service_id)
}

// optional .vas.NvrChannel nvr_channel = 2;
inline bool NvrServiceParameter::has_nvr_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NvrServiceParameter::set_has_nvr_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NvrServiceParameter::clear_has_nvr_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NvrServiceParameter::clear_nvr_channel() {
  if (nvr_channel_ != NULL) nvr_channel_->::vas::NvrChannel::Clear();
  clear_has_nvr_channel();
}
inline const ::vas::NvrChannel& NvrServiceParameter::nvr_channel() const {
  // @@protoc_insertion_point(field_get:vas.NvrServiceParameter.nvr_channel)
  return nvr_channel_ != NULL ? *nvr_channel_ : *default_instance_->nvr_channel_;
}
inline ::vas::NvrChannel* NvrServiceParameter::mutable_nvr_channel() {
  set_has_nvr_channel();
  if (nvr_channel_ == NULL) nvr_channel_ = new ::vas::NvrChannel;
  // @@protoc_insertion_point(field_mutable:vas.NvrServiceParameter.nvr_channel)
  return nvr_channel_;
}
inline ::vas::NvrChannel* NvrServiceParameter::release_nvr_channel() {
  clear_has_nvr_channel();
  ::vas::NvrChannel* temp = nvr_channel_;
  nvr_channel_ = NULL;
  return temp;
}
inline void NvrServiceParameter::set_allocated_nvr_channel(::vas::NvrChannel* nvr_channel) {
  delete nvr_channel_;
  nvr_channel_ = nvr_channel;
  if (nvr_channel) {
    set_has_nvr_channel();
  } else {
    clear_has_nvr_channel();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrServiceParameter.nvr_channel)
}

// optional .vas.DetectParameter detect_parameter = 3;
inline bool NvrServiceParameter::has_detect_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NvrServiceParameter::set_has_detect_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NvrServiceParameter::clear_has_detect_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NvrServiceParameter::clear_detect_parameter() {
  if (detect_parameter_ != NULL) detect_parameter_->::vas::DetectParameter::Clear();
  clear_has_detect_parameter();
}
inline const ::vas::DetectParameter& NvrServiceParameter::detect_parameter() const {
  // @@protoc_insertion_point(field_get:vas.NvrServiceParameter.detect_parameter)
  return detect_parameter_ != NULL ? *detect_parameter_ : *default_instance_->detect_parameter_;
}
inline ::vas::DetectParameter* NvrServiceParameter::mutable_detect_parameter() {
  set_has_detect_parameter();
  if (detect_parameter_ == NULL) detect_parameter_ = new ::vas::DetectParameter;
  // @@protoc_insertion_point(field_mutable:vas.NvrServiceParameter.detect_parameter)
  return detect_parameter_;
}
inline ::vas::DetectParameter* NvrServiceParameter::release_detect_parameter() {
  clear_has_detect_parameter();
  ::vas::DetectParameter* temp = detect_parameter_;
  detect_parameter_ = NULL;
  return temp;
}
inline void NvrServiceParameter::set_allocated_detect_parameter(::vas::DetectParameter* detect_parameter) {
  delete detect_parameter_;
  detect_parameter_ = detect_parameter;
  if (detect_parameter) {
    set_has_detect_parameter();
  } else {
    clear_has_detect_parameter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrServiceParameter.detect_parameter)
}

// optional .vas.ServiceStatus service_status = 4;
inline bool NvrServiceParameter::has_service_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NvrServiceParameter::set_has_service_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NvrServiceParameter::clear_has_service_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NvrServiceParameter::clear_service_status() {
  service_status_ = 0;
  clear_has_service_status();
}
inline ::vas::ServiceStatus NvrServiceParameter::service_status() const {
  // @@protoc_insertion_point(field_get:vas.NvrServiceParameter.service_status)
  return static_cast< ::vas::ServiceStatus >(service_status_);
}
inline void NvrServiceParameter::set_service_status(::vas::ServiceStatus value) {
  assert(::vas::ServiceStatus_IsValid(value));
  set_has_service_status();
  service_status_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrServiceParameter.service_status)
}

// optional .vas.RegMsgSubscribe reg_msg_subscribe = 5 [default = SUBSCRIBE_ON];
inline bool NvrServiceParameter::has_reg_msg_subscribe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NvrServiceParameter::set_has_reg_msg_subscribe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NvrServiceParameter::clear_has_reg_msg_subscribe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NvrServiceParameter::clear_reg_msg_subscribe() {
  reg_msg_subscribe_ = 1;
  clear_has_reg_msg_subscribe();
}
inline ::vas::RegMsgSubscribe NvrServiceParameter::reg_msg_subscribe() const {
  // @@protoc_insertion_point(field_get:vas.NvrServiceParameter.reg_msg_subscribe)
  return static_cast< ::vas::RegMsgSubscribe >(reg_msg_subscribe_);
}
inline void NvrServiceParameter::set_reg_msg_subscribe(::vas::RegMsgSubscribe value) {
  assert(::vas::RegMsgSubscribe_IsValid(value));
  set_has_reg_msg_subscribe();
  reg_msg_subscribe_ = value;
  // @@protoc_insertion_point(field_set:vas.NvrServiceParameter.reg_msg_subscribe)
}

// -------------------------------------------------------------------

// ServiceList

// optional string last_update_time = 1;
inline bool ServiceList::has_last_update_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceList::set_has_last_update_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceList::clear_has_last_update_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceList::clear_last_update_time() {
  if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_->clear();
  }
  clear_has_last_update_time();
}
inline const ::std::string& ServiceList::last_update_time() const {
  // @@protoc_insertion_point(field_get:vas.ServiceList.last_update_time)
  return *last_update_time_;
}
inline void ServiceList::set_last_update_time(const ::std::string& value) {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  last_update_time_->assign(value);
  // @@protoc_insertion_point(field_set:vas.ServiceList.last_update_time)
}
inline void ServiceList::set_last_update_time(const char* value) {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  last_update_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.ServiceList.last_update_time)
}
inline void ServiceList::set_last_update_time(const char* value, size_t size) {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  last_update_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.ServiceList.last_update_time)
}
inline ::std::string* ServiceList::mutable_last_update_time() {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.ServiceList.last_update_time)
  return last_update_time_;
}
inline ::std::string* ServiceList::release_last_update_time() {
  clear_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = last_update_time_;
    last_update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServiceList::set_allocated_last_update_time(::std::string* last_update_time) {
  if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete last_update_time_;
  }
  if (last_update_time) {
    set_has_last_update_time();
    last_update_time_ = last_update_time;
  } else {
    clear_has_last_update_time();
    last_update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.ServiceList.last_update_time)
}

// repeated .vas.ServiceParameter service_paramter = 2;
inline int ServiceList::service_paramter_size() const {
  return service_paramter_.size();
}
inline void ServiceList::clear_service_paramter() {
  service_paramter_.Clear();
}
inline const ::vas::ServiceParameter& ServiceList::service_paramter(int index) const {
  // @@protoc_insertion_point(field_get:vas.ServiceList.service_paramter)
  return service_paramter_.Get(index);
}
inline ::vas::ServiceParameter* ServiceList::mutable_service_paramter(int index) {
  // @@protoc_insertion_point(field_mutable:vas.ServiceList.service_paramter)
  return service_paramter_.Mutable(index);
}
inline ::vas::ServiceParameter* ServiceList::add_service_paramter() {
  // @@protoc_insertion_point(field_add:vas.ServiceList.service_paramter)
  return service_paramter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vas::ServiceParameter >&
ServiceList::service_paramter() const {
  // @@protoc_insertion_point(field_list:vas.ServiceList.service_paramter)
  return service_paramter_;
}
inline ::google::protobuf::RepeatedPtrField< ::vas::ServiceParameter >*
ServiceList::mutable_service_paramter() {
  // @@protoc_insertion_point(field_mutable_list:vas.ServiceList.service_paramter)
  return &service_paramter_;
}

// -------------------------------------------------------------------

// SsdServiceList

// optional string last_update_time = 1;
inline bool SsdServiceList::has_last_update_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SsdServiceList::set_has_last_update_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SsdServiceList::clear_has_last_update_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SsdServiceList::clear_last_update_time() {
  if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_->clear();
  }
  clear_has_last_update_time();
}
inline const ::std::string& SsdServiceList::last_update_time() const {
  // @@protoc_insertion_point(field_get:vas.SsdServiceList.last_update_time)
  return *last_update_time_;
}
inline void SsdServiceList::set_last_update_time(const ::std::string& value) {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  last_update_time_->assign(value);
  // @@protoc_insertion_point(field_set:vas.SsdServiceList.last_update_time)
}
inline void SsdServiceList::set_last_update_time(const char* value) {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  last_update_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.SsdServiceList.last_update_time)
}
inline void SsdServiceList::set_last_update_time(const char* value, size_t size) {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  last_update_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.SsdServiceList.last_update_time)
}
inline ::std::string* SsdServiceList::mutable_last_update_time() {
  set_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    last_update_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.SsdServiceList.last_update_time)
  return last_update_time_;
}
inline ::std::string* SsdServiceList::release_last_update_time() {
  clear_has_last_update_time();
  if (last_update_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = last_update_time_;
    last_update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SsdServiceList::set_allocated_last_update_time(::std::string* last_update_time) {
  if (last_update_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete last_update_time_;
  }
  if (last_update_time) {
    set_has_last_update_time();
    last_update_time_ = last_update_time;
  } else {
    clear_has_last_update_time();
    last_update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.SsdServiceList.last_update_time)
}

// repeated .vas.SsdServiceParameter service_paramter = 2;
inline int SsdServiceList::service_paramter_size() const {
  return service_paramter_.size();
}
inline void SsdServiceList::clear_service_paramter() {
  service_paramter_.Clear();
}
inline const ::vas::SsdServiceParameter& SsdServiceList::service_paramter(int index) const {
  // @@protoc_insertion_point(field_get:vas.SsdServiceList.service_paramter)
  return service_paramter_.Get(index);
}
inline ::vas::SsdServiceParameter* SsdServiceList::mutable_service_paramter(int index) {
  // @@protoc_insertion_point(field_mutable:vas.SsdServiceList.service_paramter)
  return service_paramter_.Mutable(index);
}
inline ::vas::SsdServiceParameter* SsdServiceList::add_service_paramter() {
  // @@protoc_insertion_point(field_add:vas.SsdServiceList.service_paramter)
  return service_paramter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vas::SsdServiceParameter >&
SsdServiceList::service_paramter() const {
  // @@protoc_insertion_point(field_list:vas.SsdServiceList.service_paramter)
  return service_paramter_;
}
inline ::google::protobuf::RepeatedPtrField< ::vas::SsdServiceParameter >*
SsdServiceList::mutable_service_paramter() {
  // @@protoc_insertion_point(field_mutable_list:vas.SsdServiceList.service_paramter)
  return &service_paramter_;
}

// -------------------------------------------------------------------

// NvrServiceList

// optional .vas.NvrParameter nvr_paramter = 1;
inline bool NvrServiceList::has_nvr_paramter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NvrServiceList::set_has_nvr_paramter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NvrServiceList::clear_has_nvr_paramter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NvrServiceList::clear_nvr_paramter() {
  if (nvr_paramter_ != NULL) nvr_paramter_->::vas::NvrParameter::Clear();
  clear_has_nvr_paramter();
}
inline const ::vas::NvrParameter& NvrServiceList::nvr_paramter() const {
  // @@protoc_insertion_point(field_get:vas.NvrServiceList.nvr_paramter)
  return nvr_paramter_ != NULL ? *nvr_paramter_ : *default_instance_->nvr_paramter_;
}
inline ::vas::NvrParameter* NvrServiceList::mutable_nvr_paramter() {
  set_has_nvr_paramter();
  if (nvr_paramter_ == NULL) nvr_paramter_ = new ::vas::NvrParameter;
  // @@protoc_insertion_point(field_mutable:vas.NvrServiceList.nvr_paramter)
  return nvr_paramter_;
}
inline ::vas::NvrParameter* NvrServiceList::release_nvr_paramter() {
  clear_has_nvr_paramter();
  ::vas::NvrParameter* temp = nvr_paramter_;
  nvr_paramter_ = NULL;
  return temp;
}
inline void NvrServiceList::set_allocated_nvr_paramter(::vas::NvrParameter* nvr_paramter) {
  delete nvr_paramter_;
  nvr_paramter_ = nvr_paramter;
  if (nvr_paramter) {
    set_has_nvr_paramter();
  } else {
    clear_has_nvr_paramter();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.NvrServiceList.nvr_paramter)
}

// repeated .vas.NvrServiceParameter service_parameter = 2;
inline int NvrServiceList::service_parameter_size() const {
  return service_parameter_.size();
}
inline void NvrServiceList::clear_service_parameter() {
  service_parameter_.Clear();
}
inline const ::vas::NvrServiceParameter& NvrServiceList::service_parameter(int index) const {
  // @@protoc_insertion_point(field_get:vas.NvrServiceList.service_parameter)
  return service_parameter_.Get(index);
}
inline ::vas::NvrServiceParameter* NvrServiceList::mutable_service_parameter(int index) {
  // @@protoc_insertion_point(field_mutable:vas.NvrServiceList.service_parameter)
  return service_parameter_.Mutable(index);
}
inline ::vas::NvrServiceParameter* NvrServiceList::add_service_parameter() {
  // @@protoc_insertion_point(field_add:vas.NvrServiceList.service_parameter)
  return service_parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vas::NvrServiceParameter >&
NvrServiceList::service_parameter() const {
  // @@protoc_insertion_point(field_list:vas.NvrServiceList.service_parameter)
  return service_parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::vas::NvrServiceParameter >*
NvrServiceList::mutable_service_parameter() {
  // @@protoc_insertion_point(field_mutable_list:vas.NvrServiceList.service_parameter)
  return &service_parameter_;
}

// -------------------------------------------------------------------

// VasComParameter

// optional string ip = 1;
inline bool VasComParameter::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasComParameter::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasComParameter::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasComParameter::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& VasComParameter::ip() const {
  // @@protoc_insertion_point(field_get:vas.VasComParameter.ip)
  return *ip_;
}
inline void VasComParameter::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasComParameter.ip)
}
inline void VasComParameter::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasComParameter.ip)
}
inline void VasComParameter::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasComParameter.ip)
}
inline ::std::string* VasComParameter::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasComParameter.ip)
  return ip_;
}
inline ::std::string* VasComParameter::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasComParameter::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasComParameter.ip)
}

// optional int64 port = 2 [default = 8001];
inline bool VasComParameter::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasComParameter::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasComParameter::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasComParameter::clear_port() {
  port_ = GOOGLE_LONGLONG(8001);
  clear_has_port();
}
inline ::google::protobuf::int64 VasComParameter::port() const {
  // @@protoc_insertion_point(field_get:vas.VasComParameter.port)
  return port_;
}
inline void VasComParameter::set_port(::google::protobuf::int64 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:vas.VasComParameter.port)
}

// optional .vas.EnAppState app_state = 3 [default = ST_STOPPED];
inline bool VasComParameter::has_app_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VasComParameter::set_has_app_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VasComParameter::clear_has_app_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VasComParameter::clear_app_state() {
  app_state_ = 2;
  clear_has_app_state();
}
inline ::vas::EnAppState VasComParameter::app_state() const {
  // @@protoc_insertion_point(field_get:vas.VasComParameter.app_state)
  return static_cast< ::vas::EnAppState >(app_state_);
}
inline void VasComParameter::set_app_state(::vas::EnAppState value) {
  assert(::vas::EnAppState_IsValid(value));
  set_has_app_state();
  app_state_ = value;
  // @@protoc_insertion_point(field_set:vas.VasComParameter.app_state)
}

// optional int32 heartbeat_interval = 4 [default = 10];
inline bool VasComParameter::has_heartbeat_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VasComParameter::set_has_heartbeat_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VasComParameter::clear_has_heartbeat_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VasComParameter::clear_heartbeat_interval() {
  heartbeat_interval_ = 10;
  clear_has_heartbeat_interval();
}
inline ::google::protobuf::int32 VasComParameter::heartbeat_interval() const {
  // @@protoc_insertion_point(field_get:vas.VasComParameter.heartbeat_interval)
  return heartbeat_interval_;
}
inline void VasComParameter::set_heartbeat_interval(::google::protobuf::int32 value) {
  set_has_heartbeat_interval();
  heartbeat_interval_ = value;
  // @@protoc_insertion_point(field_set:vas.VasComParameter.heartbeat_interval)
}

// -------------------------------------------------------------------

// VasComputeNode

// optional int32 node_id = 1;
inline bool VasComputeNode::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasComputeNode::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasComputeNode::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasComputeNode::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 VasComputeNode::node_id() const {
  // @@protoc_insertion_point(field_get:vas.VasComputeNode.node_id)
  return node_id_;
}
inline void VasComputeNode::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vas.VasComputeNode.node_id)
}

// optional string node_name = 2;
inline bool VasComputeNode::has_node_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasComputeNode::set_has_node_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasComputeNode::clear_has_node_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasComputeNode::clear_node_name() {
  if (node_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_->clear();
  }
  clear_has_node_name();
}
inline const ::std::string& VasComputeNode::node_name() const {
  // @@protoc_insertion_point(field_get:vas.VasComputeNode.node_name)
  return *node_name_;
}
inline void VasComputeNode::set_node_name(const ::std::string& value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasComputeNode.node_name)
}
inline void VasComputeNode::set_node_name(const char* value) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasComputeNode.node_name)
}
inline void VasComputeNode::set_node_name(const char* value, size_t size) {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  node_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasComputeNode.node_name)
}
inline ::std::string* VasComputeNode::mutable_node_name() {
  set_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    node_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasComputeNode.node_name)
  return node_name_;
}
inline ::std::string* VasComputeNode::release_node_name() {
  clear_has_node_name();
  if (node_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = node_name_;
    node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasComputeNode::set_allocated_node_name(::std::string* node_name) {
  if (node_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete node_name_;
  }
  if (node_name) {
    set_has_node_name();
    node_name_ = node_name;
  } else {
    clear_has_node_name();
    node_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasComputeNode.node_name)
}

// optional int32 center_id = 3;
inline bool VasComputeNode::has_center_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VasComputeNode::set_has_center_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VasComputeNode::clear_has_center_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VasComputeNode::clear_center_id() {
  center_id_ = 0;
  clear_has_center_id();
}
inline ::google::protobuf::int32 VasComputeNode::center_id() const {
  // @@protoc_insertion_point(field_get:vas.VasComputeNode.center_id)
  return center_id_;
}
inline void VasComputeNode::set_center_id(::google::protobuf::int32 value) {
  set_has_center_id();
  center_id_ = value;
  // @@protoc_insertion_point(field_set:vas.VasComputeNode.center_id)
}

// optional int32 com_version = 4;
inline bool VasComputeNode::has_com_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VasComputeNode::set_has_com_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VasComputeNode::clear_has_com_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VasComputeNode::clear_com_version() {
  com_version_ = 0;
  clear_has_com_version();
}
inline ::google::protobuf::int32 VasComputeNode::com_version() const {
  // @@protoc_insertion_point(field_get:vas.VasComputeNode.com_version)
  return com_version_;
}
inline void VasComputeNode::set_com_version(::google::protobuf::int32 value) {
  set_has_com_version();
  com_version_ = value;
  // @@protoc_insertion_point(field_set:vas.VasComputeNode.com_version)
}

// optional int32 retry_count = 5;
inline bool VasComputeNode::has_retry_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VasComputeNode::set_has_retry_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VasComputeNode::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VasComputeNode::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
inline ::google::protobuf::int32 VasComputeNode::retry_count() const {
  // @@protoc_insertion_point(field_get:vas.VasComputeNode.retry_count)
  return retry_count_;
}
inline void VasComputeNode::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:vas.VasComputeNode.retry_count)
}

// -------------------------------------------------------------------

// VasClientParameter

// optional .vas.VasComParameter com_param = 1;
inline bool VasClientParameter::has_com_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasClientParameter::set_has_com_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasClientParameter::clear_has_com_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasClientParameter::clear_com_param() {
  if (com_param_ != NULL) com_param_->::vas::VasComParameter::Clear();
  clear_has_com_param();
}
inline const ::vas::VasComParameter& VasClientParameter::com_param() const {
  // @@protoc_insertion_point(field_get:vas.VasClientParameter.com_param)
  return com_param_ != NULL ? *com_param_ : *default_instance_->com_param_;
}
inline ::vas::VasComParameter* VasClientParameter::mutable_com_param() {
  set_has_com_param();
  if (com_param_ == NULL) com_param_ = new ::vas::VasComParameter;
  // @@protoc_insertion_point(field_mutable:vas.VasClientParameter.com_param)
  return com_param_;
}
inline ::vas::VasComParameter* VasClientParameter::release_com_param() {
  clear_has_com_param();
  ::vas::VasComParameter* temp = com_param_;
  com_param_ = NULL;
  return temp;
}
inline void VasClientParameter::set_allocated_com_param(::vas::VasComParameter* com_param) {
  delete com_param_;
  com_param_ = com_param;
  if (com_param) {
    set_has_com_param();
  } else {
    clear_has_com_param();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasClientParameter.com_param)
}

// optional .vas.VasComputeNode node_param = 2;
inline bool VasClientParameter::has_node_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasClientParameter::set_has_node_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasClientParameter::clear_has_node_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasClientParameter::clear_node_param() {
  if (node_param_ != NULL) node_param_->::vas::VasComputeNode::Clear();
  clear_has_node_param();
}
inline const ::vas::VasComputeNode& VasClientParameter::node_param() const {
  // @@protoc_insertion_point(field_get:vas.VasClientParameter.node_param)
  return node_param_ != NULL ? *node_param_ : *default_instance_->node_param_;
}
inline ::vas::VasComputeNode* VasClientParameter::mutable_node_param() {
  set_has_node_param();
  if (node_param_ == NULL) node_param_ = new ::vas::VasComputeNode;
  // @@protoc_insertion_point(field_mutable:vas.VasClientParameter.node_param)
  return node_param_;
}
inline ::vas::VasComputeNode* VasClientParameter::release_node_param() {
  clear_has_node_param();
  ::vas::VasComputeNode* temp = node_param_;
  node_param_ = NULL;
  return temp;
}
inline void VasClientParameter::set_allocated_node_param(::vas::VasComputeNode* node_param) {
  delete node_param_;
  node_param_ = node_param;
  if (node_param) {
    set_has_node_param();
  } else {
    clear_has_node_param();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasClientParameter.node_param)
}

// -------------------------------------------------------------------

// VasMsgFilterParam

// optional string service_id = 1;
inline bool VasMsgFilterParam::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasMsgFilterParam::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasMsgFilterParam::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasMsgFilterParam::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& VasMsgFilterParam::service_id() const {
  // @@protoc_insertion_point(field_get:vas.VasMsgFilterParam.service_id)
  return *service_id_;
}
inline void VasMsgFilterParam::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasMsgFilterParam.service_id)
}
inline void VasMsgFilterParam::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasMsgFilterParam.service_id)
}
inline void VasMsgFilterParam::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasMsgFilterParam.service_id)
}
inline ::std::string* VasMsgFilterParam::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasMsgFilterParam.service_id)
  return service_id_;
}
inline ::std::string* VasMsgFilterParam::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasMsgFilterParam::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasMsgFilterParam.service_id)
}

// optional int32 interval_sec = 2 [default = 5];
inline bool VasMsgFilterParam::has_interval_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasMsgFilterParam::set_has_interval_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasMsgFilterParam::clear_has_interval_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasMsgFilterParam::clear_interval_sec() {
  interval_sec_ = 5;
  clear_has_interval_sec();
}
inline ::google::protobuf::int32 VasMsgFilterParam::interval_sec() const {
  // @@protoc_insertion_point(field_get:vas.VasMsgFilterParam.interval_sec)
  return interval_sec_;
}
inline void VasMsgFilterParam::set_interval_sec(::google::protobuf::int32 value) {
  set_has_interval_sec();
  interval_sec_ = value;
  // @@protoc_insertion_point(field_set:vas.VasMsgFilterParam.interval_sec)
}

// -------------------------------------------------------------------

// VasHeartbeatParameter

// optional string app_key = 1;
inline bool VasHeartbeatParameter::has_app_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasHeartbeatParameter::set_has_app_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasHeartbeatParameter::clear_has_app_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasHeartbeatParameter::clear_app_key() {
  if (app_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_key_->clear();
  }
  clear_has_app_key();
}
inline const ::std::string& VasHeartbeatParameter::app_key() const {
  // @@protoc_insertion_point(field_get:vas.VasHeartbeatParameter.app_key)
  return *app_key_;
}
inline void VasHeartbeatParameter::set_app_key(const ::std::string& value) {
  set_has_app_key();
  if (app_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_key_ = new ::std::string;
  }
  app_key_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasHeartbeatParameter.app_key)
}
inline void VasHeartbeatParameter::set_app_key(const char* value) {
  set_has_app_key();
  if (app_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_key_ = new ::std::string;
  }
  app_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasHeartbeatParameter.app_key)
}
inline void VasHeartbeatParameter::set_app_key(const char* value, size_t size) {
  set_has_app_key();
  if (app_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_key_ = new ::std::string;
  }
  app_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasHeartbeatParameter.app_key)
}
inline ::std::string* VasHeartbeatParameter::mutable_app_key() {
  set_has_app_key();
  if (app_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasHeartbeatParameter.app_key)
  return app_key_;
}
inline ::std::string* VasHeartbeatParameter::release_app_key() {
  clear_has_app_key();
  if (app_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = app_key_;
    app_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasHeartbeatParameter::set_allocated_app_key(::std::string* app_key) {
  if (app_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete app_key_;
  }
  if (app_key) {
    set_has_app_key();
    app_key_ = app_key;
  } else {
    clear_has_app_key();
    app_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasHeartbeatParameter.app_key)
}

// optional int32 node_id = 2;
inline bool VasHeartbeatParameter::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasHeartbeatParameter::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasHeartbeatParameter::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasHeartbeatParameter::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 VasHeartbeatParameter::node_id() const {
  // @@protoc_insertion_point(field_get:vas.VasHeartbeatParameter.node_id)
  return node_id_;
}
inline void VasHeartbeatParameter::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vas.VasHeartbeatParameter.node_id)
}

// optional string service_list = 3;
inline bool VasHeartbeatParameter::has_service_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VasHeartbeatParameter::set_has_service_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VasHeartbeatParameter::clear_has_service_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VasHeartbeatParameter::clear_service_list() {
  if (service_list_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_list_->clear();
  }
  clear_has_service_list();
}
inline const ::std::string& VasHeartbeatParameter::service_list() const {
  // @@protoc_insertion_point(field_get:vas.VasHeartbeatParameter.service_list)
  return *service_list_;
}
inline void VasHeartbeatParameter::set_service_list(const ::std::string& value) {
  set_has_service_list();
  if (service_list_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_list_ = new ::std::string;
  }
  service_list_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasHeartbeatParameter.service_list)
}
inline void VasHeartbeatParameter::set_service_list(const char* value) {
  set_has_service_list();
  if (service_list_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_list_ = new ::std::string;
  }
  service_list_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasHeartbeatParameter.service_list)
}
inline void VasHeartbeatParameter::set_service_list(const char* value, size_t size) {
  set_has_service_list();
  if (service_list_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_list_ = new ::std::string;
  }
  service_list_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasHeartbeatParameter.service_list)
}
inline ::std::string* VasHeartbeatParameter::mutable_service_list() {
  set_has_service_list();
  if (service_list_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_list_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasHeartbeatParameter.service_list)
  return service_list_;
}
inline ::std::string* VasHeartbeatParameter::release_service_list() {
  clear_has_service_list();
  if (service_list_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_list_;
    service_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasHeartbeatParameter::set_allocated_service_list(::std::string* service_list) {
  if (service_list_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_list_;
  }
  if (service_list) {
    set_has_service_list();
    service_list_ = service_list;
  } else {
    clear_has_service_list();
    service_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasHeartbeatParameter.service_list)
}

// optional int64 timestamp = 4;
inline bool VasHeartbeatParameter::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VasHeartbeatParameter::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VasHeartbeatParameter::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VasHeartbeatParameter::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 VasHeartbeatParameter::timestamp() const {
  // @@protoc_insertion_point(field_get:vas.VasHeartbeatParameter.timestamp)
  return timestamp_;
}
inline void VasHeartbeatParameter::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vas.VasHeartbeatParameter.timestamp)
}

// -------------------------------------------------------------------

// VasHeartbeat

// optional string psi_name = 1;
inline bool VasHeartbeat::has_psi_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasHeartbeat::set_has_psi_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasHeartbeat::clear_has_psi_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasHeartbeat::clear_psi_name() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_->clear();
  }
  clear_has_psi_name();
}
inline const ::std::string& VasHeartbeat::psi_name() const {
  // @@protoc_insertion_point(field_get:vas.VasHeartbeat.psi_name)
  return *psi_name_;
}
inline void VasHeartbeat::set_psi_name(const ::std::string& value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasHeartbeat.psi_name)
}
inline void VasHeartbeat::set_psi_name(const char* value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasHeartbeat.psi_name)
}
inline void VasHeartbeat::set_psi_name(const char* value, size_t size) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasHeartbeat.psi_name)
}
inline ::std::string* VasHeartbeat::mutable_psi_name() {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasHeartbeat.psi_name)
  return psi_name_;
}
inline ::std::string* VasHeartbeat::release_psi_name() {
  clear_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = psi_name_;
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasHeartbeat::set_allocated_psi_name(::std::string* psi_name) {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (psi_name) {
    set_has_psi_name();
    psi_name_ = psi_name;
  } else {
    clear_has_psi_name();
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasHeartbeat.psi_name)
}

// optional .vas.VasHeartbeatParameter params = 2;
inline bool VasHeartbeat::has_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasHeartbeat::set_has_params() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasHeartbeat::clear_has_params() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasHeartbeat::clear_params() {
  if (params_ != NULL) params_->::vas::VasHeartbeatParameter::Clear();
  clear_has_params();
}
inline const ::vas::VasHeartbeatParameter& VasHeartbeat::params() const {
  // @@protoc_insertion_point(field_get:vas.VasHeartbeat.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::vas::VasHeartbeatParameter* VasHeartbeat::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::vas::VasHeartbeatParameter;
  // @@protoc_insertion_point(field_mutable:vas.VasHeartbeat.params)
  return params_;
}
inline ::vas::VasHeartbeatParameter* VasHeartbeat::release_params() {
  clear_has_params();
  ::vas::VasHeartbeatParameter* temp = params_;
  params_ = NULL;
  return temp;
}
inline void VasHeartbeat::set_allocated_params(::vas::VasHeartbeatParameter* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasHeartbeat.params)
}

// -------------------------------------------------------------------

// VasRetrunParamter

// optional string psi_name = 1;
inline bool VasRetrunParamter::has_psi_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasRetrunParamter::set_has_psi_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasRetrunParamter::clear_has_psi_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasRetrunParamter::clear_psi_name() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_->clear();
  }
  clear_has_psi_name();
}
inline const ::std::string& VasRetrunParamter::psi_name() const {
  // @@protoc_insertion_point(field_get:vas.VasRetrunParamter.psi_name)
  return *psi_name_;
}
inline void VasRetrunParamter::set_psi_name(const ::std::string& value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasRetrunParamter.psi_name)
}
inline void VasRetrunParamter::set_psi_name(const char* value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasRetrunParamter.psi_name)
}
inline void VasRetrunParamter::set_psi_name(const char* value, size_t size) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasRetrunParamter.psi_name)
}
inline ::std::string* VasRetrunParamter::mutable_psi_name() {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasRetrunParamter.psi_name)
  return psi_name_;
}
inline ::std::string* VasRetrunParamter::release_psi_name() {
  clear_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = psi_name_;
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasRetrunParamter::set_allocated_psi_name(::std::string* psi_name) {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (psi_name) {
    set_has_psi_name();
    psi_name_ = psi_name;
  } else {
    clear_has_psi_name();
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasRetrunParamter.psi_name)
}

// optional int32 node_id = 2;
inline bool VasRetrunParamter::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasRetrunParamter::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasRetrunParamter::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasRetrunParamter::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 VasRetrunParamter::node_id() const {
  // @@protoc_insertion_point(field_get:vas.VasRetrunParamter.node_id)
  return node_id_;
}
inline void VasRetrunParamter::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vas.VasRetrunParamter.node_id)
}

// optional int64 timestamp = 3;
inline bool VasRetrunParamter::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VasRetrunParamter::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VasRetrunParamter::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VasRetrunParamter::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 VasRetrunParamter::timestamp() const {
  // @@protoc_insertion_point(field_get:vas.VasRetrunParamter.timestamp)
  return timestamp_;
}
inline void VasRetrunParamter::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vas.VasRetrunParamter.timestamp)
}

// -------------------------------------------------------------------

// VasReturn

// optional int32 ret_code = 1;
inline bool VasReturn::has_ret_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasReturn::set_has_ret_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasReturn::clear_has_ret_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasReturn::clear_ret_code() {
  ret_code_ = 0;
  clear_has_ret_code();
}
inline ::google::protobuf::int32 VasReturn::ret_code() const {
  // @@protoc_insertion_point(field_get:vas.VasReturn.ret_code)
  return ret_code_;
}
inline void VasReturn::set_ret_code(::google::protobuf::int32 value) {
  set_has_ret_code();
  ret_code_ = value;
  // @@protoc_insertion_point(field_set:vas.VasReturn.ret_code)
}

// optional string ret_msg = 2;
inline bool VasReturn::has_ret_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasReturn::set_has_ret_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasReturn::clear_has_ret_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasReturn::clear_ret_msg() {
  if (ret_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_msg_->clear();
  }
  clear_has_ret_msg();
}
inline const ::std::string& VasReturn::ret_msg() const {
  // @@protoc_insertion_point(field_get:vas.VasReturn.ret_msg)
  return *ret_msg_;
}
inline void VasReturn::set_ret_msg(const ::std::string& value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasReturn.ret_msg)
}
inline void VasReturn::set_ret_msg(const char* value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasReturn.ret_msg)
}
inline void VasReturn::set_ret_msg(const char* value, size_t size) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasReturn.ret_msg)
}
inline ::std::string* VasReturn::mutable_ret_msg() {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ret_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasReturn.ret_msg)
  return ret_msg_;
}
inline ::std::string* VasReturn::release_ret_msg() {
  clear_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ret_msg_;
    ret_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasReturn::set_allocated_ret_msg(::std::string* ret_msg) {
  if (ret_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ret_msg_;
  }
  if (ret_msg) {
    set_has_ret_msg();
    ret_msg_ = ret_msg;
  } else {
    clear_has_ret_msg();
    ret_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasReturn.ret_msg)
}

// optional .vas.VasRetrunParamter params = 3;
inline bool VasReturn::has_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VasReturn::set_has_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VasReturn::clear_has_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VasReturn::clear_params() {
  if (params_ != NULL) params_->::vas::VasRetrunParamter::Clear();
  clear_has_params();
}
inline const ::vas::VasRetrunParamter& VasReturn::params() const {
  // @@protoc_insertion_point(field_get:vas.VasReturn.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::vas::VasRetrunParamter* VasReturn::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::vas::VasRetrunParamter;
  // @@protoc_insertion_point(field_mutable:vas.VasReturn.params)
  return params_;
}
inline ::vas::VasRetrunParamter* VasReturn::release_params() {
  clear_has_params();
  ::vas::VasRetrunParamter* temp = params_;
  params_ = NULL;
  return temp;
}
inline void VasReturn::set_allocated_params(::vas::VasRetrunParamter* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasReturn.params)
}

// -------------------------------------------------------------------

// RegRes

// optional string reg_type = 1;
inline bool RegRes::has_reg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegRes::set_has_reg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegRes::clear_has_reg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegRes::clear_reg_type() {
  if (reg_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reg_type_->clear();
  }
  clear_has_reg_type();
}
inline const ::std::string& RegRes::reg_type() const {
  // @@protoc_insertion_point(field_get:vas.RegRes.reg_type)
  return *reg_type_;
}
inline void RegRes::set_reg_type(const ::std::string& value) {
  set_has_reg_type();
  if (reg_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reg_type_ = new ::std::string;
  }
  reg_type_->assign(value);
  // @@protoc_insertion_point(field_set:vas.RegRes.reg_type)
}
inline void RegRes::set_reg_type(const char* value) {
  set_has_reg_type();
  if (reg_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reg_type_ = new ::std::string;
  }
  reg_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.RegRes.reg_type)
}
inline void RegRes::set_reg_type(const char* value, size_t size) {
  set_has_reg_type();
  if (reg_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reg_type_ = new ::std::string;
  }
  reg_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.RegRes.reg_type)
}
inline ::std::string* RegRes::mutable_reg_type() {
  set_has_reg_type();
  if (reg_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reg_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.RegRes.reg_type)
  return reg_type_;
}
inline ::std::string* RegRes::release_reg_type() {
  clear_has_reg_type();
  if (reg_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reg_type_;
    reg_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegRes::set_allocated_reg_type(::std::string* reg_type) {
  if (reg_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reg_type_;
  }
  if (reg_type) {
    set_has_reg_type();
    reg_type_ = reg_type;
  } else {
    clear_has_reg_type();
    reg_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.RegRes.reg_type)
}

// optional float score = 2;
inline bool RegRes::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegRes::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegRes::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegRes::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float RegRes::score() const {
  // @@protoc_insertion_point(field_get:vas.RegRes.score)
  return score_;
}
inline void RegRes::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:vas.RegRes.score)
}

// optional int32 x = 3;
inline bool RegRes::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegRes::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegRes::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegRes::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 RegRes::x() const {
  // @@protoc_insertion_point(field_get:vas.RegRes.x)
  return x_;
}
inline void RegRes::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:vas.RegRes.x)
}

// optional int32 y = 4;
inline bool RegRes::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegRes::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegRes::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegRes::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 RegRes::y() const {
  // @@protoc_insertion_point(field_get:vas.RegRes.y)
  return y_;
}
inline void RegRes::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:vas.RegRes.y)
}

// optional int32 width = 5;
inline bool RegRes::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegRes::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegRes::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegRes::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 RegRes::width() const {
  // @@protoc_insertion_point(field_get:vas.RegRes.width)
  return width_;
}
inline void RegRes::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:vas.RegRes.width)
}

// optional int32 height = 6;
inline bool RegRes::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegRes::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegRes::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegRes::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 RegRes::height() const {
  // @@protoc_insertion_point(field_get:vas.RegRes.height)
  return height_;
}
inline void RegRes::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:vas.RegRes.height)
}

// -------------------------------------------------------------------

// VasResultParameter

// optional int32 node_id = 1;
inline bool VasResultParameter::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasResultParameter::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasResultParameter::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasResultParameter::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 VasResultParameter::node_id() const {
  // @@protoc_insertion_point(field_get:vas.VasResultParameter.node_id)
  return node_id_;
}
inline void VasResultParameter::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vas.VasResultParameter.node_id)
}

// optional string service_id = 2;
inline bool VasResultParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasResultParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasResultParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasResultParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& VasResultParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.VasResultParameter.service_id)
  return *service_id_;
}
inline void VasResultParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasResultParameter.service_id)
}
inline void VasResultParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasResultParameter.service_id)
}
inline void VasResultParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasResultParameter.service_id)
}
inline ::std::string* VasResultParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasResultParameter.service_id)
  return service_id_;
}
inline ::std::string* VasResultParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasResultParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasResultParameter.service_id)
}

// repeated .vas.RegRes result_rects = 3;
inline int VasResultParameter::result_rects_size() const {
  return result_rects_.size();
}
inline void VasResultParameter::clear_result_rects() {
  result_rects_.Clear();
}
inline const ::vas::RegRes& VasResultParameter::result_rects(int index) const {
  // @@protoc_insertion_point(field_get:vas.VasResultParameter.result_rects)
  return result_rects_.Get(index);
}
inline ::vas::RegRes* VasResultParameter::mutable_result_rects(int index) {
  // @@protoc_insertion_point(field_mutable:vas.VasResultParameter.result_rects)
  return result_rects_.Mutable(index);
}
inline ::vas::RegRes* VasResultParameter::add_result_rects() {
  // @@protoc_insertion_point(field_add:vas.VasResultParameter.result_rects)
  return result_rects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vas::RegRes >&
VasResultParameter::result_rects() const {
  // @@protoc_insertion_point(field_list:vas.VasResultParameter.result_rects)
  return result_rects_;
}
inline ::google::protobuf::RepeatedPtrField< ::vas::RegRes >*
VasResultParameter::mutable_result_rects() {
  // @@protoc_insertion_point(field_mutable_list:vas.VasResultParameter.result_rects)
  return &result_rects_;
}

// optional int64 timestamp = 4;
inline bool VasResultParameter::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VasResultParameter::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VasResultParameter::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VasResultParameter::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 VasResultParameter::timestamp() const {
  // @@protoc_insertion_point(field_get:vas.VasResultParameter.timestamp)
  return timestamp_;
}
inline void VasResultParameter::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vas.VasResultParameter.timestamp)
}

// -------------------------------------------------------------------

// VasResult

// optional string psi_name = 1;
inline bool VasResult::has_psi_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasResult::set_has_psi_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasResult::clear_has_psi_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasResult::clear_psi_name() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_->clear();
  }
  clear_has_psi_name();
}
inline const ::std::string& VasResult::psi_name() const {
  // @@protoc_insertion_point(field_get:vas.VasResult.psi_name)
  return *psi_name_;
}
inline void VasResult::set_psi_name(const ::std::string& value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasResult.psi_name)
}
inline void VasResult::set_psi_name(const char* value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasResult.psi_name)
}
inline void VasResult::set_psi_name(const char* value, size_t size) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasResult.psi_name)
}
inline ::std::string* VasResult::mutable_psi_name() {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasResult.psi_name)
  return psi_name_;
}
inline ::std::string* VasResult::release_psi_name() {
  clear_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = psi_name_;
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasResult::set_allocated_psi_name(::std::string* psi_name) {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (psi_name) {
    set_has_psi_name();
    psi_name_ = psi_name;
  } else {
    clear_has_psi_name();
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasResult.psi_name)
}

// optional .vas.VasResultParameter params = 2;
inline bool VasResult::has_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasResult::set_has_params() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasResult::clear_has_params() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasResult::clear_params() {
  if (params_ != NULL) params_->::vas::VasResultParameter::Clear();
  clear_has_params();
}
inline const ::vas::VasResultParameter& VasResult::params() const {
  // @@protoc_insertion_point(field_get:vas.VasResult.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::vas::VasResultParameter* VasResult::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::vas::VasResultParameter;
  // @@protoc_insertion_point(field_mutable:vas.VasResult.params)
  return params_;
}
inline ::vas::VasResultParameter* VasResult::release_params() {
  clear_has_params();
  ::vas::VasResultParameter* temp = params_;
  params_ = NULL;
  return temp;
}
inline void VasResult::set_allocated_params(::vas::VasResultParameter* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasResult.params)
}

// -------------------------------------------------------------------

// VasFeedbackParameter

// optional int32 node_id = 1;
inline bool VasFeedbackParameter::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasFeedbackParameter::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasFeedbackParameter::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasFeedbackParameter::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 VasFeedbackParameter::node_id() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.node_id)
  return node_id_;
}
inline void VasFeedbackParameter::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.node_id)
}

// optional string service_id = 2;
inline bool VasFeedbackParameter::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasFeedbackParameter::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasFeedbackParameter::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasFeedbackParameter::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& VasFeedbackParameter::service_id() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.service_id)
  return *service_id_;
}
inline void VasFeedbackParameter::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.service_id)
}
inline void VasFeedbackParameter::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasFeedbackParameter.service_id)
}
inline void VasFeedbackParameter::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasFeedbackParameter.service_id)
}
inline ::std::string* VasFeedbackParameter::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasFeedbackParameter.service_id)
  return service_id_;
}
inline ::std::string* VasFeedbackParameter::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasFeedbackParameter::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedbackParameter.service_id)
}

// optional string address_type = 3;
inline bool VasFeedbackParameter::has_address_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VasFeedbackParameter::set_has_address_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VasFeedbackParameter::clear_has_address_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VasFeedbackParameter::clear_address_type() {
  if (address_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_type_->clear();
  }
  clear_has_address_type();
}
inline const ::std::string& VasFeedbackParameter::address_type() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.address_type)
  return *address_type_;
}
inline void VasFeedbackParameter::set_address_type(const ::std::string& value) {
  set_has_address_type();
  if (address_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_type_ = new ::std::string;
  }
  address_type_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.address_type)
}
inline void VasFeedbackParameter::set_address_type(const char* value) {
  set_has_address_type();
  if (address_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_type_ = new ::std::string;
  }
  address_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasFeedbackParameter.address_type)
}
inline void VasFeedbackParameter::set_address_type(const char* value, size_t size) {
  set_has_address_type();
  if (address_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_type_ = new ::std::string;
  }
  address_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasFeedbackParameter.address_type)
}
inline ::std::string* VasFeedbackParameter::mutable_address_type() {
  set_has_address_type();
  if (address_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasFeedbackParameter.address_type)
  return address_type_;
}
inline ::std::string* VasFeedbackParameter::release_address_type() {
  clear_has_address_type();
  if (address_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_type_;
    address_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasFeedbackParameter::set_allocated_address_type(::std::string* address_type) {
  if (address_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_type_;
  }
  if (address_type) {
    set_has_address_type();
    address_type_ = address_type;
  } else {
    clear_has_address_type();
    address_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedbackParameter.address_type)
}

// optional string device_id = 4;
inline bool VasFeedbackParameter::has_device_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VasFeedbackParameter::set_has_device_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VasFeedbackParameter::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VasFeedbackParameter::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& VasFeedbackParameter::device_id() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.device_id)
  return *device_id_;
}
inline void VasFeedbackParameter::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.device_id)
}
inline void VasFeedbackParameter::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasFeedbackParameter.device_id)
}
inline void VasFeedbackParameter::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasFeedbackParameter.device_id)
}
inline ::std::string* VasFeedbackParameter::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasFeedbackParameter.device_id)
  return device_id_;
}
inline ::std::string* VasFeedbackParameter::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasFeedbackParameter::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedbackParameter.device_id)
}

// optional string device_channel = 5;
inline bool VasFeedbackParameter::has_device_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VasFeedbackParameter::set_has_device_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VasFeedbackParameter::clear_has_device_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VasFeedbackParameter::clear_device_channel() {
  if (device_channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_channel_->clear();
  }
  clear_has_device_channel();
}
inline const ::std::string& VasFeedbackParameter::device_channel() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.device_channel)
  return *device_channel_;
}
inline void VasFeedbackParameter::set_device_channel(const ::std::string& value) {
  set_has_device_channel();
  if (device_channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_channel_ = new ::std::string;
  }
  device_channel_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.device_channel)
}
inline void VasFeedbackParameter::set_device_channel(const char* value) {
  set_has_device_channel();
  if (device_channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_channel_ = new ::std::string;
  }
  device_channel_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasFeedbackParameter.device_channel)
}
inline void VasFeedbackParameter::set_device_channel(const char* value, size_t size) {
  set_has_device_channel();
  if (device_channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_channel_ = new ::std::string;
  }
  device_channel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasFeedbackParameter.device_channel)
}
inline ::std::string* VasFeedbackParameter::mutable_device_channel() {
  set_has_device_channel();
  if (device_channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_channel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasFeedbackParameter.device_channel)
  return device_channel_;
}
inline ::std::string* VasFeedbackParameter::release_device_channel() {
  clear_has_device_channel();
  if (device_channel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_channel_;
    device_channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasFeedbackParameter::set_allocated_device_channel(::std::string* device_channel) {
  if (device_channel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_channel_;
  }
  if (device_channel) {
    set_has_device_channel();
    device_channel_ = device_channel;
  } else {
    clear_has_device_channel();
    device_channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedbackParameter.device_channel)
}

// optional string address = 6;
inline bool VasFeedbackParameter::has_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VasFeedbackParameter::set_has_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VasFeedbackParameter::clear_has_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VasFeedbackParameter::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& VasFeedbackParameter::address() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.address)
  return *address_;
}
inline void VasFeedbackParameter::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.address)
}
inline void VasFeedbackParameter::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasFeedbackParameter.address)
}
inline void VasFeedbackParameter::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasFeedbackParameter.address)
}
inline ::std::string* VasFeedbackParameter::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasFeedbackParameter.address)
  return address_;
}
inline ::std::string* VasFeedbackParameter::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasFeedbackParameter::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedbackParameter.address)
}

// optional int32 feedback_code = 7;
inline bool VasFeedbackParameter::has_feedback_code() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VasFeedbackParameter::set_has_feedback_code() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VasFeedbackParameter::clear_has_feedback_code() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VasFeedbackParameter::clear_feedback_code() {
  feedback_code_ = 0;
  clear_has_feedback_code();
}
inline ::google::protobuf::int32 VasFeedbackParameter::feedback_code() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.feedback_code)
  return feedback_code_;
}
inline void VasFeedbackParameter::set_feedback_code(::google::protobuf::int32 value) {
  set_has_feedback_code();
  feedback_code_ = value;
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.feedback_code)
}

// optional string feedback_info = 8;
inline bool VasFeedbackParameter::has_feedback_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VasFeedbackParameter::set_has_feedback_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VasFeedbackParameter::clear_has_feedback_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VasFeedbackParameter::clear_feedback_info() {
  if (feedback_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feedback_info_->clear();
  }
  clear_has_feedback_info();
}
inline const ::std::string& VasFeedbackParameter::feedback_info() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.feedback_info)
  return *feedback_info_;
}
inline void VasFeedbackParameter::set_feedback_info(const ::std::string& value) {
  set_has_feedback_info();
  if (feedback_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feedback_info_ = new ::std::string;
  }
  feedback_info_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.feedback_info)
}
inline void VasFeedbackParameter::set_feedback_info(const char* value) {
  set_has_feedback_info();
  if (feedback_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feedback_info_ = new ::std::string;
  }
  feedback_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasFeedbackParameter.feedback_info)
}
inline void VasFeedbackParameter::set_feedback_info(const char* value, size_t size) {
  set_has_feedback_info();
  if (feedback_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feedback_info_ = new ::std::string;
  }
  feedback_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasFeedbackParameter.feedback_info)
}
inline ::std::string* VasFeedbackParameter::mutable_feedback_info() {
  set_has_feedback_info();
  if (feedback_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    feedback_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasFeedbackParameter.feedback_info)
  return feedback_info_;
}
inline ::std::string* VasFeedbackParameter::release_feedback_info() {
  clear_has_feedback_info();
  if (feedback_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = feedback_info_;
    feedback_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasFeedbackParameter::set_allocated_feedback_info(::std::string* feedback_info) {
  if (feedback_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete feedback_info_;
  }
  if (feedback_info) {
    set_has_feedback_info();
    feedback_info_ = feedback_info;
  } else {
    clear_has_feedback_info();
    feedback_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedbackParameter.feedback_info)
}

// optional int64 timestamp = 9;
inline bool VasFeedbackParameter::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VasFeedbackParameter::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VasFeedbackParameter::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VasFeedbackParameter::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 VasFeedbackParameter::timestamp() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedbackParameter.timestamp)
  return timestamp_;
}
inline void VasFeedbackParameter::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vas.VasFeedbackParameter.timestamp)
}

// -------------------------------------------------------------------

// VasFeedback

// optional string psi_name = 1;
inline bool VasFeedback::has_psi_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VasFeedback::set_has_psi_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VasFeedback::clear_has_psi_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VasFeedback::clear_psi_name() {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_->clear();
  }
  clear_has_psi_name();
}
inline const ::std::string& VasFeedback::psi_name() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedback.psi_name)
  return *psi_name_;
}
inline void VasFeedback::set_psi_name(const ::std::string& value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set:vas.VasFeedback.psi_name)
}
inline void VasFeedback::set_psi_name(const char* value) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:vas.VasFeedback.psi_name)
}
inline void VasFeedback::set_psi_name(const char* value, size_t size) {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  psi_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vas.VasFeedback.psi_name)
}
inline ::std::string* VasFeedback::mutable_psi_name() {
  set_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    psi_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:vas.VasFeedback.psi_name)
  return psi_name_;
}
inline ::std::string* VasFeedback::release_psi_name() {
  clear_has_psi_name();
  if (psi_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = psi_name_;
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VasFeedback::set_allocated_psi_name(::std::string* psi_name) {
  if (psi_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete psi_name_;
  }
  if (psi_name) {
    set_has_psi_name();
    psi_name_ = psi_name;
  } else {
    clear_has_psi_name();
    psi_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedback.psi_name)
}

// optional .vas.VasFeedbackParameter params = 2;
inline bool VasFeedback::has_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VasFeedback::set_has_params() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VasFeedback::clear_has_params() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VasFeedback::clear_params() {
  if (params_ != NULL) params_->::vas::VasFeedbackParameter::Clear();
  clear_has_params();
}
inline const ::vas::VasFeedbackParameter& VasFeedback::params() const {
  // @@protoc_insertion_point(field_get:vas.VasFeedback.params)
  return params_ != NULL ? *params_ : *default_instance_->params_;
}
inline ::vas::VasFeedbackParameter* VasFeedback::mutable_params() {
  set_has_params();
  if (params_ == NULL) params_ = new ::vas::VasFeedbackParameter;
  // @@protoc_insertion_point(field_mutable:vas.VasFeedback.params)
  return params_;
}
inline ::vas::VasFeedbackParameter* VasFeedback::release_params() {
  clear_has_params();
  ::vas::VasFeedbackParameter* temp = params_;
  params_ = NULL;
  return temp;
}
inline void VasFeedback::set_allocated_params(::vas::VasFeedbackParameter* params) {
  delete params_;
  params_ = params;
  if (params) {
    set_has_params();
  } else {
    clear_has_params();
  }
  // @@protoc_insertion_point(field_set_allocated:vas.VasFeedback.params)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vas

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vas::DecodeMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::DecodeMethod>() {
  return ::vas::DecodeMethod_descriptor();
}
template <> struct is_proto_enum< ::vas::VideoSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::VideoSource>() {
  return ::vas::VideoSource_descriptor();
}
template <> struct is_proto_enum< ::vas::CamStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::CamStatus>() {
  return ::vas::CamStatus_descriptor();
}
template <> struct is_proto_enum< ::vas::StreamStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::StreamStatus>() {
  return ::vas::StreamStatus_descriptor();
}
template <> struct is_proto_enum< ::vas::BgStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::BgStatus>() {
  return ::vas::BgStatus_descriptor();
}
template <> struct is_proto_enum< ::vas::BgMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::BgMethod>() {
  return ::vas::BgMethod_descriptor();
}
template <> struct is_proto_enum< ::vas::FilterMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::FilterMethod>() {
  return ::vas::FilterMethod_descriptor();
}
template <> struct is_proto_enum< ::vas::FilterType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::FilterType>() {
  return ::vas::FilterType_descriptor();
}
template <> struct is_proto_enum< ::vas::DetectStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::DetectStatus>() {
  return ::vas::DetectStatus_descriptor();
}
template <> struct is_proto_enum< ::vas::ServiceStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::ServiceStatus>() {
  return ::vas::ServiceStatus_descriptor();
}
template <> struct is_proto_enum< ::vas::ServiceCommandReply> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::ServiceCommandReply>() {
  return ::vas::ServiceCommandReply_descriptor();
}
template <> struct is_proto_enum< ::vas::RegMsgSubscribe> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::RegMsgSubscribe>() {
  return ::vas::RegMsgSubscribe_descriptor();
}
template <> struct is_proto_enum< ::vas::EnAppState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vas::EnAppState>() {
  return ::vas::EnAppState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_VasProto_2eprototxt__INCLUDED
